/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DatacatalogConnectionInitParameters struct {

	// Unique catalog identifier.
	CatalogID *string `json:"catalogId,omitempty" tf:"catalog_id,omitempty"`

	// Unique data asset key.
	DataAssetKey *string `json:"dataAssetKey,omitempty" tf:"data_asset_key,omitempty"`

	// (Updatable) A description of the connection.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	EncProperties map[string]*string `json:"encPropertiesSecretRef,omitempty" tf:"-"`

	// (Updatable) Indicates whether this connection is the default connection. The first connection of a data asset defaults to being the default, subsequent connections default to not being the default. If a default connection already exists, then trying to create a connection as the default will fail. In this case the default connection would need to be updated not to be the default and then the new connection can then be created as the default.
	IsDefault *bool `json:"isDefault,omitempty" tf:"is_default,omitempty"`

	// (Updatable) A map of maps that contains the properties which are specific to the connection type. Each connection type definition defines it's set of required and optional properties. The map keys are category names and the values are maps of property name to property value. Every property is contained inside of a category. Most connections have required properties within the "default" category. To determine the set of optional and required properties for a connection type, a query can be done on '/types?type=connection' that returns a collection of all connection types. The appropriate connection type, which will include definitions of all of it's properties, can be identified from this collection. Example: {"properties": { "default": { "username": "user1"}}} . denoting each level. For more information check out this example
	// +mapType=granular
	Properties map[string]*string `json:"properties,omitempty" tf:"properties,omitempty"`

	// The key of the object type. Type key's can be found via the '/types' endpoint.
	TypeKey *string `json:"typeKey,omitempty" tf:"type_key,omitempty"`
}

type DatacatalogConnectionObservation struct {

	// Unique catalog identifier.
	CatalogID *string `json:"catalogId,omitempty" tf:"catalog_id,omitempty"`

	// OCID of the user who created the connection.
	CreatedByID *string `json:"createdById,omitempty" tf:"created_by_id,omitempty"`

	// Unique data asset key.
	DataAssetKey *string `json:"dataAssetKey,omitempty" tf:"data_asset_key,omitempty"`

	// (Updatable) A description of the connection.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Unique external key of this object from the source system.
	ExternalKey *string `json:"externalKey,omitempty" tf:"external_key,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Updatable) Indicates whether this connection is the default connection. The first connection of a data asset defaults to being the default, subsequent connections default to not being the default. If a default connection already exists, then trying to create a connection as the default will fail. In this case the default connection would need to be updated not to be the default and then the new connection can then be created as the default.
	IsDefault *bool `json:"isDefault,omitempty" tf:"is_default,omitempty"`

	// Unique connection key that is immutable.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Updatable) A map of maps that contains the properties which are specific to the connection type. Each connection type definition defines it's set of required and optional properties. The map keys are category names and the values are maps of property name to property value. Every property is contained inside of a category. Most connections have required properties within the "default" category. To determine the set of optional and required properties for a connection type, a query can be done on '/types?type=connection' that returns a collection of all connection types. The appropriate connection type, which will include definitions of all of it's properties, can be identified from this collection. Example: {"properties": { "default": { "username": "user1"}}} . denoting each level. For more information check out this example
	// +mapType=granular
	Properties map[string]*string `json:"properties,omitempty" tf:"properties,omitempty"`

	// The current state of the connection.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The date and time the connection was created, in the format defined by RFC3339. Example: 2019-03-25T21:10:29.600Z
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// Time that the connections status was last updated. An RFC3339 formatted datetime string.
	TimeStatusUpdated *string `json:"timeStatusUpdated,omitempty" tf:"time_status_updated,omitempty"`

	// The last time that any change was made to the connection. An RFC3339 formatted datetime string.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`

	// The key of the object type. Type key's can be found via the '/types' endpoint.
	TypeKey *string `json:"typeKey,omitempty" tf:"type_key,omitempty"`

	// URI to the connection instance in the API.
	URI *string `json:"uri,omitempty" tf:"uri,omitempty"`

	// OCID of the user who modified the connection.
	UpdatedByID *string `json:"updatedById,omitempty" tf:"updated_by_id,omitempty"`
}

type DatacatalogConnectionParameters struct {

	// Unique catalog identifier.
	// +kubebuilder:validation:Optional
	CatalogID *string `json:"catalogId,omitempty" tf:"catalog_id,omitempty"`

	// Unique data asset key.
	// +kubebuilder:validation:Optional
	DataAssetKey *string `json:"dataAssetKey,omitempty" tf:"data_asset_key,omitempty"`

	// (Updatable) A description of the connection.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) A map of maps that contains the encrypted values for sensitive properties which are specific to the connection type. Each connection type definition defines it's set of required and optional properties. The map keys are category names and the values are maps of property name to property value. Every property is contained inside of a category. Most connections have required properties within the "default" category. To determine the set of optional and required properties for a connection type, a query can be done on '/types?type=connection' that returns a collection of all connection types. The appropriate connection type, which will include definitions of all of it's properties, can be identified from this collection. Example: {"encProperties": { "default": { "password": "example-password"}}}
	// +kubebuilder:validation:Optional
	EncPropertiesSecretRef *v1.SecretReference `json:"encPropertiesSecretRef,omitempty" tf:"-"`

	// (Updatable) Indicates whether this connection is the default connection. The first connection of a data asset defaults to being the default, subsequent connections default to not being the default. If a default connection already exists, then trying to create a connection as the default will fail. In this case the default connection would need to be updated not to be the default and then the new connection can then be created as the default.
	// +kubebuilder:validation:Optional
	IsDefault *bool `json:"isDefault,omitempty" tf:"is_default,omitempty"`

	// (Updatable) A map of maps that contains the properties which are specific to the connection type. Each connection type definition defines it's set of required and optional properties. The map keys are category names and the values are maps of property name to property value. Every property is contained inside of a category. Most connections have required properties within the "default" category. To determine the set of optional and required properties for a connection type, a query can be done on '/types?type=connection' that returns a collection of all connection types. The appropriate connection type, which will include definitions of all of it's properties, can be identified from this collection. Example: {"properties": { "default": { "username": "user1"}}} . denoting each level. For more information check out this example
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Properties map[string]*string `json:"properties,omitempty" tf:"properties,omitempty"`

	// The key of the object type. Type key's can be found via the '/types' endpoint.
	// +kubebuilder:validation:Optional
	TypeKey *string `json:"typeKey,omitempty" tf:"type_key,omitempty"`
}

// DatacatalogConnectionSpec defines the desired state of DatacatalogConnection
type DatacatalogConnectionSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DatacatalogConnectionParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider DatacatalogConnectionInitParameters `json:"initProvider,omitempty"`
}

// DatacatalogConnectionStatus defines the observed state of DatacatalogConnection.
type DatacatalogConnectionStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DatacatalogConnectionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// DatacatalogConnection is the Schema for the DatacatalogConnections API. Provides the Connection resource in Oracle Cloud Infrastructure Data Catalog service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type DatacatalogConnection struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.catalogId) || (has(self.initProvider) && has(self.initProvider.catalogId))",message="spec.forProvider.catalogId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.dataAssetKey) || (has(self.initProvider) && has(self.initProvider.dataAssetKey))",message="spec.forProvider.dataAssetKey is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.displayName) || (has(self.initProvider) && has(self.initProvider.displayName))",message="spec.forProvider.displayName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.properties) || (has(self.initProvider) && has(self.initProvider.properties))",message="spec.forProvider.properties is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.typeKey) || (has(self.initProvider) && has(self.initProvider.typeKey))",message="spec.forProvider.typeKey is a required parameter"
	Spec   DatacatalogConnectionSpec   `json:"spec"`
	Status DatacatalogConnectionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DatacatalogConnectionList contains a list of DatacatalogConnections
type DatacatalogConnectionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DatacatalogConnection `json:"items"`
}

// Repository type metadata.
var (
	DatacatalogConnection_Kind             = "DatacatalogConnection"
	DatacatalogConnection_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DatacatalogConnection_Kind}.String()
	DatacatalogConnection_KindAPIVersion   = DatacatalogConnection_Kind + "." + CRDGroupVersion.String()
	DatacatalogConnection_GroupVersionKind = CRDGroupVersion.WithKind(DatacatalogConnection_Kind)
)

func init() {
	SchemeBuilder.Register(&DatacatalogConnection{}, &DatacatalogConnectionList{})
}
