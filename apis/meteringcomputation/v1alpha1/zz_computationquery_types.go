/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ComputationQueryInitParameters struct {

	// The compartment OCID.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) The common fields for queries.
	QueryDefinition []QueryDefinitionInitParameters `json:"queryDefinition,omitempty" tf:"query_definition,omitempty"`
}

type ComputationQueryObservation struct {

	// The compartment OCID.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// The query OCID.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Updatable) The common fields for queries.
	QueryDefinition []QueryDefinitionObservation `json:"queryDefinition,omitempty" tf:"query_definition,omitempty"`
}

type ComputationQueryParameters struct {

	// The compartment OCID.
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) The common fields for queries.
	// +kubebuilder:validation:Optional
	QueryDefinition []QueryDefinitionParameters `json:"queryDefinition,omitempty" tf:"query_definition,omitempty"`
}

type CostAnalysisUIInitParameters struct {

	// (Updatable) The graph type.
	Graph *string `json:"graph,omitempty" tf:"graph,omitempty"`

	// (Updatable) A cumulative graph.
	IsCumulativeGraph *bool `json:"isCumulativeGraph,omitempty" tf:"is_cumulative_graph,omitempty"`
}

type CostAnalysisUIObservation struct {

	// (Updatable) The graph type.
	Graph *string `json:"graph,omitempty" tf:"graph,omitempty"`

	// (Updatable) A cumulative graph.
	IsCumulativeGraph *bool `json:"isCumulativeGraph,omitempty" tf:"is_cumulative_graph,omitempty"`
}

type CostAnalysisUIParameters struct {

	// (Updatable) The graph type.
	// +kubebuilder:validation:Optional
	Graph *string `json:"graph,omitempty" tf:"graph,omitempty"`

	// (Updatable) A cumulative graph.
	// +kubebuilder:validation:Optional
	IsCumulativeGraph *bool `json:"isCumulativeGraph,omitempty" tf:"is_cumulative_graph,omitempty"`
}

type ForecastInitParameters struct {

	// (Updatable) BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
	ForecastType *string `json:"forecastType,omitempty" tf:"forecast_type,omitempty"`

	// (Updatable) The forecast end time.
	TimeForecastEnded *string `json:"timeForecastEnded,omitempty" tf:"time_forecast_ended,omitempty"`

	// (Updatable) The forecast start time. Defaults to UTC-1 if not specified.
	TimeForecastStarted *string `json:"timeForecastStarted,omitempty" tf:"time_forecast_started,omitempty"`
}

type ForecastObservation struct {

	// (Updatable) BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
	ForecastType *string `json:"forecastType,omitempty" tf:"forecast_type,omitempty"`

	// (Updatable) The forecast end time.
	TimeForecastEnded *string `json:"timeForecastEnded,omitempty" tf:"time_forecast_ended,omitempty"`

	// (Updatable) The forecast start time. Defaults to UTC-1 if not specified.
	TimeForecastStarted *string `json:"timeForecastStarted,omitempty" tf:"time_forecast_started,omitempty"`
}

type ForecastParameters struct {

	// (Updatable) BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
	// +kubebuilder:validation:Optional
	ForecastType *string `json:"forecastType,omitempty" tf:"forecast_type,omitempty"`

	// (Updatable) The forecast end time.
	// +kubebuilder:validation:Optional
	TimeForecastEnded *string `json:"timeForecastEnded" tf:"time_forecast_ended,omitempty"`

	// (Updatable) The forecast start time. Defaults to UTC-1 if not specified.
	// +kubebuilder:validation:Optional
	TimeForecastStarted *string `json:"timeForecastStarted,omitempty" tf:"time_forecast_started,omitempty"`
}

type QueryDefinitionInitParameters struct {

	// (Updatable) The common fields for Cost Analysis UI rendering.
	CostAnalysisUI []CostAnalysisUIInitParameters `json:"costAnalysisUi,omitempty" tf:"cost_analysis_ui,omitempty"`

	// (Updatable) The query display name. Avoid entering confidential information.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) The request of the generated Cost Analysis report.
	ReportQuery []ReportQueryInitParameters `json:"reportQuery,omitempty" tf:"report_query,omitempty"`

	// (Updatable) The saved query version.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type QueryDefinitionObservation struct {

	// (Updatable) The common fields for Cost Analysis UI rendering.
	CostAnalysisUI []CostAnalysisUIObservation `json:"costAnalysisUi,omitempty" tf:"cost_analysis_ui,omitempty"`

	// (Updatable) The query display name. Avoid entering confidential information.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) The request of the generated Cost Analysis report.
	ReportQuery []ReportQueryObservation `json:"reportQuery,omitempty" tf:"report_query,omitempty"`

	// (Updatable) The saved query version.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type QueryDefinitionParameters struct {

	// (Updatable) The common fields for Cost Analysis UI rendering.
	// +kubebuilder:validation:Optional
	CostAnalysisUI []CostAnalysisUIParameters `json:"costAnalysisUi" tf:"cost_analysis_ui,omitempty"`

	// (Updatable) The query display name. Avoid entering confidential information.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName" tf:"display_name,omitempty"`

	// (Updatable) The request of the generated Cost Analysis report.
	// +kubebuilder:validation:Optional
	ReportQuery []ReportQueryParameters `json:"reportQuery" tf:"report_query,omitempty"`

	// (Updatable) The saved query version.
	// +kubebuilder:validation:Optional
	Version *float64 `json:"version" tf:"version,omitempty"`
}

type ReportQueryGroupByTagInitParameters struct {

	// (Updatable) The tag key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Updatable) The tag namespace.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (Updatable) The tag value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ReportQueryGroupByTagObservation struct {

	// (Updatable) The tag key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Updatable) The tag namespace.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (Updatable) The tag value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ReportQueryGroupByTagParameters struct {

	// (Updatable) The tag key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Updatable) The tag namespace.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (Updatable) The tag value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ReportQueryInitParameters struct {

	// (Updatable) The compartment depth level.
	CompartmentDepth *float64 `json:"compartmentDepth,omitempty" tf:"compartment_depth,omitempty"`

	// (Updatable) The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
	DateRangeName *string `json:"dateRangeName,omitempty" tf:"date_range_name,omitempty"`

	// (Updatable) The filter object for query usage.
	Filter *string `json:"filter,omitempty" tf:"filter,omitempty"`

	// (Updatable) Forecast configuration of usage/cost.
	Forecast []ForecastInitParameters `json:"forecast,omitempty" tf:"forecast,omitempty"`

	// (Updatable) The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity *string `json:"granularity,omitempty" tf:"granularity,omitempty"`

	// (Updatable) Specifies what to aggregate the result by. For example: ["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]
	GroupBy []*string `json:"groupBy,omitempty" tf:"group_by,omitempty"`

	// (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [{"namespace":"oracle", "key":"createdBy"]
	GroupByTag []ReportQueryGroupByTagInitParameters `json:"groupByTag,omitempty" tf:"group_by_tag,omitempty"`

	// (Updatable) Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
	IsAggregateByTime *bool `json:"isAggregateByTime,omitempty" tf:"is_aggregate_by_time,omitempty"`

	// (Updatable) The query usage type. COST by default if it is missing.
	QueryType *string `json:"queryType,omitempty" tf:"query_type,omitempty"`

	// (Updatable) Tenant ID.
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`

	// (Updatable) The usage end time.
	TimeUsageEnded *string `json:"timeUsageEnded,omitempty" tf:"time_usage_ended,omitempty"`

	// (Updatable) The usage start time.
	TimeUsageStarted *string `json:"timeUsageStarted,omitempty" tf:"time_usage_started,omitempty"`
}

type ReportQueryObservation struct {

	// (Updatable) The compartment depth level.
	CompartmentDepth *float64 `json:"compartmentDepth,omitempty" tf:"compartment_depth,omitempty"`

	// (Updatable) The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
	DateRangeName *string `json:"dateRangeName,omitempty" tf:"date_range_name,omitempty"`

	// (Updatable) The filter object for query usage.
	Filter *string `json:"filter,omitempty" tf:"filter,omitempty"`

	// (Updatable) Forecast configuration of usage/cost.
	Forecast []ForecastObservation `json:"forecast,omitempty" tf:"forecast,omitempty"`

	// (Updatable) The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity *string `json:"granularity,omitempty" tf:"granularity,omitempty"`

	// (Updatable) Specifies what to aggregate the result by. For example: ["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]
	GroupBy []*string `json:"groupBy,omitempty" tf:"group_by,omitempty"`

	// (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [{"namespace":"oracle", "key":"createdBy"]
	GroupByTag []ReportQueryGroupByTagObservation `json:"groupByTag,omitempty" tf:"group_by_tag,omitempty"`

	// (Updatable) Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
	IsAggregateByTime *bool `json:"isAggregateByTime,omitempty" tf:"is_aggregate_by_time,omitempty"`

	// (Updatable) The query usage type. COST by default if it is missing.
	QueryType *string `json:"queryType,omitempty" tf:"query_type,omitempty"`

	// (Updatable) Tenant ID.
	TenantID *string `json:"tenantId,omitempty" tf:"tenant_id,omitempty"`

	// (Updatable) The usage end time.
	TimeUsageEnded *string `json:"timeUsageEnded,omitempty" tf:"time_usage_ended,omitempty"`

	// (Updatable) The usage start time.
	TimeUsageStarted *string `json:"timeUsageStarted,omitempty" tf:"time_usage_started,omitempty"`
}

type ReportQueryParameters struct {

	// (Updatable) The compartment depth level.
	// +kubebuilder:validation:Optional
	CompartmentDepth *float64 `json:"compartmentDepth,omitempty" tf:"compartment_depth,omitempty"`

	// (Updatable) The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
	// +kubebuilder:validation:Optional
	DateRangeName *string `json:"dateRangeName,omitempty" tf:"date_range_name,omitempty"`

	// (Updatable) The filter object for query usage.
	// +kubebuilder:validation:Optional
	Filter *string `json:"filter,omitempty" tf:"filter,omitempty"`

	// (Updatable) Forecast configuration of usage/cost.
	// +kubebuilder:validation:Optional
	Forecast []ForecastParameters `json:"forecast,omitempty" tf:"forecast,omitempty"`

	// (Updatable) The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	// +kubebuilder:validation:Optional
	Granularity *string `json:"granularity" tf:"granularity,omitempty"`

	// (Updatable) Specifies what to aggregate the result by. For example: ["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]
	// +kubebuilder:validation:Optional
	GroupBy []*string `json:"groupBy,omitempty" tf:"group_by,omitempty"`

	// (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [{"namespace":"oracle", "key":"createdBy"]
	// +kubebuilder:validation:Optional
	GroupByTag []ReportQueryGroupByTagParameters `json:"groupByTag,omitempty" tf:"group_by_tag,omitempty"`

	// (Updatable) Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
	// +kubebuilder:validation:Optional
	IsAggregateByTime *bool `json:"isAggregateByTime,omitempty" tf:"is_aggregate_by_time,omitempty"`

	// (Updatable) The query usage type. COST by default if it is missing.
	// +kubebuilder:validation:Optional
	QueryType *string `json:"queryType,omitempty" tf:"query_type,omitempty"`

	// (Updatable) Tenant ID.
	// +kubebuilder:validation:Optional
	TenantID *string `json:"tenantId" tf:"tenant_id,omitempty"`

	// (Updatable) The usage end time.
	// +kubebuilder:validation:Optional
	TimeUsageEnded *string `json:"timeUsageEnded,omitempty" tf:"time_usage_ended,omitempty"`

	// (Updatable) The usage start time.
	// +kubebuilder:validation:Optional
	TimeUsageStarted *string `json:"timeUsageStarted,omitempty" tf:"time_usage_started,omitempty"`
}

// ComputationQuerySpec defines the desired state of ComputationQuery
type ComputationQuerySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ComputationQueryParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ComputationQueryInitParameters `json:"initProvider,omitempty"`
}

// ComputationQueryStatus defines the observed state of ComputationQuery.
type ComputationQueryStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ComputationQueryObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ComputationQuery is the Schema for the ComputationQuerys API. Provides the Query resource in Oracle Cloud Infrastructure Metering Computation service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type ComputationQuery struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.compartmentId) || (has(self.initProvider) && has(self.initProvider.compartmentId))",message="spec.forProvider.compartmentId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.queryDefinition) || (has(self.initProvider) && has(self.initProvider.queryDefinition))",message="spec.forProvider.queryDefinition is a required parameter"
	Spec   ComputationQuerySpec   `json:"spec"`
	Status ComputationQueryStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ComputationQueryList contains a list of ComputationQuerys
type ComputationQueryList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ComputationQuery `json:"items"`
}

// Repository type metadata.
var (
	ComputationQuery_Kind             = "ComputationQuery"
	ComputationQuery_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ComputationQuery_Kind}.String()
	ComputationQuery_KindAPIVersion   = ComputationQuery_Kind + "." + CRDGroupVersion.String()
	ComputationQuery_GroupVersionKind = CRDGroupVersion.WithKind(ComputationQuery_Kind)
)

func init() {
	SchemeBuilder.Register(&ComputationQuery{}, &ComputationQueryList{})
}
