/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ComputationScheduleInitParameters struct {

	// The customer tenancy.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. See Resource Tags. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) The description of the schedule.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. See Resource Tags. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// (Updatable) Specifies the supported output file format.
	OutputFileFormat *string `json:"outputFileFormat,omitempty" tf:"output_file_format,omitempty"`

	// The query properties.
	QueryProperties []QueryPropertiesInitParameters `json:"queryProperties,omitempty" tf:"query_properties,omitempty"`

	// (Updatable) The location where usage or cost CSVs will be uploaded defined by locationType, which corresponds with type-specific characteristics.
	ResultLocation []ResultLocationInitParameters `json:"resultLocation,omitempty" tf:"result_location,omitempty"`

	// The saved report ID which can also be used to generate a query.
	SavedReportID *string `json:"savedReportId,omitempty" tf:"saved_report_id,omitempty"`

	// Specifies the frequency according to when the schedule will be run, in the x-obmcs-recurring-time format described in RFC 5545 section 3.3.10. Supported values are : ONE_TIME, DAILY, WEEKLY and MONTHLY.
	ScheduleRecurrences *string `json:"scheduleRecurrences,omitempty" tf:"schedule_recurrences,omitempty"`

	// The date and time of the first time job execution.
	TimeScheduled *string `json:"timeScheduled,omitempty" tf:"time_scheduled,omitempty"`
}

type ComputationScheduleObservation struct {

	// The customer tenancy.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. See Resource Tags. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) The description of the schedule.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. See Resource Tags. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The OCID representing a unique shedule.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Updatable) Specifies the supported output file format.
	OutputFileFormat *string `json:"outputFileFormat,omitempty" tf:"output_file_format,omitempty"`

	// The query properties.
	QueryProperties []QueryPropertiesObservation `json:"queryProperties,omitempty" tf:"query_properties,omitempty"`

	// (Updatable) The location where usage or cost CSVs will be uploaded defined by locationType, which corresponds with type-specific characteristics.
	ResultLocation []ResultLocationObservation `json:"resultLocation,omitempty" tf:"result_location,omitempty"`

	// The saved report ID which can also be used to generate a query.
	SavedReportID *string `json:"savedReportId,omitempty" tf:"saved_report_id,omitempty"`

	// Specifies the frequency according to when the schedule will be run, in the x-obmcs-recurring-time format described in RFC 5545 section 3.3.10. Supported values are : ONE_TIME, DAILY, WEEKLY and MONTHLY.
	ScheduleRecurrences *string `json:"scheduleRecurrences,omitempty" tf:"schedule_recurrences,omitempty"`

	// The schedule lifecycle state.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Usage of system tag keys. These predefined keys are scoped to namespaces. See Resource Tags. Example: {"orcl-cloud.free-tier-retained": "true"}
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// The date and time the schedule was created.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The date and time of the next job execution.
	TimeNextRun *string `json:"timeNextRun,omitempty" tf:"time_next_run,omitempty"`

	// The date and time of the first time job execution.
	TimeScheduled *string `json:"timeScheduled,omitempty" tf:"time_scheduled,omitempty"`
}

type ComputationScheduleParameters struct {

	// The customer tenancy.
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. See Resource Tags. Example: {"foo-namespace.bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) The description of the schedule.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. See Resource Tags. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// (Updatable) Specifies the supported output file format.
	// +kubebuilder:validation:Optional
	OutputFileFormat *string `json:"outputFileFormat,omitempty" tf:"output_file_format,omitempty"`

	// The query properties.
	// +kubebuilder:validation:Optional
	QueryProperties []QueryPropertiesParameters `json:"queryProperties,omitempty" tf:"query_properties,omitempty"`

	// (Updatable) The location where usage or cost CSVs will be uploaded defined by locationType, which corresponds with type-specific characteristics.
	// +kubebuilder:validation:Optional
	ResultLocation []ResultLocationParameters `json:"resultLocation,omitempty" tf:"result_location,omitempty"`

	// The saved report ID which can also be used to generate a query.
	// +kubebuilder:validation:Optional
	SavedReportID *string `json:"savedReportId,omitempty" tf:"saved_report_id,omitempty"`

	// Specifies the frequency according to when the schedule will be run, in the x-obmcs-recurring-time format described in RFC 5545 section 3.3.10. Supported values are : ONE_TIME, DAILY, WEEKLY and MONTHLY.
	// +kubebuilder:validation:Optional
	ScheduleRecurrences *string `json:"scheduleRecurrences,omitempty" tf:"schedule_recurrences,omitempty"`

	// The date and time of the first time job execution.
	// +kubebuilder:validation:Optional
	TimeScheduled *string `json:"timeScheduled,omitempty" tf:"time_scheduled,omitempty"`
}

type DateRangeInitParameters struct {

	// Defines whether the schedule date range is STATIC or DYNAMIC.
	DateRangeType *string `json:"dateRangeType,omitempty" tf:"date_range_type,omitempty"`

	DynamicDateRangeType *string `json:"dynamicDateRangeType,omitempty" tf:"dynamic_date_range_type,omitempty"`

	// The usage end time.
	TimeUsageEnded *string `json:"timeUsageEnded,omitempty" tf:"time_usage_ended,omitempty"`

	// The usage start time.
	TimeUsageStarted *string `json:"timeUsageStarted,omitempty" tf:"time_usage_started,omitempty"`
}

type DateRangeObservation struct {

	// Defines whether the schedule date range is STATIC or DYNAMIC.
	DateRangeType *string `json:"dateRangeType,omitempty" tf:"date_range_type,omitempty"`

	DynamicDateRangeType *string `json:"dynamicDateRangeType,omitempty" tf:"dynamic_date_range_type,omitempty"`

	// The usage end time.
	TimeUsageEnded *string `json:"timeUsageEnded,omitempty" tf:"time_usage_ended,omitempty"`

	// The usage start time.
	TimeUsageStarted *string `json:"timeUsageStarted,omitempty" tf:"time_usage_started,omitempty"`
}

type DateRangeParameters struct {

	// Defines whether the schedule date range is STATIC or DYNAMIC.
	// +kubebuilder:validation:Optional
	DateRangeType *string `json:"dateRangeType" tf:"date_range_type,omitempty"`

	// +kubebuilder:validation:Optional
	DynamicDateRangeType *string `json:"dynamicDateRangeType,omitempty" tf:"dynamic_date_range_type,omitempty"`

	// The usage end time.
	// +kubebuilder:validation:Optional
	TimeUsageEnded *string `json:"timeUsageEnded,omitempty" tf:"time_usage_ended,omitempty"`

	// The usage start time.
	// +kubebuilder:validation:Optional
	TimeUsageStarted *string `json:"timeUsageStarted,omitempty" tf:"time_usage_started,omitempty"`
}

type QueryPropertiesGroupByTagInitParameters struct {

	// The tag key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The tag namespace.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// The tag value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type QueryPropertiesGroupByTagObservation struct {

	// The tag key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The tag namespace.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// The tag value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type QueryPropertiesGroupByTagParameters struct {

	// The tag key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The tag namespace.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// The tag value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type QueryPropertiesInitParameters struct {

	// The depth level of the compartment.
	CompartmentDepth *float64 `json:"compartmentDepth,omitempty" tf:"compartment_depth,omitempty"`

	// Static or dynamic date range dateRangeType, which corresponds with type-specific characteristics.
	DateRange []DateRangeInitParameters `json:"dateRange,omitempty" tf:"date_range,omitempty"`

	// The filter object for query usage.
	Filter *string `json:"filter,omitempty" tf:"filter,omitempty"`

	// The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
	Granularity *string `json:"granularity,omitempty" tf:"granularity,omitempty"`

	// Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
	GroupBy []*string `json:"groupBy,omitempty" tf:"group_by,omitempty"`

	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
	GroupByTag []QueryPropertiesGroupByTagInitParameters `json:"groupByTag,omitempty" tf:"group_by_tag,omitempty"`

	// Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
	IsAggregateByTime *bool `json:"isAggregateByTime,omitempty" tf:"is_aggregate_by_time,omitempty"`

	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
	QueryType *string `json:"queryType,omitempty" tf:"query_type,omitempty"`
}

type QueryPropertiesObservation struct {

	// The depth level of the compartment.
	CompartmentDepth *float64 `json:"compartmentDepth,omitempty" tf:"compartment_depth,omitempty"`

	// Static or dynamic date range dateRangeType, which corresponds with type-specific characteristics.
	DateRange []DateRangeObservation `json:"dateRange,omitempty" tf:"date_range,omitempty"`

	// The filter object for query usage.
	Filter *string `json:"filter,omitempty" tf:"filter,omitempty"`

	// The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
	Granularity *string `json:"granularity,omitempty" tf:"granularity,omitempty"`

	// Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
	GroupBy []*string `json:"groupBy,omitempty" tf:"group_by,omitempty"`

	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
	GroupByTag []QueryPropertiesGroupByTagObservation `json:"groupByTag,omitempty" tf:"group_by_tag,omitempty"`

	// Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
	IsAggregateByTime *bool `json:"isAggregateByTime,omitempty" tf:"is_aggregate_by_time,omitempty"`

	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
	QueryType *string `json:"queryType,omitempty" tf:"query_type,omitempty"`
}

type QueryPropertiesParameters struct {

	// The depth level of the compartment.
	// +kubebuilder:validation:Optional
	CompartmentDepth *float64 `json:"compartmentDepth,omitempty" tf:"compartment_depth,omitempty"`

	// Static or dynamic date range dateRangeType, which corresponds with type-specific characteristics.
	// +kubebuilder:validation:Optional
	DateRange []DateRangeParameters `json:"dateRange" tf:"date_range,omitempty"`

	// The filter object for query usage.
	// +kubebuilder:validation:Optional
	Filter *string `json:"filter,omitempty" tf:"filter,omitempty"`

	// The usage granularity. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. Allowed values are: DAILY MONTHLY
	// +kubebuilder:validation:Optional
	Granularity *string `json:"granularity" tf:"granularity,omitempty"`

	// Aggregate the result by. For example: [ "tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName" ]
	// +kubebuilder:validation:Optional
	GroupBy []*string `json:"groupBy,omitempty" tf:"group_by,omitempty"`

	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: [ { "namespace": "oracle", "key": "createdBy" ]
	// +kubebuilder:validation:Optional
	GroupByTag []QueryPropertiesGroupByTagParameters `json:"groupByTag,omitempty" tf:"group_by_tag,omitempty"`

	// Specifies whether aggregated by time. If isAggregateByTime is true, all usage or cost over the query time period will be added up.
	// +kubebuilder:validation:Optional
	IsAggregateByTime *bool `json:"isAggregateByTime,omitempty" tf:"is_aggregate_by_time,omitempty"`

	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Allowed values are: USAGE COST USAGE_AND_COST
	// +kubebuilder:validation:Optional
	QueryType *string `json:"queryType,omitempty" tf:"query_type,omitempty"`
}

type ResultLocationInitParameters struct {

	// (Updatable) The bucket name where usage or cost CSVs will be uploaded.
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// (Updatable) Defines the type of location where the usage or cost CSVs will be stored.
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// The tag namespace.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (Updatable) The destination Object Store Region specified by the customer.
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ResultLocationObservation struct {

	// (Updatable) The bucket name where usage or cost CSVs will be uploaded.
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// (Updatable) Defines the type of location where the usage or cost CSVs will be stored.
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// The tag namespace.
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// (Updatable) The destination Object Store Region specified by the customer.
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ResultLocationParameters struct {

	// (Updatable) The bucket name where usage or cost CSVs will be uploaded.
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// (Updatable) Defines the type of location where the usage or cost CSVs will be stored.
	// +kubebuilder:validation:Optional
	LocationType *string `json:"locationType" tf:"location_type,omitempty"`

	// The tag namespace.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// (Updatable) The destination Object Store Region specified by the customer.
	// +kubebuilder:validation:Optional
	Region *string `json:"region" tf:"region,omitempty"`
}

// ComputationScheduleSpec defines the desired state of ComputationSchedule
type ComputationScheduleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ComputationScheduleParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ComputationScheduleInitParameters `json:"initProvider,omitempty"`
}

// ComputationScheduleStatus defines the observed state of ComputationSchedule.
type ComputationScheduleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ComputationScheduleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ComputationSchedule is the Schema for the ComputationSchedules API. Provides the Schedule resource in Oracle Cloud Infrastructure Metering Computation service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type ComputationSchedule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.compartmentId) || (has(self.initProvider) && has(self.initProvider.compartmentId))",message="spec.forProvider.compartmentId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.resultLocation) || (has(self.initProvider) && has(self.initProvider.resultLocation))",message="spec.forProvider.resultLocation is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.scheduleRecurrences) || (has(self.initProvider) && has(self.initProvider.scheduleRecurrences))",message="spec.forProvider.scheduleRecurrences is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.timeScheduled) || (has(self.initProvider) && has(self.initProvider.timeScheduled))",message="spec.forProvider.timeScheduled is a required parameter"
	Spec   ComputationScheduleSpec   `json:"spec"`
	Status ComputationScheduleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ComputationScheduleList contains a list of ComputationSchedules
type ComputationScheduleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ComputationSchedule `json:"items"`
}

// Repository type metadata.
var (
	ComputationSchedule_Kind             = "ComputationSchedule"
	ComputationSchedule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ComputationSchedule_Kind}.String()
	ComputationSchedule_KindAPIVersion   = ComputationSchedule_Kind + "." + CRDGroupVersion.String()
	ComputationSchedule_GroupVersionKind = CRDGroupVersion.WithKind(ComputationSchedule_Kind)
)

func init() {
	SchemeBuilder.Register(&ComputationSchedule{}, &ComputationScheduleList{})
}
