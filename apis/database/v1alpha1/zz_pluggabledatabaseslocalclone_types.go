/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type PluggableDatabasesLocalCloneConnectionStringsInitParameters struct {
}

type PluggableDatabasesLocalCloneConnectionStringsObservation struct {

	// All connection strings to use to connect to the pluggable database.
	// +mapType=granular
	AllConnectionStrings map[string]*string `json:"allConnectionStrings,omitempty" tf:"all_connection_strings,omitempty"`

	// A host name-based PDB connection string.
	PdbDefault *string `json:"pdbDefault,omitempty" tf:"pdb_default,omitempty"`

	// An IP-based PDB connection string.
	PdbIPDefault *string `json:"pdbIpDefault,omitempty" tf:"pdb_ip_default,omitempty"`
}

type PluggableDatabasesLocalCloneConnectionStringsParameters struct {
}

type PluggableDatabasesLocalCloneInitParameters struct {

	// The name for the pluggable database (PDB). The name is unique in the context of a container database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. The pluggable database name should not be same as the container database name.
	ClonedPdbName *string `json:"clonedPdbName,omitempty" tf:"cloned_pdb_name,omitempty"`

	// A strong password for PDB Admin of the newly cloned PDB. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, #, or -.
	PdbAdminPasswordSecretRef *v1.SecretKeySelector `json:"pdbAdminPasswordSecretRef,omitempty" tf:"-"`

	// The database OCID.
	PluggableDatabaseID *string `json:"pluggableDatabaseId,omitempty" tf:"pluggable_database_id,omitempty"`

	// The locked mode of the pluggable database admin account. If false, the user needs to provide the PDB Admin Password to connect to it. If true, the pluggable database will be locked and user cannot login to it.
	ShouldPdbAdminAccountBeLocked *bool `json:"shouldPdbAdminAccountBeLocked,omitempty" tf:"should_pdb_admin_account_be_locked,omitempty"`

	// The existing TDE wallet password of the target CDB.
	TargetTdeWalletPasswordSecretRef *v1.SecretKeySelector `json:"targetTdeWalletPasswordSecretRef,omitempty" tf:"-"`
}

type PluggableDatabasesLocalCloneObservation struct {

	// The name for the pluggable database (PDB). The name is unique in the context of a container database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. The pluggable database name should not be same as the container database name.
	ClonedPdbName *string `json:"clonedPdbName,omitempty" tf:"cloned_pdb_name,omitempty"`

	// The OCID of the compartment.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Connection strings to connect to an Oracle Pluggable Database.
	ConnectionStrings []PluggableDatabasesLocalCloneConnectionStringsObservation `json:"connectionStrings,omitempty" tf:"connection_strings,omitempty"`

	// The OCID of the CDB.
	ContainerDatabaseID *string `json:"containerDatabaseId,omitempty" tf:"container_database_id,omitempty"`

	// Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags.
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see Resource Tags.  Example: {"Department": "Finance"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The OCID of the pluggable database.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The restricted mode of the pluggable database. If a pluggable database is opened in restricted mode, the user needs both create a session and have restricted session privileges to connect to it.
	IsRestricted *bool `json:"isRestricted,omitempty" tf:"is_restricted,omitempty"`

	// Detailed message for the lifecycle state.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// Deprecated. Use PluggableDatabaseNodeLevelDetails for OpenMode details. The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
	OpenMode *string `json:"openMode,omitempty" tf:"open_mode,omitempty"`

	// The name for the pluggable database (PDB). The name is unique in the context of a container database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. The pluggable database name should not be same as the container database name.
	PdbName *string `json:"pdbName,omitempty" tf:"pdb_name,omitempty"`

	// Pluggable Database Node Level Details. Example: [{"nodeName" : "node1", "openMode" : "READ_WRITE"}, {"nodeName" : "node2", "openMode" : "READ_ONLY"}]
	PdbNodeLevelDetails []PluggableDatabasesLocalClonePdbNodeLevelDetailsObservation `json:"pdbNodeLevelDetails,omitempty" tf:"pdb_node_level_details,omitempty"`

	// The database OCID.
	PluggableDatabaseID *string `json:"pluggableDatabaseId,omitempty" tf:"pluggable_database_id,omitempty"`

	// The configuration of the Pluggable Database Management service.
	PluggableDatabaseManagementConfig []PluggableDatabasesLocalClonePluggableDatabaseManagementConfigObservation `json:"pluggableDatabaseManagementConfig,omitempty" tf:"pluggable_database_management_config,omitempty"`

	// Pluggable Database Refreshable Clone Configuration.
	RefreshableCloneConfig []PluggableDatabasesLocalCloneRefreshableCloneConfigObservation `json:"refreshableCloneConfig,omitempty" tf:"refreshable_clone_config,omitempty"`

	// The locked mode of the pluggable database admin account. If false, the user needs to provide the PDB Admin Password to connect to it. If true, the pluggable database will be locked and user cannot login to it.
	ShouldPdbAdminAccountBeLocked *bool `json:"shouldPdbAdminAccountBeLocked,omitempty" tf:"should_pdb_admin_account_be_locked,omitempty"`

	// The current state of the pluggable database.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags.
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// The date and time the pluggable database was created.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`
}

type PluggableDatabasesLocalCloneParameters struct {

	// The name for the pluggable database (PDB). The name is unique in the context of a container database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. The pluggable database name should not be same as the container database name.
	// +kubebuilder:validation:Optional
	ClonedPdbName *string `json:"clonedPdbName,omitempty" tf:"cloned_pdb_name,omitempty"`

	// A strong password for PDB Admin of the newly cloned PDB. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, #, or -.
	// +kubebuilder:validation:Optional
	PdbAdminPasswordSecretRef *v1.SecretKeySelector `json:"pdbAdminPasswordSecretRef,omitempty" tf:"-"`

	// The database OCID.
	// +kubebuilder:validation:Optional
	PluggableDatabaseID *string `json:"pluggableDatabaseId,omitempty" tf:"pluggable_database_id,omitempty"`

	// The locked mode of the pluggable database admin account. If false, the user needs to provide the PDB Admin Password to connect to it. If true, the pluggable database will be locked and user cannot login to it.
	// +kubebuilder:validation:Optional
	ShouldPdbAdminAccountBeLocked *bool `json:"shouldPdbAdminAccountBeLocked,omitempty" tf:"should_pdb_admin_account_be_locked,omitempty"`

	// The existing TDE wallet password of the target CDB.
	// +kubebuilder:validation:Optional
	TargetTdeWalletPasswordSecretRef *v1.SecretKeySelector `json:"targetTdeWalletPasswordSecretRef,omitempty" tf:"-"`
}

type PluggableDatabasesLocalClonePdbNodeLevelDetailsInitParameters struct {
}

type PluggableDatabasesLocalClonePdbNodeLevelDetailsObservation struct {

	// The Node name of the Database Instance.
	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`

	// Deprecated. Use PluggableDatabaseNodeLevelDetails for OpenMode details. The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
	OpenMode *string `json:"openMode,omitempty" tf:"open_mode,omitempty"`
}

type PluggableDatabasesLocalClonePdbNodeLevelDetailsParameters struct {
}

type PluggableDatabasesLocalClonePluggableDatabaseManagementConfigInitParameters struct {
}

type PluggableDatabasesLocalClonePluggableDatabaseManagementConfigObservation struct {

	// The status of the Pluggable Database Management service.
	ManagementStatus *string `json:"managementStatus,omitempty" tf:"management_status,omitempty"`
}

type PluggableDatabasesLocalClonePluggableDatabaseManagementConfigParameters struct {
}

type PluggableDatabasesLocalCloneRefreshableCloneConfigInitParameters struct {
}

type PluggableDatabasesLocalCloneRefreshableCloneConfigObservation struct {

	// Indicates whether the Pluggable Database is a refreshable clone.
	IsRefreshableClone *bool `json:"isRefreshableClone,omitempty" tf:"is_refreshable_clone,omitempty"`
}

type PluggableDatabasesLocalCloneRefreshableCloneConfigParameters struct {
}

// PluggableDatabasesLocalCloneSpec defines the desired state of PluggableDatabasesLocalClone
type PluggableDatabasesLocalCloneSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PluggableDatabasesLocalCloneParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider PluggableDatabasesLocalCloneInitParameters `json:"initProvider,omitempty"`
}

// PluggableDatabasesLocalCloneStatus defines the observed state of PluggableDatabasesLocalClone.
type PluggableDatabasesLocalCloneStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PluggableDatabasesLocalCloneObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// PluggableDatabasesLocalClone is the Schema for the PluggableDatabasesLocalClones API. Provides the Pluggable Databases Local Clone resource in Oracle Cloud Infrastructure Database service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type PluggableDatabasesLocalClone struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.clonedPdbName) || (has(self.initProvider) && has(self.initProvider.clonedPdbName))",message="spec.forProvider.clonedPdbName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.pluggableDatabaseId) || (has(self.initProvider) && has(self.initProvider.pluggableDatabaseId))",message="spec.forProvider.pluggableDatabaseId is a required parameter"
	Spec   PluggableDatabasesLocalCloneSpec   `json:"spec"`
	Status PluggableDatabasesLocalCloneStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PluggableDatabasesLocalCloneList contains a list of PluggableDatabasesLocalClones
type PluggableDatabasesLocalCloneList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []PluggableDatabasesLocalClone `json:"items"`
}

// Repository type metadata.
var (
	PluggableDatabasesLocalClone_Kind             = "PluggableDatabasesLocalClone"
	PluggableDatabasesLocalClone_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: PluggableDatabasesLocalClone_Kind}.String()
	PluggableDatabasesLocalClone_KindAPIVersion   = PluggableDatabasesLocalClone_Kind + "." + CRDGroupVersion.String()
	PluggableDatabasesLocalClone_GroupVersionKind = CRDGroupVersion.WithKind(PluggableDatabasesLocalClone_Kind)
)

func init() {
	SchemeBuilder.Register(&PluggableDatabasesLocalClone{}, &PluggableDatabasesLocalCloneList{})
}
