/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AutonomousVmClusterInitParameters struct {

	// (Updatable) The data disk group size to be allocated for Autonomous Databases, in TBs.
	AutonomousDataStorageSizeInTbs *float64 `json:"autonomousDataStorageSizeInTbs,omitempty" tf:"autonomous_data_storage_size_in_tbs,omitempty"`

	// (Updatable) The number of CPU cores to enable per VM cluster node.
	CPUCoreCountPerNode *float64 `json:"cpuCoreCountPerNode,omitempty" tf:"cpu_core_count_per_node,omitempty"`

	// (Updatable) The OCID of the compartment.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// The compute model of the Autonomous VM Cluster. ECPU compute model is the recommended model and OCPU compute model is legacy.
	ComputeModel *string `json:"computeModel,omitempty" tf:"compute_model,omitempty"`

	// The list of OCIDs of the Db servers.
	DBServers []*string `json:"dbServers,omitempty" tf:"db_servers,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags.
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The OCID of the Exadata infrastructure.
	ExadataInfrastructureID *string `json:"exadataInfrastructureId,omitempty" tf:"exadata_infrastructure_id,omitempty"`

	// (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see Resource Tags.  Example: {"Department": "Finance"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// If true, database backup on local Exadata storage is configured for the Autonomous VM cluster. If false, database backup on local Exadata storage is not available in the Autonomous VM cluster.
	IsLocalBackupEnabled *bool `json:"isLocalBackupEnabled,omitempty" tf:"is_local_backup_enabled,omitempty"`

	// Enable mutual TLS(mTLS) authentication for database while provisioning a VMCluster. Default is TLS.
	IsMtlsEnabled *bool `json:"isMtlsEnabled,omitempty" tf:"is_mtls_enabled,omitempty"`

	// (Updatable) The Oracle license model that applies to the Autonomous VM cluster. The default is BRING_YOUR_OWN_LICENSE.
	LicenseModel *string `json:"licenseModel,omitempty" tf:"license_model,omitempty"`

	// (Updatable) The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
	MaintenanceWindowDetails []AutonomousVmClusterMaintenanceWindowDetailsInitParameters `json:"maintenanceWindowDetails,omitempty" tf:"maintenance_window_details,omitempty"`

	// The amount of memory (in GBs) to be enabled per OCPU or ECPU.
	MemoryPerOracleComputeUnitInGbs *float64 `json:"memoryPerOracleComputeUnitInGbs,omitempty" tf:"memory_per_oracle_compute_unit_in_gbs,omitempty"`

	// The SCAN Listener Non TLS port number. Default value is 1521.
	ScanListenerPortNonTLS *float64 `json:"scanListenerPortNonTls,omitempty" tf:"scan_listener_port_non_tls,omitempty"`

	// The SCAN Listener TLS port number. Default value is 2484.
	ScanListenerPortTLS *float64 `json:"scanListenerPortTls,omitempty" tf:"scan_listener_port_tls,omitempty"`

	// The time zone to use for the Autonomous VM cluster. For details, see DB System Time Zones.
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`

	// (Updatable) The total number of Autonomous Container Databases that can be created.
	TotalContainerDatabases *float64 `json:"totalContainerDatabases,omitempty" tf:"total_container_databases,omitempty"`

	// The OCID of the VM cluster network.
	VMClusterNetworkID *string `json:"vmClusterNetworkId,omitempty" tf:"vm_cluster_network_id,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowDaysOfWeekInitParameters struct {
}

type AutonomousVmClusterMaintenanceWindowDaysOfWeekObservation struct {

	// (Updatable) Name of the day of the week.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowDaysOfWeekParameters struct {
}

type AutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekInitParameters struct {

	// (Updatable) Name of the day of the week.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekObservation struct {

	// (Updatable) Name of the day of the week.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekParameters struct {

	// (Updatable) Name of the day of the week.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowDetailsInitParameters struct {
	CustomActionTimeoutInMins *float64 `json:"customActionTimeoutInMins,omitempty" tf:"custom_action_timeout_in_mins,omitempty"`

	// (Updatable) Days during the week when maintenance should be performed.
	DaysOfWeek []AutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekInitParameters `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	// (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
	HoursOfDay []*float64 `json:"hoursOfDay,omitempty" tf:"hours_of_day,omitempty"`

	IsCustomActionTimeoutEnabled *bool `json:"isCustomActionTimeoutEnabled,omitempty" tf:"is_custom_action_timeout_enabled,omitempty"`

	IsMonthlyPatchingEnabled *bool `json:"isMonthlyPatchingEnabled,omitempty" tf:"is_monthly_patching_enabled,omitempty"`

	// (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
	LeadTimeInWeeks *float64 `json:"leadTimeInWeeks,omitempty" tf:"lead_time_in_weeks,omitempty"`

	// (Updatable) Months during the year when maintenance should be performed.
	Months []AutonomousVmClusterMaintenanceWindowDetailsMonthsInitParameters `json:"months,omitempty" tf:"months,omitempty"`

	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	PatchingMode *string `json:"patchingMode,omitempty" tf:"patching_mode,omitempty"`

	// (Updatable) The maintenance window scheduling preference.
	Preference *string `json:"preference,omitempty" tf:"preference,omitempty"`

	SkipRu []*bool `json:"skipRu,omitempty" tf:"skip_ru,omitempty"`

	// (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
	WeeksOfMonth []*float64 `json:"weeksOfMonth,omitempty" tf:"weeks_of_month,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowDetailsMonthsInitParameters struct {

	// (Updatable) Name of the day of the week.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowDetailsMonthsObservation struct {

	// (Updatable) Name of the day of the week.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowDetailsMonthsParameters struct {

	// (Updatable) Name of the day of the week.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowDetailsObservation struct {
	CustomActionTimeoutInMins *float64 `json:"customActionTimeoutInMins,omitempty" tf:"custom_action_timeout_in_mins,omitempty"`

	// (Updatable) Days during the week when maintenance should be performed.
	DaysOfWeek []AutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekObservation `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	// (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
	HoursOfDay []*float64 `json:"hoursOfDay,omitempty" tf:"hours_of_day,omitempty"`

	IsCustomActionTimeoutEnabled *bool `json:"isCustomActionTimeoutEnabled,omitempty" tf:"is_custom_action_timeout_enabled,omitempty"`

	IsMonthlyPatchingEnabled *bool `json:"isMonthlyPatchingEnabled,omitempty" tf:"is_monthly_patching_enabled,omitempty"`

	// (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
	LeadTimeInWeeks *float64 `json:"leadTimeInWeeks,omitempty" tf:"lead_time_in_weeks,omitempty"`

	// (Updatable) Months during the year when maintenance should be performed.
	Months []AutonomousVmClusterMaintenanceWindowDetailsMonthsObservation `json:"months,omitempty" tf:"months,omitempty"`

	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	PatchingMode *string `json:"patchingMode,omitempty" tf:"patching_mode,omitempty"`

	// (Updatable) The maintenance window scheduling preference.
	Preference *string `json:"preference,omitempty" tf:"preference,omitempty"`

	SkipRu []*bool `json:"skipRu,omitempty" tf:"skip_ru,omitempty"`

	// (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
	WeeksOfMonth []*float64 `json:"weeksOfMonth,omitempty" tf:"weeks_of_month,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowDetailsParameters struct {

	// +kubebuilder:validation:Optional
	CustomActionTimeoutInMins *float64 `json:"customActionTimeoutInMins,omitempty" tf:"custom_action_timeout_in_mins,omitempty"`

	// (Updatable) Days during the week when maintenance should be performed.
	// +kubebuilder:validation:Optional
	DaysOfWeek []AutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekParameters `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	// (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
	// +kubebuilder:validation:Optional
	HoursOfDay []*float64 `json:"hoursOfDay,omitempty" tf:"hours_of_day,omitempty"`

	// +kubebuilder:validation:Optional
	IsCustomActionTimeoutEnabled *bool `json:"isCustomActionTimeoutEnabled,omitempty" tf:"is_custom_action_timeout_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IsMonthlyPatchingEnabled *bool `json:"isMonthlyPatchingEnabled,omitempty" tf:"is_monthly_patching_enabled,omitempty"`

	// (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
	// +kubebuilder:validation:Optional
	LeadTimeInWeeks *float64 `json:"leadTimeInWeeks,omitempty" tf:"lead_time_in_weeks,omitempty"`

	// (Updatable) Months during the year when maintenance should be performed.
	// +kubebuilder:validation:Optional
	Months []AutonomousVmClusterMaintenanceWindowDetailsMonthsParameters `json:"months,omitempty" tf:"months,omitempty"`

	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	// +kubebuilder:validation:Optional
	PatchingMode *string `json:"patchingMode,omitempty" tf:"patching_mode,omitempty"`

	// (Updatable) The maintenance window scheduling preference.
	// +kubebuilder:validation:Optional
	Preference *string `json:"preference,omitempty" tf:"preference,omitempty"`

	// +kubebuilder:validation:Optional
	SkipRu []*bool `json:"skipRu,omitempty" tf:"skip_ru,omitempty"`

	// (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
	// +kubebuilder:validation:Optional
	WeeksOfMonth []*float64 `json:"weeksOfMonth,omitempty" tf:"weeks_of_month,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowInitParameters struct {
}

type AutonomousVmClusterMaintenanceWindowMonthsInitParameters struct {
}

type AutonomousVmClusterMaintenanceWindowMonthsObservation struct {

	// (Updatable) Name of the day of the week.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowMonthsParameters struct {
}

type AutonomousVmClusterMaintenanceWindowObservation struct {
	CustomActionTimeoutInMins *float64 `json:"customActionTimeoutInMins,omitempty" tf:"custom_action_timeout_in_mins,omitempty"`

	// (Updatable) Days during the week when maintenance should be performed.
	DaysOfWeek []AutonomousVmClusterMaintenanceWindowDaysOfWeekObservation `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	// (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
	HoursOfDay []*float64 `json:"hoursOfDay,omitempty" tf:"hours_of_day,omitempty"`

	IsCustomActionTimeoutEnabled *bool `json:"isCustomActionTimeoutEnabled,omitempty" tf:"is_custom_action_timeout_enabled,omitempty"`

	IsMonthlyPatchingEnabled *bool `json:"isMonthlyPatchingEnabled,omitempty" tf:"is_monthly_patching_enabled,omitempty"`

	// (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
	LeadTimeInWeeks *float64 `json:"leadTimeInWeeks,omitempty" tf:"lead_time_in_weeks,omitempty"`

	// (Updatable) Months during the year when maintenance should be performed.
	Months []AutonomousVmClusterMaintenanceWindowMonthsObservation `json:"months,omitempty" tf:"months,omitempty"`

	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	PatchingMode *string `json:"patchingMode,omitempty" tf:"patching_mode,omitempty"`

	// (Updatable) The maintenance window scheduling preference.
	Preference *string `json:"preference,omitempty" tf:"preference,omitempty"`

	SkipRu []*bool `json:"skipRu,omitempty" tf:"skip_ru,omitempty"`

	// (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
	WeeksOfMonth []*float64 `json:"weeksOfMonth,omitempty" tf:"weeks_of_month,omitempty"`
}

type AutonomousVmClusterMaintenanceWindowParameters struct {
}

type AutonomousVmClusterObservation struct {
	AutonomousDataStoragePercentage *float64 `json:"autonomousDataStoragePercentage,omitempty" tf:"autonomous_data_storage_percentage,omitempty"`

	// (Updatable) The data disk group size to be allocated for Autonomous Databases, in TBs.
	AutonomousDataStorageSizeInTbs *float64 `json:"autonomousDataStorageSizeInTbs,omitempty" tf:"autonomous_data_storage_size_in_tbs,omitempty"`

	// The data disk group size available for Autonomous Databases, in TBs.
	AvailableAutonomousDataStorageSizeInTbs *float64 `json:"availableAutonomousDataStorageSizeInTbs,omitempty" tf:"available_autonomous_data_storage_size_in_tbs,omitempty"`

	// The number of Autonomous Container Databases that can be created with the currently available local storage.
	AvailableContainerDatabases *float64 `json:"availableContainerDatabases,omitempty" tf:"available_container_databases,omitempty"`

	// The numnber of CPU cores available.
	AvailableCpus *float64 `json:"availableCpus,omitempty" tf:"available_cpus,omitempty"`

	// Deprecated. Use availableAutonomousDataStorageSizeInTBs for Autonomous Databases' data storage availability in TBs.
	AvailableDataStorageSizeInTbs *float64 `json:"availableDataStorageSizeInTbs,omitempty" tf:"available_data_storage_size_in_tbs,omitempty"`

	// (Updatable) The number of CPU cores to enable per VM cluster node.
	CPUCoreCountPerNode *float64 `json:"cpuCoreCountPerNode,omitempty" tf:"cpu_core_count_per_node,omitempty"`

	CPUPercentage *float64 `json:"cpuPercentage,omitempty" tf:"cpu_percentage,omitempty"`

	// (Updatable) The OCID of the compartment.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// The compute model of the Autonomous VM Cluster. ECPU compute model is the recommended model and OCPU compute model is legacy.
	ComputeModel *string `json:"computeModel,omitempty" tf:"compute_model,omitempty"`

	// The number of enabled CPU cores.
	CpusEnabled *float64 `json:"cpusEnabled,omitempty" tf:"cpus_enabled,omitempty"`

	CpusLowestScaledValue *float64 `json:"cpusLowestScaledValue,omitempty" tf:"cpus_lowest_scaled_value,omitempty"`

	// The local node storage allocated in GBs.
	DBNodeStorageSizeInGbs *float64 `json:"dbNodeStorageSizeInGbs,omitempty" tf:"db_node_storage_size_in_gbs,omitempty"`

	// The list of OCIDs of the Db servers.
	DBServers []*string `json:"dbServers,omitempty" tf:"db_servers,omitempty"`

	DataStorageSizeInGb *float64 `json:"dataStorageSizeInGb,omitempty" tf:"data_storage_size_in_gb,omitempty"`

	// The total data storage allocated in TBs
	DataStorageSizeInTbs *float64 `json:"dataStorageSizeInTbs,omitempty" tf:"data_storage_size_in_tbs,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags.
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The OCID of the Exadata infrastructure.
	ExadataInfrastructureID *string `json:"exadataInfrastructureId,omitempty" tf:"exadata_infrastructure_id,omitempty"`

	// The lowest value to which exadataStorage(in TBs) can be scaled down.
	ExadataStorageInTbsLowestScaledValue *float64 `json:"exadataStorageInTbsLowestScaledValue,omitempty" tf:"exadata_storage_in_tbs_lowest_scaled_value,omitempty"`

	// (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see Resource Tags.  Example: {"Department": "Finance"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The OCID of the Autonomous VM cluster.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// If true, database backup on local Exadata storage is configured for the Autonomous VM cluster. If false, database backup on local Exadata storage is not available in the Autonomous VM cluster.
	IsLocalBackupEnabled *bool `json:"isLocalBackupEnabled,omitempty" tf:"is_local_backup_enabled,omitempty"`

	// Enable mutual TLS(mTLS) authentication for database while provisioning a VMCluster. Default is TLS.
	IsMtlsEnabled *bool `json:"isMtlsEnabled,omitempty" tf:"is_mtls_enabled,omitempty"`

	// The OCID of the last maintenance run.
	LastMaintenanceRunID *string `json:"lastMaintenanceRunId,omitempty" tf:"last_maintenance_run_id,omitempty"`

	// (Updatable) The Oracle license model that applies to the Autonomous VM cluster. The default is BRING_YOUR_OWN_LICENSE.
	LicenseModel *string `json:"licenseModel,omitempty" tf:"license_model,omitempty"`

	// Additional information about the current lifecycle state.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
	MaintenanceWindow []AutonomousVmClusterMaintenanceWindowObservation `json:"maintenanceWindow,omitempty" tf:"maintenance_window,omitempty"`

	// (Updatable) The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
	MaintenanceWindowDetails []AutonomousVmClusterMaintenanceWindowDetailsObservation `json:"maintenanceWindowDetails,omitempty" tf:"maintenance_window_details,omitempty"`

	// The lowest value to which maximum number of ACDs can be scaled down.
	MaxAcdsLowestScaledValue *float64 `json:"maxAcdsLowestScaledValue,omitempty" tf:"max_acds_lowest_scaled_value,omitempty"`

	// The amount of memory (in GBs) to be enabled per OCPU or ECPU.
	MemoryPerOracleComputeUnitInGbs *float64 `json:"memoryPerOracleComputeUnitInGbs,omitempty" tf:"memory_per_oracle_compute_unit_in_gbs,omitempty"`

	// The memory allocated in GBs.
	MemorySizeInGbs *float64 `json:"memorySizeInGbs,omitempty" tf:"memory_size_in_gbs,omitempty"`

	// The OCID of the next maintenance run.
	NextMaintenanceRunID *string `json:"nextMaintenanceRunId,omitempty" tf:"next_maintenance_run_id,omitempty"`

	// The number of nodes in the Autonomous VM Cluster.
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// Deprecated. Use field totalContainerDatabases.
	NonProvisionableAutonomousContainerDatabases *float64 `json:"nonProvisionableAutonomousContainerDatabases,omitempty" tf:"non_provisionable_autonomous_container_databases,omitempty"`

	// The number of enabled OCPU cores.
	OcpusEnabled *float64 `json:"ocpusEnabled,omitempty" tf:"ocpus_enabled,omitempty"`

	// Deprecated. Use field totalContainerDatabases.
	ProvisionableAutonomousContainerDatabases *float64 `json:"provisionableAutonomousContainerDatabases,omitempty" tf:"provisionable_autonomous_container_databases,omitempty"`

	// The number of provisioned Autonomous Container Databases in an Autonomous VM Cluster.
	ProvisionedAutonomousContainerDatabases *float64 `json:"provisionedAutonomousContainerDatabases,omitempty" tf:"provisioned_autonomous_container_databases,omitempty"`

	// The number of CPUs provisioned in an Autonomous VM Cluster.
	ProvisionedCpus *float64 `json:"provisionedCpus,omitempty" tf:"provisioned_cpus,omitempty"`

	// For Autonomous Databases on Dedicated Exadata Infrastructure:
	ReclaimableCpus *float64 `json:"reclaimableCpus,omitempty" tf:"reclaimable_cpus,omitempty"`

	// The number of CPUs reserved in an Autonomous VM Cluster.
	ReservedCpus *float64 `json:"reservedCpus,omitempty" tf:"reserved_cpus,omitempty"`

	// The SCAN Listener Non TLS port number. Default value is 1521.
	ScanListenerPortNonTLS *float64 `json:"scanListenerPortNonTls,omitempty" tf:"scan_listener_port_non_tls,omitempty"`

	// The SCAN Listener TLS port number. Default value is 2484.
	ScanListenerPortTLS *float64 `json:"scanListenerPortTls,omitempty" tf:"scan_listener_port_tls,omitempty"`

	// The current state of the Autonomous VM cluster.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags.
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// The date and time that the Autonomous VM cluster was created.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The date and time of Database SSL certificate expiration.
	TimeDatabaseSSLCertificateExpires *string `json:"timeDatabaseSslCertificateExpires,omitempty" tf:"time_database_ssl_certificate_expires,omitempty"`

	// The date and time of ORDS certificate expiration.
	TimeOrdsCertificateExpires *string `json:"timeOrdsCertificateExpires,omitempty" tf:"time_ords_certificate_expires,omitempty"`

	// The time zone to use for the Autonomous VM cluster. For details, see DB System Time Zones.
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`

	TotalAutonomousDataStorageInTbs *float64 `json:"totalAutonomousDataStorageInTbs,omitempty" tf:"total_autonomous_data_storage_in_tbs,omitempty"`

	// (Updatable) The total number of Autonomous Container Databases that can be created.
	TotalContainerDatabases *float64 `json:"totalContainerDatabases,omitempty" tf:"total_container_databases,omitempty"`

	// The OCID of the VM cluster network.
	VMClusterNetworkID *string `json:"vmClusterNetworkId,omitempty" tf:"vm_cluster_network_id,omitempty"`
}

type AutonomousVmClusterParameters struct {

	// (Updatable) The data disk group size to be allocated for Autonomous Databases, in TBs.
	// +kubebuilder:validation:Optional
	AutonomousDataStorageSizeInTbs *float64 `json:"autonomousDataStorageSizeInTbs,omitempty" tf:"autonomous_data_storage_size_in_tbs,omitempty"`

	// (Updatable) The number of CPU cores to enable per VM cluster node.
	// +kubebuilder:validation:Optional
	CPUCoreCountPerNode *float64 `json:"cpuCoreCountPerNode,omitempty" tf:"cpu_core_count_per_node,omitempty"`

	// (Updatable) The OCID of the compartment.
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// The compute model of the Autonomous VM Cluster. ECPU compute model is the recommended model and OCPU compute model is legacy.
	// +kubebuilder:validation:Optional
	ComputeModel *string `json:"computeModel,omitempty" tf:"compute_model,omitempty"`

	// The list of OCIDs of the Db servers.
	// +kubebuilder:validation:Optional
	DBServers []*string `json:"dbServers,omitempty" tf:"db_servers,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The OCID of the Exadata infrastructure.
	// +kubebuilder:validation:Optional
	ExadataInfrastructureID *string `json:"exadataInfrastructureId,omitempty" tf:"exadata_infrastructure_id,omitempty"`

	// (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see Resource Tags.  Example: {"Department": "Finance"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// If true, database backup on local Exadata storage is configured for the Autonomous VM cluster. If false, database backup on local Exadata storage is not available in the Autonomous VM cluster.
	// +kubebuilder:validation:Optional
	IsLocalBackupEnabled *bool `json:"isLocalBackupEnabled,omitempty" tf:"is_local_backup_enabled,omitempty"`

	// Enable mutual TLS(mTLS) authentication for database while provisioning a VMCluster. Default is TLS.
	// +kubebuilder:validation:Optional
	IsMtlsEnabled *bool `json:"isMtlsEnabled,omitempty" tf:"is_mtls_enabled,omitempty"`

	// (Updatable) The Oracle license model that applies to the Autonomous VM cluster. The default is BRING_YOUR_OWN_LICENSE.
	// +kubebuilder:validation:Optional
	LicenseModel *string `json:"licenseModel,omitempty" tf:"license_model,omitempty"`

	// (Updatable) The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
	// +kubebuilder:validation:Optional
	MaintenanceWindowDetails []AutonomousVmClusterMaintenanceWindowDetailsParameters `json:"maintenanceWindowDetails,omitempty" tf:"maintenance_window_details,omitempty"`

	// The amount of memory (in GBs) to be enabled per OCPU or ECPU.
	// +kubebuilder:validation:Optional
	MemoryPerOracleComputeUnitInGbs *float64 `json:"memoryPerOracleComputeUnitInGbs,omitempty" tf:"memory_per_oracle_compute_unit_in_gbs,omitempty"`

	// The SCAN Listener Non TLS port number. Default value is 1521.
	// +kubebuilder:validation:Optional
	ScanListenerPortNonTLS *float64 `json:"scanListenerPortNonTls,omitempty" tf:"scan_listener_port_non_tls,omitempty"`

	// The SCAN Listener TLS port number. Default value is 2484.
	// +kubebuilder:validation:Optional
	ScanListenerPortTLS *float64 `json:"scanListenerPortTls,omitempty" tf:"scan_listener_port_tls,omitempty"`

	// The time zone to use for the Autonomous VM cluster. For details, see DB System Time Zones.
	// +kubebuilder:validation:Optional
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`

	// (Updatable) The total number of Autonomous Container Databases that can be created.
	// +kubebuilder:validation:Optional
	TotalContainerDatabases *float64 `json:"totalContainerDatabases,omitempty" tf:"total_container_databases,omitempty"`

	// The OCID of the VM cluster network.
	// +kubebuilder:validation:Optional
	VMClusterNetworkID *string `json:"vmClusterNetworkId,omitempty" tf:"vm_cluster_network_id,omitempty"`
}

// AutonomousVmClusterSpec defines the desired state of AutonomousVmCluster
type AutonomousVmClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AutonomousVmClusterParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider AutonomousVmClusterInitParameters `json:"initProvider,omitempty"`
}

// AutonomousVmClusterStatus defines the observed state of AutonomousVmCluster.
type AutonomousVmClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AutonomousVmClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// AutonomousVmCluster is the Schema for the AutonomousVmClusters API. Provides the Autonomous Vm Cluster resource in Oracle Cloud Infrastructure Database service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type AutonomousVmCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.compartmentId) || (has(self.initProvider) && has(self.initProvider.compartmentId))",message="spec.forProvider.compartmentId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.displayName) || (has(self.initProvider) && has(self.initProvider.displayName))",message="spec.forProvider.displayName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.exadataInfrastructureId) || (has(self.initProvider) && has(self.initProvider.exadataInfrastructureId))",message="spec.forProvider.exadataInfrastructureId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.vmClusterNetworkId) || (has(self.initProvider) && has(self.initProvider.vmClusterNetworkId))",message="spec.forProvider.vmClusterNetworkId is a required parameter"
	Spec   AutonomousVmClusterSpec   `json:"spec"`
	Status AutonomousVmClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AutonomousVmClusterList contains a list of AutonomousVmClusters
type AutonomousVmClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AutonomousVmCluster `json:"items"`
}

// Repository type metadata.
var (
	AutonomousVmCluster_Kind             = "AutonomousVmCluster"
	AutonomousVmCluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: AutonomousVmCluster_Kind}.String()
	AutonomousVmCluster_KindAPIVersion   = AutonomousVmCluster_Kind + "." + CRDGroupVersion.String()
	AutonomousVmCluster_GroupVersionKind = CRDGroupVersion.WithKind(AutonomousVmCluster_Kind)
)

func init() {
	SchemeBuilder.Register(&AutonomousVmCluster{}, &AutonomousVmClusterList{})
}
