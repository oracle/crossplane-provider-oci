/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type EstimatedPatchingTimeInitParameters struct {
}

type EstimatedPatchingTimeObservation struct {

	// The estimated time required in minutes for database server patching.
	EstimatedDBServerPatchingTime *float64 `json:"estimatedDbServerPatchingTime,omitempty" tf:"estimated_db_server_patching_time,omitempty"`

	// The estimated time required in minutes for network switch patching.
	EstimatedNetworkSwitchesPatchingTime *float64 `json:"estimatedNetworkSwitchesPatchingTime,omitempty" tf:"estimated_network_switches_patching_time,omitempty"`

	// The estimated time required in minutes for storage server patching.
	EstimatedStorageServerPatchingTime *float64 `json:"estimatedStorageServerPatchingTime,omitempty" tf:"estimated_storage_server_patching_time,omitempty"`

	// The estimated total time required in minutes for all patching operations.
	TotalEstimatedPatchingTime *float64 `json:"totalEstimatedPatchingTime,omitempty" tf:"total_estimated_patching_time,omitempty"`
}

type EstimatedPatchingTimeParameters struct {
}

type MaintenanceRunInitParameters struct {

	// The OCID of the compartment containing the Maintenance Run.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/identity/v1alpha1.Compartment
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Reference to a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// Selector for a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// The Autonomous Database Software Image OCID
	DatabaseSoftwareImageID *string `json:"databaseSoftwareImageId,omitempty" tf:"database_software_image_id,omitempty"`

	// Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
	IsDstFileUpdateEnabled *bool `json:"isDstFileUpdateEnabled,omitempty" tf:"is_dst_file_update_enabled,omitempty"`

	// Patch type, either "QUARTERLY", "TIMEZONE" or "CUSTOM_DATABASE_SOFTWARE_IMAGE".
	PatchType *string `json:"patchType,omitempty" tf:"patch_type,omitempty"`

	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	PatchingMode *string `json:"patchingMode,omitempty" tf:"patching_mode,omitempty"`

	// The ID of the target resource for which the maintenance run should be created.
	TargetResourceID *string `json:"targetResourceId,omitempty" tf:"target_resource_id,omitempty"`

	// (Updatable) The date and time that update should be scheduled.
	TimeScheduled *string `json:"timeScheduled,omitempty" tf:"time_scheduled,omitempty"`
}

type MaintenanceRunObservation struct {

	// The OCID of the compartment containing the Maintenance Run.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
	CurrentCustomActionTimeoutInMins *float64 `json:"currentCustomActionTimeoutInMins,omitempty" tf:"current_custom_action_timeout_in_mins,omitempty"`

	// The name of the current infrastruture component that is getting patched.
	CurrentPatchingComponent *string `json:"currentPatchingComponent,omitempty" tf:"current_patching_component,omitempty"`

	// Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
	CustomActionTimeoutInMins *float64 `json:"customActionTimeoutInMins,omitempty" tf:"custom_action_timeout_in_mins,omitempty"`

	// The Autonomous Database Software Image OCID
	DatabaseSoftwareImageID *string `json:"databaseSoftwareImageId,omitempty" tf:"database_software_image_id,omitempty"`

	// Description of the maintenance run.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The user-friendly name for the maintenance run.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The estimated start time of the next infrastruture component patching operation.
	EstimatedComponentPatchingStartTime *string `json:"estimatedComponentPatchingStartTime,omitempty" tf:"estimated_component_patching_start_time,omitempty"`

	// The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
	EstimatedPatchingTime []EstimatedPatchingTimeObservation `json:"estimatedPatchingTime,omitempty" tf:"estimated_patching_time,omitempty"`

	// The OCID of the maintenance run.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
	IsCustomActionTimeoutEnabled *bool `json:"isCustomActionTimeoutEnabled,omitempty" tf:"is_custom_action_timeout_enabled,omitempty"`

	// Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
	IsDstFileUpdateEnabled *bool `json:"isDstFileUpdateEnabled,omitempty" tf:"is_dst_file_update_enabled,omitempty"`

	// If FALSE, the maintenance run doesn't support granular maintenance.
	IsMaintenanceRunGranular *bool `json:"isMaintenanceRunGranular,omitempty" tf:"is_maintenance_run_granular,omitempty"`

	// Additional information about the current lifecycle state.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// Maintenance sub-type.
	MaintenanceSubtype *string `json:"maintenanceSubtype,omitempty" tf:"maintenance_subtype,omitempty"`

	// Maintenance type.
	MaintenanceType *string `json:"maintenanceType,omitempty" tf:"maintenance_type,omitempty"`

	// Contain the patch failure count.
	PatchFailureCount *float64 `json:"patchFailureCount,omitempty" tf:"patch_failure_count,omitempty"`

	// The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier ru_patch_19.9.0.0_201030 is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
	PatchID *string `json:"patchId,omitempty" tf:"patch_id,omitempty"`

	// Patch type, either "QUARTERLY", "TIMEZONE" or "CUSTOM_DATABASE_SOFTWARE_IMAGE".
	PatchType *string `json:"patchType,omitempty" tf:"patch_type,omitempty"`

	// The time when the patching operation ended.
	PatchingEndTime *string `json:"patchingEndTime,omitempty" tf:"patching_end_time,omitempty"`

	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	PatchingMode *string `json:"patchingMode,omitempty" tf:"patching_mode,omitempty"`

	// The time when the patching operation started.
	PatchingStartTime *string `json:"patchingStartTime,omitempty" tf:"patching_start_time,omitempty"`

	// The status of the patching operation.
	PatchingStatus *string `json:"patchingStatus,omitempty" tf:"patching_status,omitempty"`

	// The OCID of the maintenance run for the Autonomous Data Guard association's peer container database.
	PeerMaintenanceRunID *string `json:"peerMaintenanceRunId,omitempty" tf:"peer_maintenance_run_id,omitempty"`

	// The list of OCIDs for the maintenance runs associated with their Autonomous Data Guard peer container databases.
	PeerMaintenanceRunIds []*string `json:"peerMaintenanceRunIds,omitempty" tf:"peer_maintenance_run_ids,omitempty"`

	// The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags.
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// The target software version for the database server patching operation.
	TargetDBServerVersion *string `json:"targetDbServerVersion,omitempty" tf:"target_db_server_version,omitempty"`

	// The ID of the target resource for which the maintenance run should be created.
	TargetResourceID *string `json:"targetResourceId,omitempty" tf:"target_resource_id,omitempty"`

	// The type of the target resource on which the maintenance run occurs.
	TargetResourceType *string `json:"targetResourceType,omitempty" tf:"target_resource_type,omitempty"`

	// The target Cell version that is to be patched to.
	TargetStorageServerVersion *string `json:"targetStorageServerVersion,omitempty" tf:"target_storage_server_version,omitempty"`

	// The date and time the maintenance run was completed.
	TimeEnded *string `json:"timeEnded,omitempty" tf:"time_ended,omitempty"`

	// (Updatable) The date and time that update should be scheduled.
	TimeScheduled *string `json:"timeScheduled,omitempty" tf:"time_scheduled,omitempty"`

	// The date and time the maintenance run starts.
	TimeStarted *string `json:"timeStarted,omitempty" tf:"time_started,omitempty"`

	// The total time taken by corresponding resource activity in minutes.
	TotalTimeTakenInMins *float64 `json:"totalTimeTakenInMins,omitempty" tf:"total_time_taken_in_mins,omitempty"`
}

type MaintenanceRunParameters struct {

	// The OCID of the compartment containing the Maintenance Run.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/identity/v1alpha1.Compartment
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Reference to a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// Selector for a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// The Autonomous Database Software Image OCID
	// +kubebuilder:validation:Optional
	DatabaseSoftwareImageID *string `json:"databaseSoftwareImageId,omitempty" tf:"database_software_image_id,omitempty"`

	// Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
	// +kubebuilder:validation:Optional
	IsDstFileUpdateEnabled *bool `json:"isDstFileUpdateEnabled,omitempty" tf:"is_dst_file_update_enabled,omitempty"`

	// Patch type, either "QUARTERLY", "TIMEZONE" or "CUSTOM_DATABASE_SOFTWARE_IMAGE".
	// +kubebuilder:validation:Optional
	PatchType *string `json:"patchType,omitempty" tf:"patch_type,omitempty"`

	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	// +kubebuilder:validation:Optional
	PatchingMode *string `json:"patchingMode,omitempty" tf:"patching_mode,omitempty"`

	// The ID of the target resource for which the maintenance run should be created.
	// +kubebuilder:validation:Optional
	TargetResourceID *string `json:"targetResourceId,omitempty" tf:"target_resource_id,omitempty"`

	// (Updatable) The date and time that update should be scheduled.
	// +kubebuilder:validation:Optional
	TimeScheduled *string `json:"timeScheduled,omitempty" tf:"time_scheduled,omitempty"`
}

// MaintenanceRunSpec defines the desired state of MaintenanceRun
type MaintenanceRunSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MaintenanceRunParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider MaintenanceRunInitParameters `json:"initProvider,omitempty"`
}

// MaintenanceRunStatus defines the observed state of MaintenanceRun.
type MaintenanceRunStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MaintenanceRunObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// MaintenanceRun is the Schema for the MaintenanceRuns API. Provides the Maintenance Run resource in Oracle Cloud Infrastructure Database service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type MaintenanceRun struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.patchType) || (has(self.initProvider) && has(self.initProvider.patchType))",message="spec.forProvider.patchType is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.targetResourceId) || (has(self.initProvider) && has(self.initProvider.targetResourceId))",message="spec.forProvider.targetResourceId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.timeScheduled) || (has(self.initProvider) && has(self.initProvider.timeScheduled))",message="spec.forProvider.timeScheduled is a required parameter"
	Spec   MaintenanceRunSpec   `json:"spec"`
	Status MaintenanceRunStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MaintenanceRunList contains a list of MaintenanceRuns
type MaintenanceRunList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MaintenanceRun `json:"items"`
}

// Repository type metadata.
var (
	MaintenanceRun_Kind             = "MaintenanceRun"
	MaintenanceRun_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: MaintenanceRun_Kind}.String()
	MaintenanceRun_KindAPIVersion   = MaintenanceRun_Kind + "." + CRDGroupVersion.String()
	MaintenanceRun_GroupVersionKind = CRDGroupVersion.WithKind(MaintenanceRun_Kind)
)

func init() {
	SchemeBuilder.Register(&MaintenanceRun{}, &MaintenanceRunList{})
}
