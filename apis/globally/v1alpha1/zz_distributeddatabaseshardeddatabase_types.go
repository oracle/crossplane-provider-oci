/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CatalogDetailsInitParameters struct {

	// Admin password for the catalog database.
	AdminPasswordSecretRef v1.SecretKeySelector `json:"adminPasswordSecretRef" tf:"-"`

	// The OCID of the cloud Autonomous Exadata VM Cluster.
	CloudAutonomousVMClusterID *string `json:"cloudAutonomousVmClusterId,omitempty" tf:"cloud_autonomous_vm_cluster_id,omitempty"`

	// The compute count for the catalog database. It has to be in multiple of 2.
	ComputeCount *float64 `json:"computeCount,omitempty" tf:"compute_count,omitempty"`

	// The data disk group size to be allocated in GBs for the catalog database.
	DataStorageSizeInGbs *float64 `json:"dataStorageSizeInGbs,omitempty" tf:"data_storage_size_in_gbs,omitempty"`

	// Details of encryption key to be used to encrypt data for shards and catalog for sharded database. For system-defined sharding type, all shards have to use same encryptionKeyDetails. For system-defined sharding, if encryptionKeyDetails are not specified for catalog, then Oracle managed key will be used for catalog. For user-defined sharding type, if encryptionKeyDetails are not provided for any shard or catalog, then Oracle managed key will be used for such shard or catalog. For system-defined or user-defined sharding type, if the shard or catalog has a peer in region other than primary shard or catalog region, then make sure to provide virtual vault for such shard or catalog, which is also replicated to peer region (the region where peer or standby shard or catalog exists).
	EncryptionKeyDetails []EncryptionKeyDetailsInitParameters `json:"encryptionKeyDetails,omitempty" tf:"encryption_key_details,omitempty"`

	// Determines the auto-scaling mode for the catalog database.
	IsAutoScalingEnabled *bool `json:"isAutoScalingEnabled,omitempty" tf:"is_auto_scaling_enabled,omitempty"`

	// The OCID of the peer cloud Autonomous Exadata VM Cluster.
	PeerCloudAutonomousVMClusterID *string `json:"peerCloudAutonomousVmClusterId,omitempty" tf:"peer_cloud_autonomous_vm_cluster_id,omitempty"`
}

type CatalogDetailsObservation struct {

	// The OCID of the cloud Autonomous Exadata VM Cluster.
	CloudAutonomousVMClusterID *string `json:"cloudAutonomousVmClusterId,omitempty" tf:"cloud_autonomous_vm_cluster_id,omitempty"`

	// The compute count for the catalog database. It has to be in multiple of 2.
	ComputeCount *float64 `json:"computeCount,omitempty" tf:"compute_count,omitempty"`

	// Identifier of the underlying container database.
	ContainerDatabaseID *string `json:"containerDatabaseId,omitempty" tf:"container_database_id,omitempty"`

	// Identifier of the underlying container database parent.
	ContainerDatabaseParentID *string `json:"containerDatabaseParentId,omitempty" tf:"container_database_parent_id,omitempty"`

	// The data disk group size to be allocated in GBs for the catalog database.
	DataStorageSizeInGbs *float64 `json:"dataStorageSizeInGbs,omitempty" tf:"data_storage_size_in_gbs,omitempty"`

	// Details of encryption key to be used to encrypt data for shards and catalog for sharded database. For system-defined sharding type, all shards have to use same encryptionKeyDetails. For system-defined sharding, if encryptionKeyDetails are not specified for catalog, then Oracle managed key will be used for catalog. For user-defined sharding type, if encryptionKeyDetails are not provided for any shard or catalog, then Oracle managed key will be used for such shard or catalog. For system-defined or user-defined sharding type, if the shard or catalog has a peer in region other than primary shard or catalog region, then make sure to provide virtual vault for such shard or catalog, which is also replicated to peer region (the region where peer or standby shard or catalog exists).
	EncryptionKeyDetails []EncryptionKeyDetailsObservation `json:"encryptionKeyDetails,omitempty" tf:"encryption_key_details,omitempty"`

	// Determines the auto-scaling mode for the catalog database.
	IsAutoScalingEnabled *bool `json:"isAutoScalingEnabled,omitempty" tf:"is_auto_scaling_enabled,omitempty"`

	// Additional metadata related to catalog's underlying supporting resource.
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// Catalog name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The OCID of the peer cloud Autonomous Exadata VM Cluster.
	PeerCloudAutonomousVMClusterID *string `json:"peerCloudAutonomousVmClusterId,omitempty" tf:"peer_cloud_autonomous_vm_cluster_id,omitempty"`

	// Name of the shard-group to which the catalog belongs.
	ShardGroup *string `json:"shardGroup,omitempty" tf:"shard_group,omitempty"`

	// Status of shard or catalog or gsm for the sharded database.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// Identifier of the underlying supporting resource.
	SupportingResourceID *string `json:"supportingResourceId,omitempty" tf:"supporting_resource_id,omitempty"`

	// The time the catalog was created. An RFC3339 formatted datetime string
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The time the ssl certificate associated with catalog expires. An RFC3339 formatted datetime string
	TimeSSLCertificateExpires *string `json:"timeSslCertificateExpires,omitempty" tf:"time_ssl_certificate_expires,omitempty"`

	// The time the catalog was last created. An RFC3339 formatted datetime string
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`
}

type CatalogDetailsParameters struct {

	// Admin password for the catalog database.
	// +kubebuilder:validation:Optional
	AdminPasswordSecretRef v1.SecretKeySelector `json:"adminPasswordSecretRef" tf:"-"`

	// The OCID of the cloud Autonomous Exadata VM Cluster.
	// +kubebuilder:validation:Optional
	CloudAutonomousVMClusterID *string `json:"cloudAutonomousVmClusterId" tf:"cloud_autonomous_vm_cluster_id,omitempty"`

	// The compute count for the catalog database. It has to be in multiple of 2.
	// +kubebuilder:validation:Optional
	ComputeCount *float64 `json:"computeCount" tf:"compute_count,omitempty"`

	// The data disk group size to be allocated in GBs for the catalog database.
	// +kubebuilder:validation:Optional
	DataStorageSizeInGbs *float64 `json:"dataStorageSizeInGbs" tf:"data_storage_size_in_gbs,omitempty"`

	// Details of encryption key to be used to encrypt data for shards and catalog for sharded database. For system-defined sharding type, all shards have to use same encryptionKeyDetails. For system-defined sharding, if encryptionKeyDetails are not specified for catalog, then Oracle managed key will be used for catalog. For user-defined sharding type, if encryptionKeyDetails are not provided for any shard or catalog, then Oracle managed key will be used for such shard or catalog. For system-defined or user-defined sharding type, if the shard or catalog has a peer in region other than primary shard or catalog region, then make sure to provide virtual vault for such shard or catalog, which is also replicated to peer region (the region where peer or standby shard or catalog exists).
	// +kubebuilder:validation:Optional
	EncryptionKeyDetails []EncryptionKeyDetailsParameters `json:"encryptionKeyDetails,omitempty" tf:"encryption_key_details,omitempty"`

	// Determines the auto-scaling mode for the catalog database.
	// +kubebuilder:validation:Optional
	IsAutoScalingEnabled *bool `json:"isAutoScalingEnabled" tf:"is_auto_scaling_enabled,omitempty"`

	// The OCID of the peer cloud Autonomous Exadata VM Cluster.
	// +kubebuilder:validation:Optional
	PeerCloudAutonomousVMClusterID *string `json:"peerCloudAutonomousVmClusterId,omitempty" tf:"peer_cloud_autonomous_vm_cluster_id,omitempty"`
}

type ConnectionStringsInitParameters struct {
}

type ConnectionStringsObservation struct {

	// Collection of connection strings.
	// +mapType=granular
	AllConnectionStrings map[string]*string `json:"allConnectionStrings,omitempty" tf:"all_connection_strings,omitempty"`
}

type ConnectionStringsParameters struct {
}

type DistributedDatabaseShardedDatabaseInitParameters struct {
	CASignedCertificate *string `json:"caSignedCertificate,omitempty" tf:"ca_signed_certificate,omitempty"`

	// Collection of ATP-Dedicated catalogs that needs to be created.
	CatalogDetails []CatalogDetailsInitParameters `json:"catalogDetails,omitempty" tf:"catalog_details,omitempty"`

	// The character set for the new shard database being created. Use database api ListAutonomousDatabaseCharacterSets to get the list of allowed character set for autonomous dedicated database. See documentation: https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/ListAutonomousDatabaseCharacterSets
	CharacterSet *string `json:"characterSet,omitempty" tf:"character_set,omitempty"`

	// The default number of unique chunks in a shardspace. The value of chunks must be greater than 2 times the size of the largest shardgroup in any shardspace.
	Chunks *float64 `json:"chunks,omitempty" tf:"chunks,omitempty"`

	// The certificate common name used in all cloudAutonomousVmClusters for the sharded database topology. Eg. Production. All the clusters used in one sharded database topology shall have same CABundle setup. Valid characterset for clusterCertificateCommonName include uppercase or lowercase letters, numbers, hyphens, underscores, and period.
	ClusterCertificateCommonName *string `json:"clusterCertificateCommonName,omitempty" tf:"cluster_certificate_common_name,omitempty"`

	// (Updatable) Identifier of the compartment where sharded database is to be created.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) An optional property when incremented triggers Configure Gsms. Could be set to any integer value.
	ConfigureGsmsTrigger *float64 `json:"configureGsmsTrigger,omitempty" tf:"configure_gsms_trigger,omitempty"`

	ConfigureGsmsTriggerIsLatestGsmImage *bool `json:"configureGsmsTriggerIsLatestGsmImage,omitempty" tf:"configure_gsms_trigger_is_latest_gsm_image,omitempty"`

	ConfigureGsmsTriggerOldGsmNames []*string `json:"configureGsmsTriggerOldGsmNames,omitempty" tf:"configure_gsms_trigger_old_gsm_names,omitempty"`

	// (Updatable) An optional property when incremented triggers Configure Sharding. Could be set to any integer value.
	ConfigureShardingTrigger *float64 `json:"configureShardingTrigger,omitempty" tf:"configure_sharding_trigger,omitempty"`

	// The database deployment type.
	DBDeploymentType *string `json:"dbDeploymentType,omitempty" tf:"db_deployment_type,omitempty"`

	// Oracle Database version of the Autonomous Container Database.
	DBVersion *string `json:"dbVersion,omitempty" tf:"db_version,omitempty"`

	// Possible workload types.
	DBWorkload *string `json:"dbWorkload,omitempty" tf:"db_workload,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Oracle sharded database display name.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) An optional property when incremented triggers Download Gsm Certificate Signing Request. Could be set to any integer value.
	DownloadGsmCertificateSigningRequestTrigger *float64 `json:"downloadGsmCertificateSigningRequestTrigger,omitempty" tf:"download_gsm_certificate_signing_request_trigger,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// (Updatable) An optional property when incremented triggers Generate Gsm Certificate Signing Request. Could be set to any integer value.
	GenerateGsmCertificateSigningRequestTrigger *float64 `json:"generateGsmCertificateSigningRequestTrigger,omitempty" tf:"generate_gsm_certificate_signing_request_trigger,omitempty"`

	GenerateWalletPasswordSecretRef *v1.SecretKeySelector `json:"generateWalletPasswordSecretRef,omitempty" tf:"-"`

	// (Updatable) An optional property when incremented triggers Generate Wallet. Could be set to any integer value.
	GenerateWalletTrigger *float64 `json:"generateWalletTrigger,omitempty" tf:"generate_wallet_trigger,omitempty"`

	// (Updatable) An optional property when incremented triggers Get Connection String. Could be set to any integer value.
	GetConnectionStringTrigger *float64 `json:"getConnectionStringTrigger,omitempty" tf:"get_connection_string_trigger,omitempty"`

	// The listener port number for sharded database.
	ListenerPort *float64 `json:"listenerPort,omitempty" tf:"listener_port,omitempty"`

	// The TLS listener port number for sharded database.
	ListenerPortTLS *float64 `json:"listenerPortTls,omitempty" tf:"listener_port_tls,omitempty"`

	// The national character set for the new shard database being created. Use database api ListAutonomousDatabaseCharacterSets to get the list of allowed national character set for autonomous dedicated database. See documentation: https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/ListAutonomousDatabaseCharacterSets
	NcharacterSet *string `json:"ncharacterSet,omitempty" tf:"ncharacter_set,omitempty"`

	// Ons port local for sharded database.
	OnsPortLocal *float64 `json:"onsPortLocal,omitempty" tf:"ons_port_local,omitempty"`

	// Ons remote port for sharded database.
	OnsPortRemote *float64 `json:"onsPortRemote,omitempty" tf:"ons_port_remote,omitempty"`

	// (Updatable)
	PatchOperations []PatchOperationsInitParameters `json:"patchOperations,omitempty" tf:"patch_operations,omitempty"`

	// Unique name prefix for the sharded databases. Only alpha-numeric values are allowed. First character has to be a letter followed by any combination of letter and number.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// The Replication factor for RAFT replication based sharded database. Currently supported values are 3, 5 and 7.
	ReplicationFactor *float64 `json:"replicationFactor,omitempty" tf:"replication_factor,omitempty"`

	// The Replication method for sharded database.
	ReplicationMethod *string `json:"replicationMethod,omitempty" tf:"replication_method,omitempty"`

	// For RAFT replication based sharded database, the value should be atleast twice the number of shards.
	ReplicationUnit *float64 `json:"replicationUnit,omitempty" tf:"replication_unit,omitempty"`

	// Collection of ATP-Dedicated shards that needs to be created.
	ShardDetails []ShardDetailsInitParameters `json:"shardDetails,omitempty" tf:"shard_details,omitempty"`

	// Sharding Method.
	ShardingMethod *string `json:"shardingMethod,omitempty" tf:"sharding_method,omitempty"`

	// (Updatable) An optional property when incremented triggers Start Database. Could be set to any integer value.
	StartDatabaseTrigger *float64 `json:"startDatabaseTrigger,omitempty" tf:"start_database_trigger,omitempty"`

	// (Updatable) An optional property when incremented triggers Stop Database. Could be set to any integer value.
	StopDatabaseTrigger *float64 `json:"stopDatabaseTrigger,omitempty" tf:"stop_database_trigger,omitempty"`

	// (Updatable) An optional property when incremented triggers Upload Signed Certificate And Generate Wallet. Could be set to any integer value.
	UploadSignedCertificateAndGenerateWalletTrigger *float64 `json:"uploadSignedCertificateAndGenerateWalletTrigger,omitempty" tf:"upload_signed_certificate_and_generate_wallet_trigger,omitempty"`

	// (Updatable) An optional property when incremented triggers Validate Network. Could be set to any integer value.
	ValidateNetworkTrigger *float64 `json:"validateNetworkTrigger,omitempty" tf:"validate_network_trigger,omitempty"`
}

type DistributedDatabaseShardedDatabaseObservation struct {
	CASignedCertificate *string `json:"caSignedCertificate,omitempty" tf:"ca_signed_certificate,omitempty"`

	// Collection of ATP-Dedicated catalogs that needs to be created.
	CatalogDetails []CatalogDetailsObservation `json:"catalogDetails,omitempty" tf:"catalog_details,omitempty"`

	// The character set for the new shard database being created. Use database api ListAutonomousDatabaseCharacterSets to get the list of allowed character set for autonomous dedicated database. See documentation: https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/ListAutonomousDatabaseCharacterSets
	CharacterSet *string `json:"characterSet,omitempty" tf:"character_set,omitempty"`

	// The default number of unique chunks in a shardspace. The value of chunks must be greater than 2 times the size of the largest shardgroup in any shardspace.
	Chunks *float64 `json:"chunks,omitempty" tf:"chunks,omitempty"`

	// The certificate common name used in all cloudAutonomousVmClusters for the sharded database topology. Eg. Production. All the clusters used in one sharded database topology shall have same CABundle setup. Valid characterset for clusterCertificateCommonName include uppercase or lowercase letters, numbers, hyphens, underscores, and period.
	ClusterCertificateCommonName *string `json:"clusterCertificateCommonName,omitempty" tf:"cluster_certificate_common_name,omitempty"`

	// (Updatable) Identifier of the compartment where sharded database is to be created.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) An optional property when incremented triggers Configure Gsms. Could be set to any integer value.
	ConfigureGsmsTrigger *float64 `json:"configureGsmsTrigger,omitempty" tf:"configure_gsms_trigger,omitempty"`

	ConfigureGsmsTriggerIsLatestGsmImage *bool `json:"configureGsmsTriggerIsLatestGsmImage,omitempty" tf:"configure_gsms_trigger_is_latest_gsm_image,omitempty"`

	ConfigureGsmsTriggerOldGsmNames []*string `json:"configureGsmsTriggerOldGsmNames,omitempty" tf:"configure_gsms_trigger_old_gsm_names,omitempty"`

	// (Updatable) An optional property when incremented triggers Configure Sharding. Could be set to any integer value.
	ConfigureShardingTrigger *float64 `json:"configureShardingTrigger,omitempty" tf:"configure_sharding_trigger,omitempty"`

	// Details of sharded database connection String.
	ConnectionStrings []ConnectionStringsObservation `json:"connectionStrings,omitempty" tf:"connection_strings,omitempty"`

	// The database deployment type.
	DBDeploymentType *string `json:"dbDeploymentType,omitempty" tf:"db_deployment_type,omitempty"`

	// Oracle Database version of the Autonomous Container Database.
	DBVersion *string `json:"dbVersion,omitempty" tf:"db_version,omitempty"`

	// Possible workload types.
	DBWorkload *string `json:"dbWorkload,omitempty" tf:"db_workload,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Oracle sharded database display name.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) An optional property when incremented triggers Download Gsm Certificate Signing Request. Could be set to any integer value.
	DownloadGsmCertificateSigningRequestTrigger *float64 `json:"downloadGsmCertificateSigningRequestTrigger,omitempty" tf:"download_gsm_certificate_signing_request_trigger,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// (Updatable) An optional property when incremented triggers Generate Gsm Certificate Signing Request. Could be set to any integer value.
	GenerateGsmCertificateSigningRequestTrigger *float64 `json:"generateGsmCertificateSigningRequestTrigger,omitempty" tf:"generate_gsm_certificate_signing_request_trigger,omitempty"`

	// (Updatable) An optional property when incremented triggers Generate Wallet. Could be set to any integer value.
	GenerateWalletTrigger *float64 `json:"generateWalletTrigger,omitempty" tf:"generate_wallet_trigger,omitempty"`

	// (Updatable) An optional property when incremented triggers Get Connection String. Could be set to any integer value.
	GetConnectionStringTrigger *float64 `json:"getConnectionStringTrigger,omitempty" tf:"get_connection_string_trigger,omitempty"`

	// Details of GSM instances for the sharded database.
	Gsms []GsmsObservation `json:"gsms,omitempty" tf:"gsms,omitempty"`

	// Sharded Database identifier
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Lifecycle states for sharded databases.
	LifecycleState *string `json:"lifecycleState,omitempty" tf:"lifecycle_state,omitempty"`

	// Detailed message for the lifecycle state.
	LifecycleStateDetails *string `json:"lifecycleStateDetails,omitempty" tf:"lifecycle_state_details,omitempty"`

	// The listener port number for sharded database.
	ListenerPort *float64 `json:"listenerPort,omitempty" tf:"listener_port,omitempty"`

	// The TLS listener port number for sharded database.
	ListenerPortTLS *float64 `json:"listenerPortTls,omitempty" tf:"listener_port_tls,omitempty"`

	// The national character set for the new shard database being created. Use database api ListAutonomousDatabaseCharacterSets to get the list of allowed national character set for autonomous dedicated database. See documentation: https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/ListAutonomousDatabaseCharacterSets
	NcharacterSet *string `json:"ncharacterSet,omitempty" tf:"ncharacter_set,omitempty"`

	// Ons port local for sharded database.
	OnsPortLocal *float64 `json:"onsPortLocal,omitempty" tf:"ons_port_local,omitempty"`

	// Ons remote port for sharded database.
	OnsPortRemote *float64 `json:"onsPortRemote,omitempty" tf:"ons_port_remote,omitempty"`

	// (Updatable)
	PatchOperations []PatchOperationsObservation `json:"patchOperations,omitempty" tf:"patch_operations,omitempty"`

	// Unique name prefix for the sharded databases. Only alpha-numeric values are allowed. First character has to be a letter followed by any combination of letter and number.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// The OCID of private endpoint being used by the sharded database.
	PrivateEndpoint *string `json:"privateEndpoint,omitempty" tf:"private_endpoint,omitempty"`

	// The Replication factor for RAFT replication based sharded database. Currently supported values are 3, 5 and 7.
	ReplicationFactor *float64 `json:"replicationFactor,omitempty" tf:"replication_factor,omitempty"`

	// The Replication method for sharded database.
	ReplicationMethod *string `json:"replicationMethod,omitempty" tf:"replication_method,omitempty"`

	// For RAFT replication based sharded database, the value should be atleast twice the number of shards.
	ReplicationUnit *float64 `json:"replicationUnit,omitempty" tf:"replication_unit,omitempty"`

	// Collection of ATP-Dedicated shards that needs to be created.
	ShardDetails []ShardDetailsObservation `json:"shardDetails,omitempty" tf:"shard_details,omitempty"`

	ShardedDatabaseID *string `json:"shardedDatabaseId,omitempty" tf:"sharded_database_id,omitempty"`

	// Sharding Method.
	ShardingMethod *string `json:"shardingMethod,omitempty" tf:"sharding_method,omitempty"`

	// (Updatable) An optional property when incremented triggers Start Database. Could be set to any integer value.
	StartDatabaseTrigger *float64 `json:"startDatabaseTrigger,omitempty" tf:"start_database_trigger,omitempty"`

	// Lifecycle states for sharded databases.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// (Updatable) An optional property when incremented triggers Stop Database. Could be set to any integer value.
	StopDatabaseTrigger *float64 `json:"stopDatabaseTrigger,omitempty" tf:"stop_database_trigger,omitempty"`

	// Usage of system tag keys. These predefined keys are scoped to namespaces. Example: {"orcl-cloud.free-tier-retained": "true"}
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// The time the catalog was created. An RFC3339 formatted datetime string
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The time the catalog was last created. An RFC3339 formatted datetime string
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`

	// Timezone associated with the sharded database.
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`

	// (Updatable) An optional property when incremented triggers Upload Signed Certificate And Generate Wallet. Could be set to any integer value.
	UploadSignedCertificateAndGenerateWalletTrigger *float64 `json:"uploadSignedCertificateAndGenerateWalletTrigger,omitempty" tf:"upload_signed_certificate_and_generate_wallet_trigger,omitempty"`

	// (Updatable) An optional property when incremented triggers Validate Network. Could be set to any integer value.
	ValidateNetworkTrigger *float64 `json:"validateNetworkTrigger,omitempty" tf:"validate_network_trigger,omitempty"`
}

type DistributedDatabaseShardedDatabaseParameters struct {

	// +kubebuilder:validation:Optional
	CASignedCertificate *string `json:"caSignedCertificate,omitempty" tf:"ca_signed_certificate,omitempty"`

	// Collection of ATP-Dedicated catalogs that needs to be created.
	// +kubebuilder:validation:Optional
	CatalogDetails []CatalogDetailsParameters `json:"catalogDetails,omitempty" tf:"catalog_details,omitempty"`

	// The character set for the new shard database being created. Use database api ListAutonomousDatabaseCharacterSets to get the list of allowed character set for autonomous dedicated database. See documentation: https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/ListAutonomousDatabaseCharacterSets
	// +kubebuilder:validation:Optional
	CharacterSet *string `json:"characterSet,omitempty" tf:"character_set,omitempty"`

	// The default number of unique chunks in a shardspace. The value of chunks must be greater than 2 times the size of the largest shardgroup in any shardspace.
	// +kubebuilder:validation:Optional
	Chunks *float64 `json:"chunks,omitempty" tf:"chunks,omitempty"`

	// The certificate common name used in all cloudAutonomousVmClusters for the sharded database topology. Eg. Production. All the clusters used in one sharded database topology shall have same CABundle setup. Valid characterset for clusterCertificateCommonName include uppercase or lowercase letters, numbers, hyphens, underscores, and period.
	// +kubebuilder:validation:Optional
	ClusterCertificateCommonName *string `json:"clusterCertificateCommonName,omitempty" tf:"cluster_certificate_common_name,omitempty"`

	// (Updatable) Identifier of the compartment where sharded database is to be created.
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) An optional property when incremented triggers Configure Gsms. Could be set to any integer value.
	// +kubebuilder:validation:Optional
	ConfigureGsmsTrigger *float64 `json:"configureGsmsTrigger,omitempty" tf:"configure_gsms_trigger,omitempty"`

	// +kubebuilder:validation:Optional
	ConfigureGsmsTriggerIsLatestGsmImage *bool `json:"configureGsmsTriggerIsLatestGsmImage,omitempty" tf:"configure_gsms_trigger_is_latest_gsm_image,omitempty"`

	// +kubebuilder:validation:Optional
	ConfigureGsmsTriggerOldGsmNames []*string `json:"configureGsmsTriggerOldGsmNames,omitempty" tf:"configure_gsms_trigger_old_gsm_names,omitempty"`

	// (Updatable) An optional property when incremented triggers Configure Sharding. Could be set to any integer value.
	// +kubebuilder:validation:Optional
	ConfigureShardingTrigger *float64 `json:"configureShardingTrigger,omitempty" tf:"configure_sharding_trigger,omitempty"`

	// The database deployment type.
	// +kubebuilder:validation:Optional
	DBDeploymentType *string `json:"dbDeploymentType,omitempty" tf:"db_deployment_type,omitempty"`

	// Oracle Database version of the Autonomous Container Database.
	// +kubebuilder:validation:Optional
	DBVersion *string `json:"dbVersion,omitempty" tf:"db_version,omitempty"`

	// Possible workload types.
	// +kubebuilder:validation:Optional
	DBWorkload *string `json:"dbWorkload,omitempty" tf:"db_workload,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Oracle sharded database display name.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) An optional property when incremented triggers Download Gsm Certificate Signing Request. Could be set to any integer value.
	// +kubebuilder:validation:Optional
	DownloadGsmCertificateSigningRequestTrigger *float64 `json:"downloadGsmCertificateSigningRequestTrigger,omitempty" tf:"download_gsm_certificate_signing_request_trigger,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// (Updatable) An optional property when incremented triggers Generate Gsm Certificate Signing Request. Could be set to any integer value.
	// +kubebuilder:validation:Optional
	GenerateGsmCertificateSigningRequestTrigger *float64 `json:"generateGsmCertificateSigningRequestTrigger,omitempty" tf:"generate_gsm_certificate_signing_request_trigger,omitempty"`

	// +kubebuilder:validation:Optional
	GenerateWalletPasswordSecretRef *v1.SecretKeySelector `json:"generateWalletPasswordSecretRef,omitempty" tf:"-"`

	// (Updatable) An optional property when incremented triggers Generate Wallet. Could be set to any integer value.
	// +kubebuilder:validation:Optional
	GenerateWalletTrigger *float64 `json:"generateWalletTrigger,omitempty" tf:"generate_wallet_trigger,omitempty"`

	// (Updatable) An optional property when incremented triggers Get Connection String. Could be set to any integer value.
	// +kubebuilder:validation:Optional
	GetConnectionStringTrigger *float64 `json:"getConnectionStringTrigger,omitempty" tf:"get_connection_string_trigger,omitempty"`

	// The listener port number for sharded database.
	// +kubebuilder:validation:Optional
	ListenerPort *float64 `json:"listenerPort,omitempty" tf:"listener_port,omitempty"`

	// The TLS listener port number for sharded database.
	// +kubebuilder:validation:Optional
	ListenerPortTLS *float64 `json:"listenerPortTls,omitempty" tf:"listener_port_tls,omitempty"`

	// The national character set for the new shard database being created. Use database api ListAutonomousDatabaseCharacterSets to get the list of allowed national character set for autonomous dedicated database. See documentation: https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/ListAutonomousDatabaseCharacterSets
	// +kubebuilder:validation:Optional
	NcharacterSet *string `json:"ncharacterSet,omitempty" tf:"ncharacter_set,omitempty"`

	// Ons port local for sharded database.
	// +kubebuilder:validation:Optional
	OnsPortLocal *float64 `json:"onsPortLocal,omitempty" tf:"ons_port_local,omitempty"`

	// Ons remote port for sharded database.
	// +kubebuilder:validation:Optional
	OnsPortRemote *float64 `json:"onsPortRemote,omitempty" tf:"ons_port_remote,omitempty"`

	// (Updatable)
	// +kubebuilder:validation:Optional
	PatchOperations []PatchOperationsParameters `json:"patchOperations,omitempty" tf:"patch_operations,omitempty"`

	// Unique name prefix for the sharded databases. Only alpha-numeric values are allowed. First character has to be a letter followed by any combination of letter and number.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// The Replication factor for RAFT replication based sharded database. Currently supported values are 3, 5 and 7.
	// +kubebuilder:validation:Optional
	ReplicationFactor *float64 `json:"replicationFactor,omitempty" tf:"replication_factor,omitempty"`

	// The Replication method for sharded database.
	// +kubebuilder:validation:Optional
	ReplicationMethod *string `json:"replicationMethod,omitempty" tf:"replication_method,omitempty"`

	// For RAFT replication based sharded database, the value should be atleast twice the number of shards.
	// +kubebuilder:validation:Optional
	ReplicationUnit *float64 `json:"replicationUnit,omitempty" tf:"replication_unit,omitempty"`

	// Collection of ATP-Dedicated shards that needs to be created.
	// +kubebuilder:validation:Optional
	ShardDetails []ShardDetailsParameters `json:"shardDetails,omitempty" tf:"shard_details,omitempty"`

	// Sharding Method.
	// +kubebuilder:validation:Optional
	ShardingMethod *string `json:"shardingMethod,omitempty" tf:"sharding_method,omitempty"`

	// (Updatable) An optional property when incremented triggers Start Database. Could be set to any integer value.
	// +kubebuilder:validation:Optional
	StartDatabaseTrigger *float64 `json:"startDatabaseTrigger,omitempty" tf:"start_database_trigger,omitempty"`

	// (Updatable) An optional property when incremented triggers Stop Database. Could be set to any integer value.
	// +kubebuilder:validation:Optional
	StopDatabaseTrigger *float64 `json:"stopDatabaseTrigger,omitempty" tf:"stop_database_trigger,omitempty"`

	// (Updatable) An optional property when incremented triggers Upload Signed Certificate And Generate Wallet. Could be set to any integer value.
	// +kubebuilder:validation:Optional
	UploadSignedCertificateAndGenerateWalletTrigger *float64 `json:"uploadSignedCertificateAndGenerateWalletTrigger,omitempty" tf:"upload_signed_certificate_and_generate_wallet_trigger,omitempty"`

	// (Updatable) An optional property when incremented triggers Validate Network. Could be set to any integer value.
	// +kubebuilder:validation:Optional
	ValidateNetworkTrigger *float64 `json:"validateNetworkTrigger,omitempty" tf:"validate_network_trigger,omitempty"`
}

type EncryptionKeyDetailsInitParameters struct {

	// The OCID of the KMS key in vault identified by vaultId in customer tenancy  that is used as the master encryption key.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The OCID of the KMS key version for key identified by kmsKeyId that is used in data encryption (TDE) operations.
	KMSKeyVersionID *string `json:"kmsKeyVersionId,omitempty" tf:"kms_key_version_id,omitempty"`

	// The OCID of the vault in customer tenancy where KMS key is present. For shard or catalog with cross-region data guard enabled, user needs to make sure to provide virtual private vault only, which is also replicated in the region of standby shard.
	VaultID *string `json:"vaultId,omitempty" tf:"vault_id,omitempty"`
}

type EncryptionKeyDetailsObservation struct {

	// The OCID of the KMS key in vault identified by vaultId in customer tenancy  that is used as the master encryption key.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The OCID of the KMS key version for key identified by kmsKeyId that is used in data encryption (TDE) operations.
	KMSKeyVersionID *string `json:"kmsKeyVersionId,omitempty" tf:"kms_key_version_id,omitempty"`

	// The OCID of the vault in customer tenancy where KMS key is present. For shard or catalog with cross-region data guard enabled, user needs to make sure to provide virtual private vault only, which is also replicated in the region of standby shard.
	VaultID *string `json:"vaultId,omitempty" tf:"vault_id,omitempty"`
}

type EncryptionKeyDetailsParameters struct {

	// The OCID of the KMS key in vault identified by vaultId in customer tenancy  that is used as the master encryption key.
	// +kubebuilder:validation:Optional
	KMSKeyID *string `json:"kmsKeyId" tf:"kms_key_id,omitempty"`

	// The OCID of the KMS key version for key identified by kmsKeyId that is used in data encryption (TDE) operations.
	// +kubebuilder:validation:Optional
	KMSKeyVersionID *string `json:"kmsKeyVersionId,omitempty" tf:"kms_key_version_id,omitempty"`

	// The OCID of the vault in customer tenancy where KMS key is present. For shard or catalog with cross-region data guard enabled, user needs to make sure to provide virtual private vault only, which is also replicated in the region of standby shard.
	// +kubebuilder:validation:Optional
	VaultID *string `json:"vaultId" tf:"vault_id,omitempty"`
}

type GsmsInitParameters struct {
}

type GsmsObservation struct {

	// The compute count for the catalog database. It has to be in multiple of 2.
	ComputeCount *float64 `json:"computeCount,omitempty" tf:"compute_count,omitempty"`

	// The data disk group size to be allocated in GBs for the catalog database.
	DataStorageSizeInGbs *float64 `json:"dataStorageSizeInGbs,omitempty" tf:"data_storage_size_in_gbs,omitempty"`

	// Additional metadata related to catalog's underlying supporting resource.
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// Catalog name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Status of shard or catalog or gsm for the sharded database.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// Identifier of the underlying supporting resource.
	SupportingResourceID *string `json:"supportingResourceId,omitempty" tf:"supporting_resource_id,omitempty"`

	// The time the catalog was created. An RFC3339 formatted datetime string
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The time the ssl certificate associated with catalog expires. An RFC3339 formatted datetime string
	TimeSSLCertificateExpires *string `json:"timeSslCertificateExpires,omitempty" tf:"time_ssl_certificate_expires,omitempty"`

	// The time the catalog was last created. An RFC3339 formatted datetime string
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`
}

type GsmsParameters struct {
}

type PatchOperationsInitParameters struct {

	// (Updatable) The operation can be one of these values: INSERT, MERGE, REMOVE
	Operation *string `json:"operation,omitempty" tf:"operation,omitempty"`

	// (Updatable)
	Selection *string `json:"selection,omitempty" tf:"selection,omitempty"`

	// (Updatable)
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PatchOperationsObservation struct {

	// (Updatable) The operation can be one of these values: INSERT, MERGE, REMOVE
	Operation *string `json:"operation,omitempty" tf:"operation,omitempty"`

	// (Updatable)
	Selection *string `json:"selection,omitempty" tf:"selection,omitempty"`

	// (Updatable)
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PatchOperationsParameters struct {

	// (Updatable) The operation can be one of these values: INSERT, MERGE, REMOVE
	// +kubebuilder:validation:Optional
	Operation *string `json:"operation" tf:"operation,omitempty"`

	// (Updatable)
	// +kubebuilder:validation:Optional
	Selection *string `json:"selection" tf:"selection,omitempty"`

	// (Updatable)
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type ShardDetailsEncryptionKeyDetailsInitParameters struct {

	// The OCID of the KMS key in vault identified by vaultId in customer tenancy  that is used as the master encryption key.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The OCID of the KMS key version for key identified by kmsKeyId that is used in data encryption (TDE) operations.
	KMSKeyVersionID *string `json:"kmsKeyVersionId,omitempty" tf:"kms_key_version_id,omitempty"`

	// The OCID of the vault in customer tenancy where KMS key is present. For shard or catalog with cross-region data guard enabled, user needs to make sure to provide virtual private vault only, which is also replicated in the region of standby shard.
	VaultID *string `json:"vaultId,omitempty" tf:"vault_id,omitempty"`
}

type ShardDetailsEncryptionKeyDetailsObservation struct {

	// The OCID of the KMS key in vault identified by vaultId in customer tenancy  that is used as the master encryption key.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The OCID of the KMS key version for key identified by kmsKeyId that is used in data encryption (TDE) operations.
	KMSKeyVersionID *string `json:"kmsKeyVersionId,omitempty" tf:"kms_key_version_id,omitempty"`

	// The OCID of the vault in customer tenancy where KMS key is present. For shard or catalog with cross-region data guard enabled, user needs to make sure to provide virtual private vault only, which is also replicated in the region of standby shard.
	VaultID *string `json:"vaultId,omitempty" tf:"vault_id,omitempty"`
}

type ShardDetailsEncryptionKeyDetailsParameters struct {

	// The OCID of the KMS key in vault identified by vaultId in customer tenancy  that is used as the master encryption key.
	// +kubebuilder:validation:Optional
	KMSKeyID *string `json:"kmsKeyId" tf:"kms_key_id,omitempty"`

	// The OCID of the KMS key version for key identified by kmsKeyId that is used in data encryption (TDE) operations.
	// +kubebuilder:validation:Optional
	KMSKeyVersionID *string `json:"kmsKeyVersionId,omitempty" tf:"kms_key_version_id,omitempty"`

	// The OCID of the vault in customer tenancy where KMS key is present. For shard or catalog with cross-region data guard enabled, user needs to make sure to provide virtual private vault only, which is also replicated in the region of standby shard.
	// +kubebuilder:validation:Optional
	VaultID *string `json:"vaultId" tf:"vault_id,omitempty"`
}

type ShardDetailsInitParameters struct {

	// Admin password for the catalog database.
	AdminPasswordSecretRef v1.SecretKeySelector `json:"adminPasswordSecretRef" tf:"-"`

	// The OCID of the cloud Autonomous Exadata VM Cluster.
	CloudAutonomousVMClusterID *string `json:"cloudAutonomousVmClusterId,omitempty" tf:"cloud_autonomous_vm_cluster_id,omitempty"`

	// The compute count for the catalog database. It has to be in multiple of 2.
	ComputeCount *float64 `json:"computeCount,omitempty" tf:"compute_count,omitempty"`

	// The data disk group size to be allocated in GBs for the catalog database.
	DataStorageSizeInGbs *float64 `json:"dataStorageSizeInGbs,omitempty" tf:"data_storage_size_in_gbs,omitempty"`

	// Details of encryption key to be used to encrypt data for shards and catalog for sharded database. For system-defined sharding type, all shards have to use same encryptionKeyDetails. For system-defined sharding, if encryptionKeyDetails are not specified for catalog, then Oracle managed key will be used for catalog. For user-defined sharding type, if encryptionKeyDetails are not provided for any shard or catalog, then Oracle managed key will be used for such shard or catalog. For system-defined or user-defined sharding type, if the shard or catalog has a peer in region other than primary shard or catalog region, then make sure to provide virtual vault for such shard or catalog, which is also replicated to peer region (the region where peer or standby shard or catalog exists).
	EncryptionKeyDetails []ShardDetailsEncryptionKeyDetailsInitParameters `json:"encryptionKeyDetails,omitempty" tf:"encryption_key_details,omitempty"`

	// Determines the auto-scaling mode for the catalog database.
	IsAutoScalingEnabled *bool `json:"isAutoScalingEnabled,omitempty" tf:"is_auto_scaling_enabled,omitempty"`

	// The OCID of the peer cloud Autonomous Exadata VM Cluster.
	PeerCloudAutonomousVMClusterID *string `json:"peerCloudAutonomousVmClusterId,omitempty" tf:"peer_cloud_autonomous_vm_cluster_id,omitempty"`

	// The shard space name for the shard database. Shard space for existing shard cannot be changed, once shard is created. Shard space name shall be used while creation of new shards. For User defined sharding, every shard must have a unique shard space name. For system defined sharding, shard space name is not required.
	ShardSpace *string `json:"shardSpace,omitempty" tf:"shard_space,omitempty"`
}

type ShardDetailsObservation struct {

	// The OCID of the cloud Autonomous Exadata VM Cluster.
	CloudAutonomousVMClusterID *string `json:"cloudAutonomousVmClusterId,omitempty" tf:"cloud_autonomous_vm_cluster_id,omitempty"`

	// The compute count for the catalog database. It has to be in multiple of 2.
	ComputeCount *float64 `json:"computeCount,omitempty" tf:"compute_count,omitempty"`

	// Identifier of the underlying container database.
	ContainerDatabaseID *string `json:"containerDatabaseId,omitempty" tf:"container_database_id,omitempty"`

	// Identifier of the underlying container database parent.
	ContainerDatabaseParentID *string `json:"containerDatabaseParentId,omitempty" tf:"container_database_parent_id,omitempty"`

	// The data disk group size to be allocated in GBs for the catalog database.
	DataStorageSizeInGbs *float64 `json:"dataStorageSizeInGbs,omitempty" tf:"data_storage_size_in_gbs,omitempty"`

	// Details of encryption key to be used to encrypt data for shards and catalog for sharded database. For system-defined sharding type, all shards have to use same encryptionKeyDetails. For system-defined sharding, if encryptionKeyDetails are not specified for catalog, then Oracle managed key will be used for catalog. For user-defined sharding type, if encryptionKeyDetails are not provided for any shard or catalog, then Oracle managed key will be used for such shard or catalog. For system-defined or user-defined sharding type, if the shard or catalog has a peer in region other than primary shard or catalog region, then make sure to provide virtual vault for such shard or catalog, which is also replicated to peer region (the region where peer or standby shard or catalog exists).
	EncryptionKeyDetails []ShardDetailsEncryptionKeyDetailsObservation `json:"encryptionKeyDetails,omitempty" tf:"encryption_key_details,omitempty"`

	// Determines the auto-scaling mode for the catalog database.
	IsAutoScalingEnabled *bool `json:"isAutoScalingEnabled,omitempty" tf:"is_auto_scaling_enabled,omitempty"`

	// Additional metadata related to catalog's underlying supporting resource.
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// Catalog name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The OCID of the peer cloud Autonomous Exadata VM Cluster.
	PeerCloudAutonomousVMClusterID *string `json:"peerCloudAutonomousVmClusterId,omitempty" tf:"peer_cloud_autonomous_vm_cluster_id,omitempty"`

	// Name of the shard-group to which the catalog belongs.
	ShardGroup *string `json:"shardGroup,omitempty" tf:"shard_group,omitempty"`

	// The shard space name for the shard database. Shard space for existing shard cannot be changed, once shard is created. Shard space name shall be used while creation of new shards. For User defined sharding, every shard must have a unique shard space name. For system defined sharding, shard space name is not required.
	ShardSpace *string `json:"shardSpace,omitempty" tf:"shard_space,omitempty"`

	// Status of shard or catalog or gsm for the sharded database.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// Identifier of the underlying supporting resource.
	SupportingResourceID *string `json:"supportingResourceId,omitempty" tf:"supporting_resource_id,omitempty"`

	// The time the catalog was created. An RFC3339 formatted datetime string
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The time the ssl certificate associated with catalog expires. An RFC3339 formatted datetime string
	TimeSSLCertificateExpires *string `json:"timeSslCertificateExpires,omitempty" tf:"time_ssl_certificate_expires,omitempty"`

	// The time the catalog was last created. An RFC3339 formatted datetime string
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`
}

type ShardDetailsParameters struct {

	// Admin password for the catalog database.
	// +kubebuilder:validation:Optional
	AdminPasswordSecretRef v1.SecretKeySelector `json:"adminPasswordSecretRef" tf:"-"`

	// The OCID of the cloud Autonomous Exadata VM Cluster.
	// +kubebuilder:validation:Optional
	CloudAutonomousVMClusterID *string `json:"cloudAutonomousVmClusterId" tf:"cloud_autonomous_vm_cluster_id,omitempty"`

	// The compute count for the catalog database. It has to be in multiple of 2.
	// +kubebuilder:validation:Optional
	ComputeCount *float64 `json:"computeCount" tf:"compute_count,omitempty"`

	// The data disk group size to be allocated in GBs for the catalog database.
	// +kubebuilder:validation:Optional
	DataStorageSizeInGbs *float64 `json:"dataStorageSizeInGbs" tf:"data_storage_size_in_gbs,omitempty"`

	// Details of encryption key to be used to encrypt data for shards and catalog for sharded database. For system-defined sharding type, all shards have to use same encryptionKeyDetails. For system-defined sharding, if encryptionKeyDetails are not specified for catalog, then Oracle managed key will be used for catalog. For user-defined sharding type, if encryptionKeyDetails are not provided for any shard or catalog, then Oracle managed key will be used for such shard or catalog. For system-defined or user-defined sharding type, if the shard or catalog has a peer in region other than primary shard or catalog region, then make sure to provide virtual vault for such shard or catalog, which is also replicated to peer region (the region where peer or standby shard or catalog exists).
	// +kubebuilder:validation:Optional
	EncryptionKeyDetails []ShardDetailsEncryptionKeyDetailsParameters `json:"encryptionKeyDetails,omitempty" tf:"encryption_key_details,omitempty"`

	// Determines the auto-scaling mode for the catalog database.
	// +kubebuilder:validation:Optional
	IsAutoScalingEnabled *bool `json:"isAutoScalingEnabled" tf:"is_auto_scaling_enabled,omitempty"`

	// The OCID of the peer cloud Autonomous Exadata VM Cluster.
	// +kubebuilder:validation:Optional
	PeerCloudAutonomousVMClusterID *string `json:"peerCloudAutonomousVmClusterId,omitempty" tf:"peer_cloud_autonomous_vm_cluster_id,omitempty"`

	// The shard space name for the shard database. Shard space for existing shard cannot be changed, once shard is created. Shard space name shall be used while creation of new shards. For User defined sharding, every shard must have a unique shard space name. For system defined sharding, shard space name is not required.
	// +kubebuilder:validation:Optional
	ShardSpace *string `json:"shardSpace,omitempty" tf:"shard_space,omitempty"`
}

// DistributedDatabaseShardedDatabaseSpec defines the desired state of DistributedDatabaseShardedDatabase
type DistributedDatabaseShardedDatabaseSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DistributedDatabaseShardedDatabaseParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider DistributedDatabaseShardedDatabaseInitParameters `json:"initProvider,omitempty"`
}

// DistributedDatabaseShardedDatabaseStatus defines the observed state of DistributedDatabaseShardedDatabase.
type DistributedDatabaseShardedDatabaseStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DistributedDatabaseShardedDatabaseObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// DistributedDatabaseShardedDatabase is the Schema for the DistributedDatabaseShardedDatabases API. Provides the Sharded Database resource in Oracle Cloud Infrastructure Globally Distributed Database service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type DistributedDatabaseShardedDatabase struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.catalogDetails) || (has(self.initProvider) && has(self.initProvider.catalogDetails))",message="spec.forProvider.catalogDetails is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.characterSet) || (has(self.initProvider) && has(self.initProvider.characterSet))",message="spec.forProvider.characterSet is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.compartmentId) || (has(self.initProvider) && has(self.initProvider.compartmentId))",message="spec.forProvider.compartmentId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.dbDeploymentType) || (has(self.initProvider) && has(self.initProvider.dbDeploymentType))",message="spec.forProvider.dbDeploymentType is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.dbVersion) || (has(self.initProvider) && has(self.initProvider.dbVersion))",message="spec.forProvider.dbVersion is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.dbWorkload) || (has(self.initProvider) && has(self.initProvider.dbWorkload))",message="spec.forProvider.dbWorkload is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.displayName) || (has(self.initProvider) && has(self.initProvider.displayName))",message="spec.forProvider.displayName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.listenerPort) || (has(self.initProvider) && has(self.initProvider.listenerPort))",message="spec.forProvider.listenerPort is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.listenerPortTls) || (has(self.initProvider) && has(self.initProvider.listenerPortTls))",message="spec.forProvider.listenerPortTls is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.ncharacterSet) || (has(self.initProvider) && has(self.initProvider.ncharacterSet))",message="spec.forProvider.ncharacterSet is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.onsPortLocal) || (has(self.initProvider) && has(self.initProvider.onsPortLocal))",message="spec.forProvider.onsPortLocal is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.onsPortRemote) || (has(self.initProvider) && has(self.initProvider.onsPortRemote))",message="spec.forProvider.onsPortRemote is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.prefix) || (has(self.initProvider) && has(self.initProvider.prefix))",message="spec.forProvider.prefix is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.shardDetails) || (has(self.initProvider) && has(self.initProvider.shardDetails))",message="spec.forProvider.shardDetails is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.shardingMethod) || (has(self.initProvider) && has(self.initProvider.shardingMethod))",message="spec.forProvider.shardingMethod is a required parameter"
	Spec   DistributedDatabaseShardedDatabaseSpec   `json:"spec"`
	Status DistributedDatabaseShardedDatabaseStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DistributedDatabaseShardedDatabaseList contains a list of DistributedDatabaseShardedDatabases
type DistributedDatabaseShardedDatabaseList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DistributedDatabaseShardedDatabase `json:"items"`
}

// Repository type metadata.
var (
	DistributedDatabaseShardedDatabase_Kind             = "DistributedDatabaseShardedDatabase"
	DistributedDatabaseShardedDatabase_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DistributedDatabaseShardedDatabase_Kind}.String()
	DistributedDatabaseShardedDatabase_KindAPIVersion   = DistributedDatabaseShardedDatabase_Kind + "." + CRDGroupVersion.String()
	DistributedDatabaseShardedDatabase_GroupVersionKind = CRDGroupVersion.WithKind(DistributedDatabaseShardedDatabase_Kind)
)

func init() {
	SchemeBuilder.Register(&DistributedDatabaseShardedDatabase{}, &DistributedDatabaseShardedDatabaseList{})
}
