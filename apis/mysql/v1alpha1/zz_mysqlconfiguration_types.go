/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type InitVariablesInitParameters struct {

	// Represents the MySQL server system variable lower_case_table_names (https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_lower_case_table_names).
	LowerCaseTableNames *string `json:"lowerCaseTableNames,omitempty" tf:"lower_case_table_names,omitempty"`
}

type InitVariablesObservation struct {

	// Represents the MySQL server system variable lower_case_table_names (https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_lower_case_table_names).
	LowerCaseTableNames *string `json:"lowerCaseTableNames,omitempty" tf:"lower_case_table_names,omitempty"`
}

type InitVariablesParameters struct {

	// Represents the MySQL server system variable lower_case_table_names (https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_lower_case_table_names).
	// +kubebuilder:validation:Optional
	LowerCaseTableNames *string `json:"lowerCaseTableNames,omitempty" tf:"lower_case_table_names,omitempty"`
}

type MysqlConfigurationInitParameters struct {

	// The OCID of the compartment.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) User-provided data about the Configuration.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) The display name of the Configuration.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// User-defined service variables set only at DB system initialization. These variables cannot be changed later at runtime.
	InitVariables []InitVariablesInitParameters `json:"initVariables,omitempty" tf:"init_variables,omitempty"`

	// The OCID of the Configuration from which the new Configuration is derived. The values in CreateConfigurationDetails.variables supersede the variables of the parent Configuration.
	ParentConfigurationID *string `json:"parentConfigurationId,omitempty" tf:"parent_configuration_id,omitempty"`

	// The name of the associated Shape.
	ShapeName *string `json:"shapeName,omitempty" tf:"shape_name,omitempty"`

	// User-defined service variables.
	Variables []VariablesInitParameters `json:"variables,omitempty" tf:"variables,omitempty"`
}

type MysqlConfigurationObservation struct {

	// The OCID of the compartment.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) User-provided data about the Configuration.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) The display name of the Configuration.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The OCID of the Configuration.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// User-defined service variables set only at DB system initialization. These variables cannot be changed later at runtime.
	InitVariables []InitVariablesObservation `json:"initVariables,omitempty" tf:"init_variables,omitempty"`

	// The OCID of the Configuration from which the new Configuration is derived. The values in CreateConfigurationDetails.variables supersede the variables of the parent Configuration.
	ParentConfigurationID *string `json:"parentConfigurationId,omitempty" tf:"parent_configuration_id,omitempty"`

	// The name of the associated Shape.
	ShapeName *string `json:"shapeName,omitempty" tf:"shape_name,omitempty"`

	// The current state of the Configuration.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Usage of system tag keys. These predefined keys are scoped to namespaces. Example: {"orcl-cloud.free-tier-retained": "true"}
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// The date and time the Configuration was created, as described by RFC 3339.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The date and time the Configuration was last updated, as described by RFC 3339.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`

	// The Configuration type, DEFAULT or CUSTOM.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// User-defined service variables.
	Variables []VariablesObservation `json:"variables,omitempty" tf:"variables,omitempty"`
}

type MysqlConfigurationParameters struct {

	// The OCID of the compartment.
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) User-provided data about the Configuration.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) The display name of the Configuration.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// User-defined service variables set only at DB system initialization. These variables cannot be changed later at runtime.
	// +kubebuilder:validation:Optional
	InitVariables []InitVariablesParameters `json:"initVariables,omitempty" tf:"init_variables,omitempty"`

	// The OCID of the Configuration from which the new Configuration is derived. The values in CreateConfigurationDetails.variables supersede the variables of the parent Configuration.
	// +kubebuilder:validation:Optional
	ParentConfigurationID *string `json:"parentConfigurationId,omitempty" tf:"parent_configuration_id,omitempty"`

	// The name of the associated Shape.
	// +kubebuilder:validation:Optional
	ShapeName *string `json:"shapeName,omitempty" tf:"shape_name,omitempty"`

	// User-defined service variables.
	// +kubebuilder:validation:Optional
	Variables []VariablesParameters `json:"variables,omitempty" tf:"variables,omitempty"`
}

type VariablesInitParameters struct {

	// auto_increment_increment and auto_increment_offset are intended for use with circular (source-to-source) replication, and can be used to control the operation of AUTO_INCREMENT columns. Both variables have global and session values, and each can assume an integer value between 1 and 65,535 inclusive.
	AutoIncrementIncrement *float64 `json:"autoIncrementIncrement,omitempty" tf:"auto_increment_increment,omitempty"`

	// This variable has a default value of 1. If it is left with its default value, and Group Replication is started on the server in multi-primary mode, it is changed to the server ID.
	AutoIncrementOffset *float64 `json:"autoIncrementOffset,omitempty" tf:"auto_increment_offset,omitempty"`

	// ("autocommit")
	Autocommit *bool `json:"autocommit,omitempty" tf:"autocommit,omitempty"`

	// If enabled, the server stores all temporary tables on disk rather than in memory.
	BigTables *bool `json:"bigTables,omitempty" tf:"big_tables,omitempty"`

	// Sets the binary log expiration period in seconds. binlogExpireLogsSeconds corresponds to the MySQL binary logging system variable binlog_expire_logs_seconds.
	BinlogExpireLogsSeconds *float64 `json:"binlogExpireLogsSeconds,omitempty" tf:"binlog_expire_logs_seconds,omitempty"`

	// Controls how many microseconds the binary log commit waits before synchronizing the binary log file to disk. There is no delay by default. Setting this variable to a microsecond delay enables more transactions to be synchronized together to disk at once, reducing the overall time to commit a group of transactions because the larger groups required fewer time units per group.
	BinlogGroupCommitSyncDelay *float64 `json:"binlogGroupCommitSyncDelay,omitempty" tf:"binlog_group_commit_sync_delay,omitempty"`

	// The maximum number of transactions to wait for before aborting the current delay as specified by binlog_group_commit_sync_delay. If binlog_group_commit_sync_delay is set to 0, then this option has no effect.
	BinlogGroupCommitSyncNoDelayCount *float64 `json:"binlogGroupCommitSyncNoDelayCount,omitempty" tf:"binlog_group_commit_sync_no_delay_count,omitempty"`

	// Configures the amount of table metadata added to the binary log when using row-based logging. binlogRowMetadata corresponds to the MySQL binary logging system variable binlog_row_metadata.
	BinlogRowMetadata *string `json:"binlogRowMetadata,omitempty" tf:"binlog_row_metadata,omitempty"`

	// When set to PARTIAL_JSON, this enables use of a space-efficient binary log format for updates that modify only a small portion of a JSON document. binlogRowValueOptions corresponds to the MySQL binary logging system variable binlog_row_value_options.
	BinlogRowValueOptions *string `json:"binlogRowValueOptions,omitempty" tf:"binlog_row_value_options,omitempty"`

	// Enables compression for transactions that are written to binary log files on this server. binlogTransactionCompression corresponds to the MySQL binary logging system variable binlog_transaction_compression.
	BinlogTransactionCompression *bool `json:"binlogTransactionCompression,omitempty" tf:"binlog_transaction_compression,omitempty"`

	// This variable controls the block encryption mode for block-based algorithms such as AES. It affects encryption for AES_ENCRYPT() and AES_DECRYPT(). block_encryption_mode takes a value in aes-keylen-mode format, where keylen is the key length in bits and mode is the encryption mode. The value is not case-sensitive. Permitted keylen values are 128, 192, and 256. Permitted mode values are ECB, CBC, CFB1, CFB8, CFB128, and OFB.
	BlockEncryptionMode *string `json:"blockEncryptionMode,omitempty" tf:"block_encryption_mode,omitempty"`

	// The server's default character set. If you set this variable, you should also set collation_server to specify the collation for the character set.
	CharacterSetServer *string `json:"characterSetServer,omitempty" tf:"character_set_server,omitempty"`

	// The server's default collation.
	CollationServer *string `json:"collationServer,omitempty" tf:"collation_server,omitempty"`

	// ("completion_type")
	CompletionType *string `json:"completionType,omitempty" tf:"completion_type,omitempty"`

	// The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
	ConnectTimeout *float64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Set the chunking size for updates to the global memory usage counter Global_connection_memory.
	ConnectionMemoryChunkSize *float64 `json:"connectionMemoryChunkSize,omitempty" tf:"connection_memory_chunk_size,omitempty"`

	// Set the maximum amount of memory that can be used by a single user connection.
	ConnectionMemoryLimit *string `json:"connectionMemoryLimit,omitempty" tf:"connection_memory_limit,omitempty"`

	// ("cte_max_recursion_depth")
	CteMaxRecursionDepth *string `json:"cteMaxRecursionDepth,omitempty" tf:"cte_max_recursion_depth,omitempty"`

	// The default authentication plugin. This must be a plugin that uses internal credentials storage, so these values are permitted: mysql_native_password, sha256_password, caching_sha2_password.
	DefaultAuthenticationPlugin *string `json:"defaultAuthenticationPlugin,omitempty" tf:"default_authentication_plugin,omitempty"`

	// This variable determines the default output format used by EXPLAIN in the absence of a FORMAT option when displaying a query execution plan.
	ExplainFormat *string `json:"explainFormat,omitempty" tf:"explain_format,omitempty"`

	// This system variable determines whether the server enables certain nonstandard behaviors for default values and NULL-value handling in TIMESTAMP columns. By default, explicit_defaults_for_timestamp is enabled, which disables the nonstandard behaviors. Disabling explicit_defaults_for_timestamp results in a warning.
	ExplicitDefaultsForTimestamp *bool `json:"explicitDefaultsForTimestamp,omitempty" tf:"explicit_defaults_for_timestamp,omitempty"`

	// ("foreign_key_checks")
	ForeignKeyChecks *bool `json:"foreignKeyChecks,omitempty" tf:"foreign_key_checks,omitempty"`

	// ("generated_random_password_length") DEPRECATED -- variable should not be settable and will be ignored
	GeneratedRandomPasswordLength *float64 `json:"generatedRandomPasswordLength,omitempty" tf:"generated_random_password_length,omitempty"`

	// Set the total amount of memory that can be used by all user connections.
	GlobalConnectionMemoryLimit *string `json:"globalConnectionMemoryLimit,omitempty" tf:"global_connection_memory_limit,omitempty"`

	// Determines whether the MySQL server calculates Global_connection_memory.
	GlobalConnectionMemoryTracking *bool `json:"globalConnectionMemoryTracking,omitempty" tf:"global_connection_memory_tracking,omitempty"`

	// Specifies the maximum permitted result length in bytes for the GROUP_CONCAT() function.
	GroupConcatMaxLen *string `json:"groupConcatMaxLen,omitempty" tf:"group_concat_max_len,omitempty"`

	GroupReplicationConsistency *string `json:"groupReplicationConsistency,omitempty" tf:"group_replication_consistency,omitempty"`

	// ("information_schema_stats_expiry")
	InformationSchemaStatsExpiry *float64 `json:"informationSchemaStatsExpiry,omitempty" tf:"information_schema_stats_expiry,omitempty"`

	// Whether the InnoDB adaptive hash index is enabled or disabled. It may be desirable, depending on your workload, to dynamically enable or disable adaptive hash indexing to improve query performance. Because the adaptive hash index may not be useful for all workloads, conduct benchmarks with it both enabled and disabled, using realistic workloads.
	InnodbAdaptiveHashIndex *bool `json:"innodbAdaptiveHashIndex,omitempty" tf:"innodb_adaptive_hash_index,omitempty"`

	// The lock mode to use for generating auto-increment values. Permissible values are 0, 1, or 2, for traditional, consecutive, or interleaved, respectively.
	InnodbAutoincLockMode *float64 `json:"innodbAutoincLockMode,omitempty" tf:"innodb_autoinc_lock_mode,omitempty"`

	// Specifies the percentage of the most recently used pages for each buffer pool to read out and dump.
	InnodbBufferPoolDumpPct *float64 `json:"innodbBufferPoolDumpPct,omitempty" tf:"innodb_buffer_pool_dump_pct,omitempty"`

	// ("innodb_buffer_pool_instances")
	InnodbBufferPoolInstances *float64 `json:"innodbBufferPoolInstances,omitempty" tf:"innodb_buffer_pool_instances,omitempty"`

	// The size (in bytes) of the buffer pool, that is, the memory area where InnoDB caches table and index data.
	InnodbBufferPoolSize *string `json:"innodbBufferPoolSize,omitempty" tf:"innodb_buffer_pool_size,omitempty"`

	// Whether InnoDB performs change buffering, an optimization that delays write operations to secondary indexes so that the I/O operations can be performed sequentially. Permitted values are described in the following table. Values may also be specified numerically.
	InnodbChangeBuffering *string `json:"innodbChangeBuffering,omitempty" tf:"innodb_change_buffering,omitempty"`

	// innodbDdlBufferSize corresponds to the MySQL system variable [innodb_ddl_buffer_size] (https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_ddl_buffer_size)
	InnodbDdlBufferSize *string `json:"innodbDdlBufferSize,omitempty" tf:"innodb_ddl_buffer_size,omitempty"`

	// innodbDdlThreads corresponds to the MySQL system variable [innodb_ddl_threads] (https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_ddl_threads)
	InnodbDdlThreads *float64 `json:"innodbDdlThreads,omitempty" tf:"innodb_ddl_threads,omitempty"`

	// ("innodb_ft_enable_stopword")
	InnodbFtEnableStopword *bool `json:"innodbFtEnableStopword,omitempty" tf:"innodb_ft_enable_stopword,omitempty"`

	// ("innodb_ft_max_token_size")
	InnodbFtMaxTokenSize *float64 `json:"innodbFtMaxTokenSize,omitempty" tf:"innodb_ft_max_token_size,omitempty"`

	// ("innodb_ft_min_token_size")
	InnodbFtMinTokenSize *float64 `json:"innodbFtMinTokenSize,omitempty" tf:"innodb_ft_min_token_size,omitempty"`

	// ("innodb_ft_num_word_optimize")
	InnodbFtNumWordOptimize *float64 `json:"innodbFtNumWordOptimize,omitempty" tf:"innodb_ft_num_word_optimize,omitempty"`

	// ("innodb_ft_result_cache_limit")
	InnodbFtResultCacheLimit *string `json:"innodbFtResultCacheLimit,omitempty" tf:"innodb_ft_result_cache_limit,omitempty"`

	// ("innodb_ft_server_stopword_table")
	InnodbFtServerStopwordTable *string `json:"innodbFtServerStopwordTable,omitempty" tf:"innodb_ft_server_stopword_table,omitempty"`

	// ("innodb_lock_wait_timeout")
	InnodbLockWaitTimeout *float64 `json:"innodbLockWaitTimeout,omitempty" tf:"innodb_lock_wait_timeout,omitempty"`

	// Enables dedicated log writer threads for writing redo log records from the log buffer to the system buffers and flushing the system buffers to the redo log files.
	InnodbLogWriterThreads *bool `json:"innodbLogWriterThreads,omitempty" tf:"innodb_log_writer_threads,omitempty"`

	// The desired maximum purge lag in terms of transactions.
	InnodbMaxPurgeLag *string `json:"innodbMaxPurgeLag,omitempty" tf:"innodb_max_purge_lag,omitempty"`

	// The maximum delay in microseconds for the delay imposed when the innodb_max_purge_lag threshold is exceeded.
	InnodbMaxPurgeLagDelay *float64 `json:"innodbMaxPurgeLagDelay,omitempty" tf:"innodb_max_purge_lag_delay,omitempty"`

	// Enables the NUMA interleave memory policy for allocation of the InnoDB buffer pool. When innodb_numa_interleave is enabled, the NUMA memory policy is set to MPOL_INTERLEAVE for the mysqld process. After the InnoDB buffer pool is allocated, the NUMA memory policy is set back to MPOL_DEFAULT. For the innodb_numa_interleave option to be available, MySQL must be compiled on a NUMA-enabled Linux system.
	InnodbNumaInterleave *bool `json:"innodbNumaInterleave,omitempty" tf:"innodb_numa_interleave,omitempty"`

	// Specifies an upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables. There is one such log file for each index being created or table being altered. This log file stores data inserted, updated, or deleted in the table during the DDL operation.
	InnodbOnlineAlterLogMaxSize *string `json:"innodbOnlineAlterLogMaxSize,omitempty" tf:"innodb_online_alter_log_max_size,omitempty"`

	// Defines the amount of disk space occupied by redo log files. innodb_redo_log_capacity supercedes the innodb_log_files_in_group and innodb_log_file_size variables, which are both ignored if innodb_redo_log_capacity is defined. If innodb_redo_log_capacity is not defined, and if neither innodb_log_file_size or innodb_log_files_in_group are defined, then the default innodb_redo_log_capacity value is used.
	InnodbRedoLogCapacity *string `json:"innodbRedoLogCapacity,omitempty" tf:"innodb_redo_log_capacity,omitempty"`

	// InnoDB rolls back only the last statement on a transaction timeout by default. If --innodb-rollback-on-timeout is specified, a transaction timeout causes InnoDB to abort and roll back the entire transaction.
	InnodbRollbackOnTimeout *bool `json:"innodbRollbackOnTimeout,omitempty" tf:"innodb_rollback_on_timeout,omitempty"`

	// This variable defines:
	InnodbSortBufferSize *float64 `json:"innodbSortBufferSize,omitempty" tf:"innodb_sort_buffer_size,omitempty"`

	// The number of index pages to sample when estimating cardinality and other statistics for an indexed column, such as those calculated by ANALYZE TABLE.
	InnodbStatsPersistentSamplePages *string `json:"innodbStatsPersistentSamplePages,omitempty" tf:"innodb_stats_persistent_sample_pages,omitempty"`

	// The number of index pages to sample when estimating cardinality and other statistics for an indexed column, such as those calculated by ANALYZE TABLE.
	InnodbStatsTransientSamplePages *string `json:"innodbStatsTransientSamplePages,omitempty" tf:"innodb_stats_transient_sample_pages,omitempty"`

	// When you enable innodbStrictMode, the InnoDB storage engine returns errors instead of warnings for invalid or incompatible table options.
	InnodbStrictMode *bool `json:"innodbStrictMode,omitempty" tf:"innodb_strict_mode,omitempty"`

	// When enabled, undo tablespaces that exceed the threshold value defined by innodb_max_undo_log_size are marked for truncation. Only undo tablespaces can be truncated. Truncating undo logs that reside in the system tablespace is not supported. For truncation to occur, there must be at least two undo tablespaces.
	InnodbUndoLogTruncate *bool `json:"innodbUndoLogTruncate,omitempty" tf:"innodb_undo_log_truncate,omitempty"`

	// The number of seconds the server waits for activity on an interactive connection before closing it.
	InteractiveTimeout *float64 `json:"interactiveTimeout,omitempty" tf:"interactive_timeout,omitempty"`

	// The minimum size of the buffer that is used for plain index scans, range index scans, and joins that do not use indexes and thus perform full table scans. In MySQL 8.0.18 and later, this variable also controls the amount of memory used for hash joins. Normally, the best way to get fast joins is to add indexes. Increase the value of join_buffer_size to get a faster full join when adding indexes is not possible. One join buffer is allocated for each full join between two tables. For a complex join between several tables for which indexes are not used, multiple join buffers might be necessary.
	JoinBufferSize *string `json:"joinBufferSize,omitempty" tf:"join_buffer_size,omitempty"`

	// This variable controls server-side LOCAL capability for LOAD DATA statements. Depending on the local_infile setting, the server refuses or permits local data loading by clients that have LOCAL enabled on the client side.
	LocalInfile *bool `json:"localInfile,omitempty" tf:"local_infile,omitempty"`

	// If a query takes longer than this many seconds, the server increments the Slow_queries status variable. If the slow query log is enabled, the query is logged to the slow query log file. This value is measured in real time, not CPU time, so a query that is under the threshold on a lightly loaded system might be above the threshold on a heavily loaded one.
	LongQueryTime *float64 `json:"longQueryTime,omitempty" tf:"long_query_time,omitempty"`

	// ("mandatory_roles")
	MandatoryRoles *string `json:"mandatoryRoles,omitempty" tf:"mandatory_roles,omitempty"`

	// The maximum size of one packet or any generated/intermediate string.
	MaxAllowedPacket *float64 `json:"maxAllowedPacket,omitempty" tf:"max_allowed_packet,omitempty"`

	// Sets the size of the transaction cache.
	MaxBinlogCacheSize *string `json:"maxBinlogCacheSize,omitempty" tf:"max_binlog_cache_size,omitempty"`

	// ("max_connect_errors")
	MaxConnectErrors *string `json:"maxConnectErrors,omitempty" tf:"max_connect_errors,omitempty"`

	// ("max_connections")
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// ("max_execution_time")
	MaxExecutionTime *string `json:"maxExecutionTime,omitempty" tf:"max_execution_time,omitempty"`

	// This variable sets the maximum size to which user-created MEMORY tables are permitted to grow.
	MaxHeapTableSize *string `json:"maxHeapTableSize,omitempty" tf:"max_heap_table_size,omitempty"`

	// ("max_prepared_stmt_count")
	MaxPreparedStmtCount *float64 `json:"maxPreparedStmtCount,omitempty" tf:"max_prepared_stmt_count,omitempty"`

	// Limit the assumed maximum number of seeks when looking up rows based on a key. The MySQL optimizer assumes that no more than this number of key seeks are required when searching for matching rows in a table by scanning an index, regardless of the actual cardinality of the index (see Section 15.7.7.22, “SHOW INDEX Statement”). By setting this to a low value (say, 100), you can force MySQL to prefer indexes instead of table scans.
	MaxSeeksForKey *string `json:"maxSeeksForKey,omitempty" tf:"max_seeks_for_key,omitempty"`

	// The maximum number of simultaneous connections permitted to any given MySQL user account. A value of 0 (the default) means “no limit.” This variable has a global value that can be set at server startup or runtime. It also has a read-only session value that indicates the effective simultaneous-connection limit that applies to the account associated with the current session.
	MaxUserConnections *string `json:"maxUserConnections,omitempty" tf:"max_user_connections,omitempty"`

	// ("mysql_firewall_mode")
	MySQLFirewallMode *bool `json:"mysqlFirewallMode,omitempty" tf:"mysql_firewall_mode,omitempty"`

	// DEPRECATED -- typo of mysqlx_zstd_default_compression_level. variable will be ignored.
	MySQLZstdDefaultCompressionLevel *float64 `json:"mysqlZstdDefaultCompressionLevel,omitempty" tf:"mysql_zstd_default_compression_level,omitempty"`

	// The number of seconds X Plugin waits for the first packet to be received from newly connected clients.
	MysqlxConnectTimeout *float64 `json:"mysqlxConnectTimeout,omitempty" tf:"mysqlx_connect_timeout,omitempty"`

	// Set the default compression level for the deflate algorithm. ("mysqlx_deflate_default_compression_level")
	MysqlxDeflateDefaultCompressionLevel *float64 `json:"mysqlxDeflateDefaultCompressionLevel,omitempty" tf:"mysqlx_deflate_default_compression_level,omitempty"`

	// Limit the upper bound of accepted compression levels for the deflate algorithm. ("mysqlx_deflate_max_client_compression_level")
	MysqlxDeflateMaxClientCompressionLevel *float64 `json:"mysqlxDeflateMaxClientCompressionLevel,omitempty" tf:"mysqlx_deflate_max_client_compression_level,omitempty"`

	// ("mysqlx_document_id_unique_prefix") DEPRECATED -- variable should not be settable and will be ignored
	MysqlxDocumentIDUniquePrefix *float64 `json:"mysqlxDocumentIdUniquePrefix,omitempty" tf:"mysqlx_document_id_unique_prefix,omitempty"`

	// ("mysqlx_enable_hello_notice") DEPRECATED -- variable should not be settable and will be ignored
	MysqlxEnableHelloNotice *bool `json:"mysqlxEnableHelloNotice,omitempty" tf:"mysqlx_enable_hello_notice,omitempty"`

	// ("mysqlx_idle_worker_thread_timeout") DEPRECATED -- variable should not be settable and will be ignored
	MysqlxIdleWorkerThreadTimeout *float64 `json:"mysqlxIdleWorkerThreadTimeout,omitempty" tf:"mysqlx_idle_worker_thread_timeout,omitempty"`

	// The number of seconds to wait for interactive clients to timeout.
	MysqlxInteractiveTimeout *float64 `json:"mysqlxInteractiveTimeout,omitempty" tf:"mysqlx_interactive_timeout,omitempty"`

	// Set the default compression level for the lz4 algorithm. ("mysqlx_lz4_default_compression_level")
	MysqlxLz4DefaultCompressionLevel *float64 `json:"mysqlxLz4DefaultCompressionLevel,omitempty" tf:"mysqlx_lz4default_compression_level,omitempty"`

	// Limit the upper bound of accepted compression levels for the lz4 algorithm. ("mysqlx_lz4_max_client_compression_level")
	MysqlxLz4MaxClientCompressionLevel *float64 `json:"mysqlxLz4MaxClientCompressionLevel,omitempty" tf:"mysqlx_lz4max_client_compression_level,omitempty"`

	// The maximum size of network packets that can be received by X Plugin.
	MysqlxMaxAllowedPacket *float64 `json:"mysqlxMaxAllowedPacket,omitempty" tf:"mysqlx_max_allowed_packet,omitempty"`

	// ("mysqlx_min_worker_threads") DEPRECATED -- variable should not be settable and will be ignored
	MysqlxMinWorkerThreads *float64 `json:"mysqlxMinWorkerThreads,omitempty" tf:"mysqlx_min_worker_threads,omitempty"`

	// The number of seconds that X Plugin waits for blocking read operations to complete. After this time, if the read operation is not successful, X Plugin closes the connection and returns a warning notice with the error code ER_IO_READ_ERROR to the client application.
	MysqlxReadTimeout *float64 `json:"mysqlxReadTimeout,omitempty" tf:"mysqlx_read_timeout,omitempty"`

	// The number of seconds that X Plugin waits for activity on a connection.
	MysqlxWaitTimeout *float64 `json:"mysqlxWaitTimeout,omitempty" tf:"mysqlx_wait_timeout,omitempty"`

	// The number of seconds that X Plugin waits for blocking write operations to complete. After this time, if the write operation is not successful, X Plugin closes the connection.
	MysqlxWriteTimeout *float64 `json:"mysqlxWriteTimeout,omitempty" tf:"mysqlx_write_timeout,omitempty"`

	// Set the default compression level for the zstd algorithm. ("mysqlx_zstd_default_compression_level")
	MysqlxZstdDefaultCompressionLevel *float64 `json:"mysqlxZstdDefaultCompressionLevel,omitempty" tf:"mysqlx_zstd_default_compression_level,omitempty"`

	// Limit the upper bound of accepted compression levels for the zstd algorithm. ("mysqlx_zstd_max_client_compression_level")
	MysqlxZstdMaxClientCompressionLevel *float64 `json:"mysqlxZstdMaxClientCompressionLevel,omitempty" tf:"mysqlx_zstd_max_client_compression_level,omitempty"`

	// The number of seconds to wait for more data from a connection before aborting the read.
	NetReadTimeout *float64 `json:"netReadTimeout,omitempty" tf:"net_read_timeout,omitempty"`

	// The number of seconds to wait for a block to be written to a connection before aborting the write.
	NetWriteTimeout *float64 `json:"netWriteTimeout,omitempty" tf:"net_write_timeout,omitempty"`

	// The optimizer_switch system variable enables control over optimizer behavior. The value of this variable is a set of flags, each of which has a value of on or off to indicate whether the corresponding optimizer behavior is enabled or disabled. This variable has global and session values and can be changed at runtime. The global default can be set at server startup.
	OptimizerSwitch *string `json:"optimizerSwitch,omitempty" tf:"optimizer_switch,omitempty"`

	// ("parser_max_mem_size")
	ParserMaxMemSize *string `json:"parserMaxMemSize,omitempty" tf:"parser_max_mem_size,omitempty"`

	// ("query_alloc_block_size") DEPRECATED -- variable should not be settable and will be ignored
	QueryAllocBlockSize *string `json:"queryAllocBlockSize,omitempty" tf:"query_alloc_block_size,omitempty"`

	// ("query_prealloc_size") DEPRECATED -- variable should not be settable and will be ignored
	QueryPreallocSize *string `json:"queryPreallocSize,omitempty" tf:"query_prealloc_size,omitempty"`

	// The limit on memory consumption for the range optimizer. A value of 0 means “no limit.” If an execution plan considered by the optimizer uses the range access method but the optimizer estimates that the amount of memory needed for this method would exceed the limit, it abandons the plan and considers other plans.
	RangeOptimizerMaxMemSize *string `json:"rangeOptimizerMaxMemSize,omitempty" tf:"range_optimizer_max_mem_size,omitempty"`

	// regexpTimeLimit corresponds to the MySQL system variable [regexp_time_limit] (https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_regexp_time_limit)
	RegexpTimeLimit *float64 `json:"regexpTimeLimit,omitempty" tf:"regexp_time_limit,omitempty"`

	// The maximum amount of space to use for all relay logs.
	RelayLogSpaceLimit *string `json:"relayLogSpaceLimit,omitempty" tf:"relay_log_space_limit,omitempty"`

	// Specifies the number of seconds to wait for more data or a heartbeat signal from the source before the replica considers the connection broken, aborts the read, and tries to reconnect. Setting this variable has no immediate effect. The state of the variable applies on all subsequent START REPLICA commands.
	ReplicaNetTimeout *float64 `json:"replicaNetTimeout,omitempty" tf:"replica_net_timeout,omitempty"`

	// Beginning with MySQL 8.0.26, slave_parallel_workers is deprecated, and you should use replica_parallel_workers instead. (Prior to MySQL 8.0.26, you must use slave_parallel_workers to set the number of applier threads.)
	ReplicaParallelWorkers *float64 `json:"replicaParallelWorkers,omitempty" tf:"replica_parallel_workers,omitempty"`

	// From MySQL 8.0.26, use replica_type_conversions in place of slave_type_conversions, which is deprecated from that release. In releases before MySQL 8.0.26, use slave_type_conversions.
	ReplicaTypeConversions *string `json:"replicaTypeConversions,omitempty" tf:"replica_type_conversions,omitempty"`

	// Whether client connections to the server are required to use some form of secure transport. When this variable is enabled, the server permits only TCP/IP connections encrypted using TLS/SSL, or connections that use a socket file or shared memory. The server rejects nonsecure connection attempts, which fail with an ER_SECURE_TRANSPORT_REQUIRED error.
	RequireSecureTransport *bool `json:"requireSecureTransport,omitempty" tf:"require_secure_transport,omitempty"`

	// Whether GIPK mode is in effect, in which case a MySQL replication source server adds a generated invisible primary key to any InnoDB table that is created without one.
	SQLGenerateInvisiblePrimaryKey *bool `json:"sqlGenerateInvisiblePrimaryKey,omitempty" tf:"sql_generate_invisible_primary_key,omitempty"`

	// ("sql_mode")
	SQLMode *string `json:"sqlMode,omitempty" tf:"sql_mode,omitempty"`

	// ("sql_require_primary_key")
	SQLRequirePrimaryKey *bool `json:"sqlRequirePrimaryKey,omitempty" tf:"sql_require_primary_key,omitempty"`

	// ("sql_warnings")
	SQLWarnings *bool `json:"sqlWarnings,omitempty" tf:"sql_warnings,omitempty"`

	// Whether to resolve host names when checking client connections. If this variable is OFF, mysqld resolves host names when checking client connections. If it is ON, mysqld uses only IP numbers; in this case, all Host column values in the grant tables must be IP addresses. See Section 7.1.12.3, “DNS Lookups and the Host Cache”.
	SkipNameResolve *bool `json:"skipNameResolve,omitempty" tf:"skip_name_resolve,omitempty"`

	// Each session that must perform a sort allocates a buffer of this size.
	SortBufferSize *string `json:"sortBufferSize,omitempty" tf:"sort_buffer_size,omitempty"`

	// The number of table definitions that can be stored in the table definition cache. If you use a large number of tables, you can create a large table definition cache to speed up opening of tables. The table definition cache takes less space and does not use file descriptors, unlike the normal table cache.
	TableDefinitionCache *float64 `json:"tableDefinitionCache,omitempty" tf:"table_definition_cache,omitempty"`

	// The number of open tables for all threads. Increasing this value increases the number of file descriptors that mysqld requires.
	TableOpenCache *float64 `json:"tableOpenCache,omitempty" tf:"table_open_cache,omitempty"`

	// Defines the maximum amount of memory that can be occupied by the TempTable storage engine before it starts storing data on disk. The default value is 1073741824 bytes (1GiB). For more information, see Section 10.4.4, “Internal Temporary Table Use in MySQL”.
	TemptableMaxRAM *string `json:"temptableMaxRam,omitempty" tf:"temptable_max_ram,omitempty"`

	// Controls whether the thread pool uses dedicated listener threads. If enabled, a listener thread in each thread group is dedicated to the task of listening for network events from clients, ensuring that the maximum number of query worker threads is no more than the value specified by threadPoolMaxTransactionsLimit. threadPoolDedicatedListeners corresponds to the MySQL Database Service-specific system variable thread_pool_dedicated_listeners.
	ThreadPoolDedicatedListeners *bool `json:"threadPoolDedicatedListeners,omitempty" tf:"thread_pool_dedicated_listeners,omitempty"`

	// Limits the maximum number of open transactions to the defined value. The default value is 0, which enforces no limit. threadPoolMaxTransactionsLimit corresponds to the MySQL Database Service-specific system variable thread_pool_max_transactions_limit.
	ThreadPoolMaxTransactionsLimit *float64 `json:"threadPoolMaxTransactionsLimit,omitempty" tf:"thread_pool_max_transactions_limit,omitempty"`

	// The maximum number of query threads permitted in a thread group. The maximum value is 4096, but if thread_pool_max_transactions_limit is set, thread_pool_query_threads_per_group must not exceed that value. The default value of 1 means there is one active query thread in each thread group, which works well for many loads. When you are using the high concurrency thread pool algorithm (thread_pool_algorithm = 1), consider increasing the value if you experience slower response times due to long-running transactions.
	ThreadPoolQueryThreadsPerGroup *float64 `json:"threadPoolQueryThreadsPerGroup,omitempty" tf:"thread_pool_query_threads_per_group,omitempty"`

	// The number of thread groups in the thread pool. This is the most important parameter controlling thread pool performance. It affects how many statements can execute simultaneously. If a value outside the range of permissible values is specified, the thread pool plugin does not load and the server writes a message to the error log.
	ThreadPoolSize *float64 `json:"threadPoolSize,omitempty" tf:"thread_pool_size,omitempty"`

	// The delay period before executing a new transaction, in milliseconds. The maximum value is 300000 (5 minutes). A transaction delay can be used in cases where parallel transactions affect the performance of other operations due to resource contention. For example, if parallel transactions affect index creation or an online buffer pool resizing operation, you can configure a transaction delay to reduce resource contention while those operations are running.
	ThreadPoolTransactionDelay *float64 `json:"threadPoolTransactionDelay,omitempty" tf:"thread_pool_transaction_delay,omitempty"`

	// Initializes the time zone for each client that connects.
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`

	// The maximum size of internal in-memory temporary tables. This variable does not apply to user-created MEMORY tables.
	TmpTableSize *string `json:"tmpTableSize,omitempty" tf:"tmp_table_size,omitempty"`

	// ("transaction_isolation")
	TransactionIsolation *string `json:"transactionIsolation,omitempty" tf:"transaction_isolation,omitempty"`

	// The number of seconds the server waits for activity on a noninteractive connection before closing it.
	WaitTimeout *float64 `json:"waitTimeout,omitempty" tf:"wait_timeout,omitempty"`
}

type VariablesObservation struct {

	// auto_increment_increment and auto_increment_offset are intended for use with circular (source-to-source) replication, and can be used to control the operation of AUTO_INCREMENT columns. Both variables have global and session values, and each can assume an integer value between 1 and 65,535 inclusive.
	AutoIncrementIncrement *float64 `json:"autoIncrementIncrement,omitempty" tf:"auto_increment_increment,omitempty"`

	// This variable has a default value of 1. If it is left with its default value, and Group Replication is started on the server in multi-primary mode, it is changed to the server ID.
	AutoIncrementOffset *float64 `json:"autoIncrementOffset,omitempty" tf:"auto_increment_offset,omitempty"`

	// ("autocommit")
	Autocommit *bool `json:"autocommit,omitempty" tf:"autocommit,omitempty"`

	// If enabled, the server stores all temporary tables on disk rather than in memory.
	BigTables *bool `json:"bigTables,omitempty" tf:"big_tables,omitempty"`

	// Sets the binary log expiration period in seconds. binlogExpireLogsSeconds corresponds to the MySQL binary logging system variable binlog_expire_logs_seconds.
	BinlogExpireLogsSeconds *float64 `json:"binlogExpireLogsSeconds,omitempty" tf:"binlog_expire_logs_seconds,omitempty"`

	// Controls how many microseconds the binary log commit waits before synchronizing the binary log file to disk. There is no delay by default. Setting this variable to a microsecond delay enables more transactions to be synchronized together to disk at once, reducing the overall time to commit a group of transactions because the larger groups required fewer time units per group.
	BinlogGroupCommitSyncDelay *float64 `json:"binlogGroupCommitSyncDelay,omitempty" tf:"binlog_group_commit_sync_delay,omitempty"`

	// The maximum number of transactions to wait for before aborting the current delay as specified by binlog_group_commit_sync_delay. If binlog_group_commit_sync_delay is set to 0, then this option has no effect.
	BinlogGroupCommitSyncNoDelayCount *float64 `json:"binlogGroupCommitSyncNoDelayCount,omitempty" tf:"binlog_group_commit_sync_no_delay_count,omitempty"`

	// Configures the amount of table metadata added to the binary log when using row-based logging. binlogRowMetadata corresponds to the MySQL binary logging system variable binlog_row_metadata.
	BinlogRowMetadata *string `json:"binlogRowMetadata,omitempty" tf:"binlog_row_metadata,omitempty"`

	// When set to PARTIAL_JSON, this enables use of a space-efficient binary log format for updates that modify only a small portion of a JSON document. binlogRowValueOptions corresponds to the MySQL binary logging system variable binlog_row_value_options.
	BinlogRowValueOptions *string `json:"binlogRowValueOptions,omitempty" tf:"binlog_row_value_options,omitempty"`

	// Enables compression for transactions that are written to binary log files on this server. binlogTransactionCompression corresponds to the MySQL binary logging system variable binlog_transaction_compression.
	BinlogTransactionCompression *bool `json:"binlogTransactionCompression,omitempty" tf:"binlog_transaction_compression,omitempty"`

	// This variable controls the block encryption mode for block-based algorithms such as AES. It affects encryption for AES_ENCRYPT() and AES_DECRYPT(). block_encryption_mode takes a value in aes-keylen-mode format, where keylen is the key length in bits and mode is the encryption mode. The value is not case-sensitive. Permitted keylen values are 128, 192, and 256. Permitted mode values are ECB, CBC, CFB1, CFB8, CFB128, and OFB.
	BlockEncryptionMode *string `json:"blockEncryptionMode,omitempty" tf:"block_encryption_mode,omitempty"`

	// The server's default character set. If you set this variable, you should also set collation_server to specify the collation for the character set.
	CharacterSetServer *string `json:"characterSetServer,omitempty" tf:"character_set_server,omitempty"`

	// The server's default collation.
	CollationServer *string `json:"collationServer,omitempty" tf:"collation_server,omitempty"`

	// ("completion_type")
	CompletionType *string `json:"completionType,omitempty" tf:"completion_type,omitempty"`

	// The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
	ConnectTimeout *float64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Set the chunking size for updates to the global memory usage counter Global_connection_memory.
	ConnectionMemoryChunkSize *float64 `json:"connectionMemoryChunkSize,omitempty" tf:"connection_memory_chunk_size,omitempty"`

	// Set the maximum amount of memory that can be used by a single user connection.
	ConnectionMemoryLimit *string `json:"connectionMemoryLimit,omitempty" tf:"connection_memory_limit,omitempty"`

	// ("cte_max_recursion_depth")
	CteMaxRecursionDepth *string `json:"cteMaxRecursionDepth,omitempty" tf:"cte_max_recursion_depth,omitempty"`

	// The default authentication plugin. This must be a plugin that uses internal credentials storage, so these values are permitted: mysql_native_password, sha256_password, caching_sha2_password.
	DefaultAuthenticationPlugin *string `json:"defaultAuthenticationPlugin,omitempty" tf:"default_authentication_plugin,omitempty"`

	// This variable determines the default output format used by EXPLAIN in the absence of a FORMAT option when displaying a query execution plan.
	ExplainFormat *string `json:"explainFormat,omitempty" tf:"explain_format,omitempty"`

	// This system variable determines whether the server enables certain nonstandard behaviors for default values and NULL-value handling in TIMESTAMP columns. By default, explicit_defaults_for_timestamp is enabled, which disables the nonstandard behaviors. Disabling explicit_defaults_for_timestamp results in a warning.
	ExplicitDefaultsForTimestamp *bool `json:"explicitDefaultsForTimestamp,omitempty" tf:"explicit_defaults_for_timestamp,omitempty"`

	// ("foreign_key_checks")
	ForeignKeyChecks *bool `json:"foreignKeyChecks,omitempty" tf:"foreign_key_checks,omitempty"`

	// ("generated_random_password_length") DEPRECATED -- variable should not be settable and will be ignored
	GeneratedRandomPasswordLength *float64 `json:"generatedRandomPasswordLength,omitempty" tf:"generated_random_password_length,omitempty"`

	// Set the total amount of memory that can be used by all user connections.
	GlobalConnectionMemoryLimit *string `json:"globalConnectionMemoryLimit,omitempty" tf:"global_connection_memory_limit,omitempty"`

	// Determines whether the MySQL server calculates Global_connection_memory.
	GlobalConnectionMemoryTracking *bool `json:"globalConnectionMemoryTracking,omitempty" tf:"global_connection_memory_tracking,omitempty"`

	// Specifies the maximum permitted result length in bytes for the GROUP_CONCAT() function.
	GroupConcatMaxLen *string `json:"groupConcatMaxLen,omitempty" tf:"group_concat_max_len,omitempty"`

	GroupReplicationConsistency *string `json:"groupReplicationConsistency,omitempty" tf:"group_replication_consistency,omitempty"`

	// ("information_schema_stats_expiry")
	InformationSchemaStatsExpiry *float64 `json:"informationSchemaStatsExpiry,omitempty" tf:"information_schema_stats_expiry,omitempty"`

	// Whether the InnoDB adaptive hash index is enabled or disabled. It may be desirable, depending on your workload, to dynamically enable or disable adaptive hash indexing to improve query performance. Because the adaptive hash index may not be useful for all workloads, conduct benchmarks with it both enabled and disabled, using realistic workloads.
	InnodbAdaptiveHashIndex *bool `json:"innodbAdaptiveHashIndex,omitempty" tf:"innodb_adaptive_hash_index,omitempty"`

	// The lock mode to use for generating auto-increment values. Permissible values are 0, 1, or 2, for traditional, consecutive, or interleaved, respectively.
	InnodbAutoincLockMode *float64 `json:"innodbAutoincLockMode,omitempty" tf:"innodb_autoinc_lock_mode,omitempty"`

	// Specifies the percentage of the most recently used pages for each buffer pool to read out and dump.
	InnodbBufferPoolDumpPct *float64 `json:"innodbBufferPoolDumpPct,omitempty" tf:"innodb_buffer_pool_dump_pct,omitempty"`

	// ("innodb_buffer_pool_instances")
	InnodbBufferPoolInstances *float64 `json:"innodbBufferPoolInstances,omitempty" tf:"innodb_buffer_pool_instances,omitempty"`

	// The size (in bytes) of the buffer pool, that is, the memory area where InnoDB caches table and index data.
	InnodbBufferPoolSize *string `json:"innodbBufferPoolSize,omitempty" tf:"innodb_buffer_pool_size,omitempty"`

	// Whether InnoDB performs change buffering, an optimization that delays write operations to secondary indexes so that the I/O operations can be performed sequentially. Permitted values are described in the following table. Values may also be specified numerically.
	InnodbChangeBuffering *string `json:"innodbChangeBuffering,omitempty" tf:"innodb_change_buffering,omitempty"`

	// innodbDdlBufferSize corresponds to the MySQL system variable [innodb_ddl_buffer_size] (https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_ddl_buffer_size)
	InnodbDdlBufferSize *string `json:"innodbDdlBufferSize,omitempty" tf:"innodb_ddl_buffer_size,omitempty"`

	// innodbDdlThreads corresponds to the MySQL system variable [innodb_ddl_threads] (https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_ddl_threads)
	InnodbDdlThreads *float64 `json:"innodbDdlThreads,omitempty" tf:"innodb_ddl_threads,omitempty"`

	// ("innodb_ft_enable_stopword")
	InnodbFtEnableStopword *bool `json:"innodbFtEnableStopword,omitempty" tf:"innodb_ft_enable_stopword,omitempty"`

	// ("innodb_ft_max_token_size")
	InnodbFtMaxTokenSize *float64 `json:"innodbFtMaxTokenSize,omitempty" tf:"innodb_ft_max_token_size,omitempty"`

	// ("innodb_ft_min_token_size")
	InnodbFtMinTokenSize *float64 `json:"innodbFtMinTokenSize,omitempty" tf:"innodb_ft_min_token_size,omitempty"`

	// ("innodb_ft_num_word_optimize")
	InnodbFtNumWordOptimize *float64 `json:"innodbFtNumWordOptimize,omitempty" tf:"innodb_ft_num_word_optimize,omitempty"`

	// ("innodb_ft_result_cache_limit")
	InnodbFtResultCacheLimit *string `json:"innodbFtResultCacheLimit,omitempty" tf:"innodb_ft_result_cache_limit,omitempty"`

	// ("innodb_ft_server_stopword_table")
	InnodbFtServerStopwordTable *string `json:"innodbFtServerStopwordTable,omitempty" tf:"innodb_ft_server_stopword_table,omitempty"`

	// ("innodb_lock_wait_timeout")
	InnodbLockWaitTimeout *float64 `json:"innodbLockWaitTimeout,omitempty" tf:"innodb_lock_wait_timeout,omitempty"`

	// Enables dedicated log writer threads for writing redo log records from the log buffer to the system buffers and flushing the system buffers to the redo log files.
	InnodbLogWriterThreads *bool `json:"innodbLogWriterThreads,omitempty" tf:"innodb_log_writer_threads,omitempty"`

	// The desired maximum purge lag in terms of transactions.
	InnodbMaxPurgeLag *string `json:"innodbMaxPurgeLag,omitempty" tf:"innodb_max_purge_lag,omitempty"`

	// The maximum delay in microseconds for the delay imposed when the innodb_max_purge_lag threshold is exceeded.
	InnodbMaxPurgeLagDelay *float64 `json:"innodbMaxPurgeLagDelay,omitempty" tf:"innodb_max_purge_lag_delay,omitempty"`

	// Enables the NUMA interleave memory policy for allocation of the InnoDB buffer pool. When innodb_numa_interleave is enabled, the NUMA memory policy is set to MPOL_INTERLEAVE for the mysqld process. After the InnoDB buffer pool is allocated, the NUMA memory policy is set back to MPOL_DEFAULT. For the innodb_numa_interleave option to be available, MySQL must be compiled on a NUMA-enabled Linux system.
	InnodbNumaInterleave *bool `json:"innodbNumaInterleave,omitempty" tf:"innodb_numa_interleave,omitempty"`

	// Specifies an upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables. There is one such log file for each index being created or table being altered. This log file stores data inserted, updated, or deleted in the table during the DDL operation.
	InnodbOnlineAlterLogMaxSize *string `json:"innodbOnlineAlterLogMaxSize,omitempty" tf:"innodb_online_alter_log_max_size,omitempty"`

	// Defines the amount of disk space occupied by redo log files. innodb_redo_log_capacity supercedes the innodb_log_files_in_group and innodb_log_file_size variables, which are both ignored if innodb_redo_log_capacity is defined. If innodb_redo_log_capacity is not defined, and if neither innodb_log_file_size or innodb_log_files_in_group are defined, then the default innodb_redo_log_capacity value is used.
	InnodbRedoLogCapacity *string `json:"innodbRedoLogCapacity,omitempty" tf:"innodb_redo_log_capacity,omitempty"`

	// InnoDB rolls back only the last statement on a transaction timeout by default. If --innodb-rollback-on-timeout is specified, a transaction timeout causes InnoDB to abort and roll back the entire transaction.
	InnodbRollbackOnTimeout *bool `json:"innodbRollbackOnTimeout,omitempty" tf:"innodb_rollback_on_timeout,omitempty"`

	// This variable defines:
	InnodbSortBufferSize *float64 `json:"innodbSortBufferSize,omitempty" tf:"innodb_sort_buffer_size,omitempty"`

	// The number of index pages to sample when estimating cardinality and other statistics for an indexed column, such as those calculated by ANALYZE TABLE.
	InnodbStatsPersistentSamplePages *string `json:"innodbStatsPersistentSamplePages,omitempty" tf:"innodb_stats_persistent_sample_pages,omitempty"`

	// The number of index pages to sample when estimating cardinality and other statistics for an indexed column, such as those calculated by ANALYZE TABLE.
	InnodbStatsTransientSamplePages *string `json:"innodbStatsTransientSamplePages,omitempty" tf:"innodb_stats_transient_sample_pages,omitempty"`

	// When you enable innodbStrictMode, the InnoDB storage engine returns errors instead of warnings for invalid or incompatible table options.
	InnodbStrictMode *bool `json:"innodbStrictMode,omitempty" tf:"innodb_strict_mode,omitempty"`

	// When enabled, undo tablespaces that exceed the threshold value defined by innodb_max_undo_log_size are marked for truncation. Only undo tablespaces can be truncated. Truncating undo logs that reside in the system tablespace is not supported. For truncation to occur, there must be at least two undo tablespaces.
	InnodbUndoLogTruncate *bool `json:"innodbUndoLogTruncate,omitempty" tf:"innodb_undo_log_truncate,omitempty"`

	// The number of seconds the server waits for activity on an interactive connection before closing it.
	InteractiveTimeout *float64 `json:"interactiveTimeout,omitempty" tf:"interactive_timeout,omitempty"`

	// The minimum size of the buffer that is used for plain index scans, range index scans, and joins that do not use indexes and thus perform full table scans. In MySQL 8.0.18 and later, this variable also controls the amount of memory used for hash joins. Normally, the best way to get fast joins is to add indexes. Increase the value of join_buffer_size to get a faster full join when adding indexes is not possible. One join buffer is allocated for each full join between two tables. For a complex join between several tables for which indexes are not used, multiple join buffers might be necessary.
	JoinBufferSize *string `json:"joinBufferSize,omitempty" tf:"join_buffer_size,omitempty"`

	// This variable controls server-side LOCAL capability for LOAD DATA statements. Depending on the local_infile setting, the server refuses or permits local data loading by clients that have LOCAL enabled on the client side.
	LocalInfile *bool `json:"localInfile,omitempty" tf:"local_infile,omitempty"`

	// If a query takes longer than this many seconds, the server increments the Slow_queries status variable. If the slow query log is enabled, the query is logged to the slow query log file. This value is measured in real time, not CPU time, so a query that is under the threshold on a lightly loaded system might be above the threshold on a heavily loaded one.
	LongQueryTime *float64 `json:"longQueryTime,omitempty" tf:"long_query_time,omitempty"`

	// ("mandatory_roles")
	MandatoryRoles *string `json:"mandatoryRoles,omitempty" tf:"mandatory_roles,omitempty"`

	// The maximum size of one packet or any generated/intermediate string.
	MaxAllowedPacket *float64 `json:"maxAllowedPacket,omitempty" tf:"max_allowed_packet,omitempty"`

	// Sets the size of the transaction cache.
	MaxBinlogCacheSize *string `json:"maxBinlogCacheSize,omitempty" tf:"max_binlog_cache_size,omitempty"`

	// ("max_connect_errors")
	MaxConnectErrors *string `json:"maxConnectErrors,omitempty" tf:"max_connect_errors,omitempty"`

	// ("max_connections")
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// ("max_execution_time")
	MaxExecutionTime *string `json:"maxExecutionTime,omitempty" tf:"max_execution_time,omitempty"`

	// This variable sets the maximum size to which user-created MEMORY tables are permitted to grow.
	MaxHeapTableSize *string `json:"maxHeapTableSize,omitempty" tf:"max_heap_table_size,omitempty"`

	// ("max_prepared_stmt_count")
	MaxPreparedStmtCount *float64 `json:"maxPreparedStmtCount,omitempty" tf:"max_prepared_stmt_count,omitempty"`

	// Limit the assumed maximum number of seeks when looking up rows based on a key. The MySQL optimizer assumes that no more than this number of key seeks are required when searching for matching rows in a table by scanning an index, regardless of the actual cardinality of the index (see Section 15.7.7.22, “SHOW INDEX Statement”). By setting this to a low value (say, 100), you can force MySQL to prefer indexes instead of table scans.
	MaxSeeksForKey *string `json:"maxSeeksForKey,omitempty" tf:"max_seeks_for_key,omitempty"`

	// The maximum number of simultaneous connections permitted to any given MySQL user account. A value of 0 (the default) means “no limit.” This variable has a global value that can be set at server startup or runtime. It also has a read-only session value that indicates the effective simultaneous-connection limit that applies to the account associated with the current session.
	MaxUserConnections *string `json:"maxUserConnections,omitempty" tf:"max_user_connections,omitempty"`

	// ("mysql_firewall_mode")
	MySQLFirewallMode *bool `json:"mysqlFirewallMode,omitempty" tf:"mysql_firewall_mode,omitempty"`

	// DEPRECATED -- typo of mysqlx_zstd_default_compression_level. variable will be ignored.
	MySQLZstdDefaultCompressionLevel *float64 `json:"mysqlZstdDefaultCompressionLevel,omitempty" tf:"mysql_zstd_default_compression_level,omitempty"`

	// The number of seconds X Plugin waits for the first packet to be received from newly connected clients.
	MysqlxConnectTimeout *float64 `json:"mysqlxConnectTimeout,omitempty" tf:"mysqlx_connect_timeout,omitempty"`

	// Set the default compression level for the deflate algorithm. ("mysqlx_deflate_default_compression_level")
	MysqlxDeflateDefaultCompressionLevel *float64 `json:"mysqlxDeflateDefaultCompressionLevel,omitempty" tf:"mysqlx_deflate_default_compression_level,omitempty"`

	// Limit the upper bound of accepted compression levels for the deflate algorithm. ("mysqlx_deflate_max_client_compression_level")
	MysqlxDeflateMaxClientCompressionLevel *float64 `json:"mysqlxDeflateMaxClientCompressionLevel,omitempty" tf:"mysqlx_deflate_max_client_compression_level,omitempty"`

	// ("mysqlx_document_id_unique_prefix") DEPRECATED -- variable should not be settable and will be ignored
	MysqlxDocumentIDUniquePrefix *float64 `json:"mysqlxDocumentIdUniquePrefix,omitempty" tf:"mysqlx_document_id_unique_prefix,omitempty"`

	// ("mysqlx_enable_hello_notice") DEPRECATED -- variable should not be settable and will be ignored
	MysqlxEnableHelloNotice *bool `json:"mysqlxEnableHelloNotice,omitempty" tf:"mysqlx_enable_hello_notice,omitempty"`

	// ("mysqlx_idle_worker_thread_timeout") DEPRECATED -- variable should not be settable and will be ignored
	MysqlxIdleWorkerThreadTimeout *float64 `json:"mysqlxIdleWorkerThreadTimeout,omitempty" tf:"mysqlx_idle_worker_thread_timeout,omitempty"`

	// The number of seconds to wait for interactive clients to timeout.
	MysqlxInteractiveTimeout *float64 `json:"mysqlxInteractiveTimeout,omitempty" tf:"mysqlx_interactive_timeout,omitempty"`

	// Set the default compression level for the lz4 algorithm. ("mysqlx_lz4_default_compression_level")
	MysqlxLz4DefaultCompressionLevel *float64 `json:"mysqlxLz4DefaultCompressionLevel,omitempty" tf:"mysqlx_lz4default_compression_level,omitempty"`

	// Limit the upper bound of accepted compression levels for the lz4 algorithm. ("mysqlx_lz4_max_client_compression_level")
	MysqlxLz4MaxClientCompressionLevel *float64 `json:"mysqlxLz4MaxClientCompressionLevel,omitempty" tf:"mysqlx_lz4max_client_compression_level,omitempty"`

	// The maximum size of network packets that can be received by X Plugin.
	MysqlxMaxAllowedPacket *float64 `json:"mysqlxMaxAllowedPacket,omitempty" tf:"mysqlx_max_allowed_packet,omitempty"`

	// ("mysqlx_min_worker_threads") DEPRECATED -- variable should not be settable and will be ignored
	MysqlxMinWorkerThreads *float64 `json:"mysqlxMinWorkerThreads,omitempty" tf:"mysqlx_min_worker_threads,omitempty"`

	// The number of seconds that X Plugin waits for blocking read operations to complete. After this time, if the read operation is not successful, X Plugin closes the connection and returns a warning notice with the error code ER_IO_READ_ERROR to the client application.
	MysqlxReadTimeout *float64 `json:"mysqlxReadTimeout,omitempty" tf:"mysqlx_read_timeout,omitempty"`

	// The number of seconds that X Plugin waits for activity on a connection.
	MysqlxWaitTimeout *float64 `json:"mysqlxWaitTimeout,omitempty" tf:"mysqlx_wait_timeout,omitempty"`

	// The number of seconds that X Plugin waits for blocking write operations to complete. After this time, if the write operation is not successful, X Plugin closes the connection.
	MysqlxWriteTimeout *float64 `json:"mysqlxWriteTimeout,omitempty" tf:"mysqlx_write_timeout,omitempty"`

	// Set the default compression level for the zstd algorithm. ("mysqlx_zstd_default_compression_level")
	MysqlxZstdDefaultCompressionLevel *float64 `json:"mysqlxZstdDefaultCompressionLevel,omitempty" tf:"mysqlx_zstd_default_compression_level,omitempty"`

	// Limit the upper bound of accepted compression levels for the zstd algorithm. ("mysqlx_zstd_max_client_compression_level")
	MysqlxZstdMaxClientCompressionLevel *float64 `json:"mysqlxZstdMaxClientCompressionLevel,omitempty" tf:"mysqlx_zstd_max_client_compression_level,omitempty"`

	// The number of seconds to wait for more data from a connection before aborting the read.
	NetReadTimeout *float64 `json:"netReadTimeout,omitempty" tf:"net_read_timeout,omitempty"`

	// The number of seconds to wait for a block to be written to a connection before aborting the write.
	NetWriteTimeout *float64 `json:"netWriteTimeout,omitempty" tf:"net_write_timeout,omitempty"`

	// The optimizer_switch system variable enables control over optimizer behavior. The value of this variable is a set of flags, each of which has a value of on or off to indicate whether the corresponding optimizer behavior is enabled or disabled. This variable has global and session values and can be changed at runtime. The global default can be set at server startup.
	OptimizerSwitch *string `json:"optimizerSwitch,omitempty" tf:"optimizer_switch,omitempty"`

	// ("parser_max_mem_size")
	ParserMaxMemSize *string `json:"parserMaxMemSize,omitempty" tf:"parser_max_mem_size,omitempty"`

	// ("query_alloc_block_size") DEPRECATED -- variable should not be settable and will be ignored
	QueryAllocBlockSize *string `json:"queryAllocBlockSize,omitempty" tf:"query_alloc_block_size,omitempty"`

	// ("query_prealloc_size") DEPRECATED -- variable should not be settable and will be ignored
	QueryPreallocSize *string `json:"queryPreallocSize,omitempty" tf:"query_prealloc_size,omitempty"`

	// The limit on memory consumption for the range optimizer. A value of 0 means “no limit.” If an execution plan considered by the optimizer uses the range access method but the optimizer estimates that the amount of memory needed for this method would exceed the limit, it abandons the plan and considers other plans.
	RangeOptimizerMaxMemSize *string `json:"rangeOptimizerMaxMemSize,omitempty" tf:"range_optimizer_max_mem_size,omitempty"`

	// regexpTimeLimit corresponds to the MySQL system variable [regexp_time_limit] (https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_regexp_time_limit)
	RegexpTimeLimit *float64 `json:"regexpTimeLimit,omitempty" tf:"regexp_time_limit,omitempty"`

	// The maximum amount of space to use for all relay logs.
	RelayLogSpaceLimit *string `json:"relayLogSpaceLimit,omitempty" tf:"relay_log_space_limit,omitempty"`

	// Specifies the number of seconds to wait for more data or a heartbeat signal from the source before the replica considers the connection broken, aborts the read, and tries to reconnect. Setting this variable has no immediate effect. The state of the variable applies on all subsequent START REPLICA commands.
	ReplicaNetTimeout *float64 `json:"replicaNetTimeout,omitempty" tf:"replica_net_timeout,omitempty"`

	// Beginning with MySQL 8.0.26, slave_parallel_workers is deprecated, and you should use replica_parallel_workers instead. (Prior to MySQL 8.0.26, you must use slave_parallel_workers to set the number of applier threads.)
	ReplicaParallelWorkers *float64 `json:"replicaParallelWorkers,omitempty" tf:"replica_parallel_workers,omitempty"`

	// From MySQL 8.0.26, use replica_type_conversions in place of slave_type_conversions, which is deprecated from that release. In releases before MySQL 8.0.26, use slave_type_conversions.
	ReplicaTypeConversions *string `json:"replicaTypeConversions,omitempty" tf:"replica_type_conversions,omitempty"`

	// Whether client connections to the server are required to use some form of secure transport. When this variable is enabled, the server permits only TCP/IP connections encrypted using TLS/SSL, or connections that use a socket file or shared memory. The server rejects nonsecure connection attempts, which fail with an ER_SECURE_TRANSPORT_REQUIRED error.
	RequireSecureTransport *bool `json:"requireSecureTransport,omitempty" tf:"require_secure_transport,omitempty"`

	// Whether GIPK mode is in effect, in which case a MySQL replication source server adds a generated invisible primary key to any InnoDB table that is created without one.
	SQLGenerateInvisiblePrimaryKey *bool `json:"sqlGenerateInvisiblePrimaryKey,omitempty" tf:"sql_generate_invisible_primary_key,omitempty"`

	// ("sql_mode")
	SQLMode *string `json:"sqlMode,omitempty" tf:"sql_mode,omitempty"`

	// ("sql_require_primary_key")
	SQLRequirePrimaryKey *bool `json:"sqlRequirePrimaryKey,omitempty" tf:"sql_require_primary_key,omitempty"`

	// ("sql_warnings")
	SQLWarnings *bool `json:"sqlWarnings,omitempty" tf:"sql_warnings,omitempty"`

	// Whether to resolve host names when checking client connections. If this variable is OFF, mysqld resolves host names when checking client connections. If it is ON, mysqld uses only IP numbers; in this case, all Host column values in the grant tables must be IP addresses. See Section 7.1.12.3, “DNS Lookups and the Host Cache”.
	SkipNameResolve *bool `json:"skipNameResolve,omitempty" tf:"skip_name_resolve,omitempty"`

	// Each session that must perform a sort allocates a buffer of this size.
	SortBufferSize *string `json:"sortBufferSize,omitempty" tf:"sort_buffer_size,omitempty"`

	// The number of table definitions that can be stored in the table definition cache. If you use a large number of tables, you can create a large table definition cache to speed up opening of tables. The table definition cache takes less space and does not use file descriptors, unlike the normal table cache.
	TableDefinitionCache *float64 `json:"tableDefinitionCache,omitempty" tf:"table_definition_cache,omitempty"`

	// The number of open tables for all threads. Increasing this value increases the number of file descriptors that mysqld requires.
	TableOpenCache *float64 `json:"tableOpenCache,omitempty" tf:"table_open_cache,omitempty"`

	// Defines the maximum amount of memory that can be occupied by the TempTable storage engine before it starts storing data on disk. The default value is 1073741824 bytes (1GiB). For more information, see Section 10.4.4, “Internal Temporary Table Use in MySQL”.
	TemptableMaxRAM *string `json:"temptableMaxRam,omitempty" tf:"temptable_max_ram,omitempty"`

	// Controls whether the thread pool uses dedicated listener threads. If enabled, a listener thread in each thread group is dedicated to the task of listening for network events from clients, ensuring that the maximum number of query worker threads is no more than the value specified by threadPoolMaxTransactionsLimit. threadPoolDedicatedListeners corresponds to the MySQL Database Service-specific system variable thread_pool_dedicated_listeners.
	ThreadPoolDedicatedListeners *bool `json:"threadPoolDedicatedListeners,omitempty" tf:"thread_pool_dedicated_listeners,omitempty"`

	// Limits the maximum number of open transactions to the defined value. The default value is 0, which enforces no limit. threadPoolMaxTransactionsLimit corresponds to the MySQL Database Service-specific system variable thread_pool_max_transactions_limit.
	ThreadPoolMaxTransactionsLimit *float64 `json:"threadPoolMaxTransactionsLimit,omitempty" tf:"thread_pool_max_transactions_limit,omitempty"`

	// The maximum number of query threads permitted in a thread group. The maximum value is 4096, but if thread_pool_max_transactions_limit is set, thread_pool_query_threads_per_group must not exceed that value. The default value of 1 means there is one active query thread in each thread group, which works well for many loads. When you are using the high concurrency thread pool algorithm (thread_pool_algorithm = 1), consider increasing the value if you experience slower response times due to long-running transactions.
	ThreadPoolQueryThreadsPerGroup *float64 `json:"threadPoolQueryThreadsPerGroup,omitempty" tf:"thread_pool_query_threads_per_group,omitempty"`

	// The number of thread groups in the thread pool. This is the most important parameter controlling thread pool performance. It affects how many statements can execute simultaneously. If a value outside the range of permissible values is specified, the thread pool plugin does not load and the server writes a message to the error log.
	ThreadPoolSize *float64 `json:"threadPoolSize,omitempty" tf:"thread_pool_size,omitempty"`

	// The delay period before executing a new transaction, in milliseconds. The maximum value is 300000 (5 minutes). A transaction delay can be used in cases where parallel transactions affect the performance of other operations due to resource contention. For example, if parallel transactions affect index creation or an online buffer pool resizing operation, you can configure a transaction delay to reduce resource contention while those operations are running.
	ThreadPoolTransactionDelay *float64 `json:"threadPoolTransactionDelay,omitempty" tf:"thread_pool_transaction_delay,omitempty"`

	// Initializes the time zone for each client that connects.
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`

	// The maximum size of internal in-memory temporary tables. This variable does not apply to user-created MEMORY tables.
	TmpTableSize *string `json:"tmpTableSize,omitempty" tf:"tmp_table_size,omitempty"`

	// ("transaction_isolation")
	TransactionIsolation *string `json:"transactionIsolation,omitempty" tf:"transaction_isolation,omitempty"`

	// The number of seconds the server waits for activity on a noninteractive connection before closing it.
	WaitTimeout *float64 `json:"waitTimeout,omitempty" tf:"wait_timeout,omitempty"`
}

type VariablesParameters struct {

	// auto_increment_increment and auto_increment_offset are intended for use with circular (source-to-source) replication, and can be used to control the operation of AUTO_INCREMENT columns. Both variables have global and session values, and each can assume an integer value between 1 and 65,535 inclusive.
	// +kubebuilder:validation:Optional
	AutoIncrementIncrement *float64 `json:"autoIncrementIncrement,omitempty" tf:"auto_increment_increment,omitempty"`

	// This variable has a default value of 1. If it is left with its default value, and Group Replication is started on the server in multi-primary mode, it is changed to the server ID.
	// +kubebuilder:validation:Optional
	AutoIncrementOffset *float64 `json:"autoIncrementOffset,omitempty" tf:"auto_increment_offset,omitempty"`

	// ("autocommit")
	// +kubebuilder:validation:Optional
	Autocommit *bool `json:"autocommit,omitempty" tf:"autocommit,omitempty"`

	// If enabled, the server stores all temporary tables on disk rather than in memory.
	// +kubebuilder:validation:Optional
	BigTables *bool `json:"bigTables,omitempty" tf:"big_tables,omitempty"`

	// Sets the binary log expiration period in seconds. binlogExpireLogsSeconds corresponds to the MySQL binary logging system variable binlog_expire_logs_seconds.
	// +kubebuilder:validation:Optional
	BinlogExpireLogsSeconds *float64 `json:"binlogExpireLogsSeconds,omitempty" tf:"binlog_expire_logs_seconds,omitempty"`

	// Controls how many microseconds the binary log commit waits before synchronizing the binary log file to disk. There is no delay by default. Setting this variable to a microsecond delay enables more transactions to be synchronized together to disk at once, reducing the overall time to commit a group of transactions because the larger groups required fewer time units per group.
	// +kubebuilder:validation:Optional
	BinlogGroupCommitSyncDelay *float64 `json:"binlogGroupCommitSyncDelay,omitempty" tf:"binlog_group_commit_sync_delay,omitempty"`

	// The maximum number of transactions to wait for before aborting the current delay as specified by binlog_group_commit_sync_delay. If binlog_group_commit_sync_delay is set to 0, then this option has no effect.
	// +kubebuilder:validation:Optional
	BinlogGroupCommitSyncNoDelayCount *float64 `json:"binlogGroupCommitSyncNoDelayCount,omitempty" tf:"binlog_group_commit_sync_no_delay_count,omitempty"`

	// Configures the amount of table metadata added to the binary log when using row-based logging. binlogRowMetadata corresponds to the MySQL binary logging system variable binlog_row_metadata.
	// +kubebuilder:validation:Optional
	BinlogRowMetadata *string `json:"binlogRowMetadata,omitempty" tf:"binlog_row_metadata,omitempty"`

	// When set to PARTIAL_JSON, this enables use of a space-efficient binary log format for updates that modify only a small portion of a JSON document. binlogRowValueOptions corresponds to the MySQL binary logging system variable binlog_row_value_options.
	// +kubebuilder:validation:Optional
	BinlogRowValueOptions *string `json:"binlogRowValueOptions,omitempty" tf:"binlog_row_value_options,omitempty"`

	// Enables compression for transactions that are written to binary log files on this server. binlogTransactionCompression corresponds to the MySQL binary logging system variable binlog_transaction_compression.
	// +kubebuilder:validation:Optional
	BinlogTransactionCompression *bool `json:"binlogTransactionCompression,omitempty" tf:"binlog_transaction_compression,omitempty"`

	// This variable controls the block encryption mode for block-based algorithms such as AES. It affects encryption for AES_ENCRYPT() and AES_DECRYPT(). block_encryption_mode takes a value in aes-keylen-mode format, where keylen is the key length in bits and mode is the encryption mode. The value is not case-sensitive. Permitted keylen values are 128, 192, and 256. Permitted mode values are ECB, CBC, CFB1, CFB8, CFB128, and OFB.
	// +kubebuilder:validation:Optional
	BlockEncryptionMode *string `json:"blockEncryptionMode,omitempty" tf:"block_encryption_mode,omitempty"`

	// The server's default character set. If you set this variable, you should also set collation_server to specify the collation for the character set.
	// +kubebuilder:validation:Optional
	CharacterSetServer *string `json:"characterSetServer,omitempty" tf:"character_set_server,omitempty"`

	// The server's default collation.
	// +kubebuilder:validation:Optional
	CollationServer *string `json:"collationServer,omitempty" tf:"collation_server,omitempty"`

	// ("completion_type")
	// +kubebuilder:validation:Optional
	CompletionType *string `json:"completionType,omitempty" tf:"completion_type,omitempty"`

	// The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
	// +kubebuilder:validation:Optional
	ConnectTimeout *float64 `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Set the chunking size for updates to the global memory usage counter Global_connection_memory.
	// +kubebuilder:validation:Optional
	ConnectionMemoryChunkSize *float64 `json:"connectionMemoryChunkSize,omitempty" tf:"connection_memory_chunk_size,omitempty"`

	// Set the maximum amount of memory that can be used by a single user connection.
	// +kubebuilder:validation:Optional
	ConnectionMemoryLimit *string `json:"connectionMemoryLimit,omitempty" tf:"connection_memory_limit,omitempty"`

	// ("cte_max_recursion_depth")
	// +kubebuilder:validation:Optional
	CteMaxRecursionDepth *string `json:"cteMaxRecursionDepth,omitempty" tf:"cte_max_recursion_depth,omitempty"`

	// The default authentication plugin. This must be a plugin that uses internal credentials storage, so these values are permitted: mysql_native_password, sha256_password, caching_sha2_password.
	// +kubebuilder:validation:Optional
	DefaultAuthenticationPlugin *string `json:"defaultAuthenticationPlugin,omitempty" tf:"default_authentication_plugin,omitempty"`

	// This variable determines the default output format used by EXPLAIN in the absence of a FORMAT option when displaying a query execution plan.
	// +kubebuilder:validation:Optional
	ExplainFormat *string `json:"explainFormat,omitempty" tf:"explain_format,omitempty"`

	// This system variable determines whether the server enables certain nonstandard behaviors for default values and NULL-value handling in TIMESTAMP columns. By default, explicit_defaults_for_timestamp is enabled, which disables the nonstandard behaviors. Disabling explicit_defaults_for_timestamp results in a warning.
	// +kubebuilder:validation:Optional
	ExplicitDefaultsForTimestamp *bool `json:"explicitDefaultsForTimestamp,omitempty" tf:"explicit_defaults_for_timestamp,omitempty"`

	// ("foreign_key_checks")
	// +kubebuilder:validation:Optional
	ForeignKeyChecks *bool `json:"foreignKeyChecks,omitempty" tf:"foreign_key_checks,omitempty"`

	// ("generated_random_password_length") DEPRECATED -- variable should not be settable and will be ignored
	// +kubebuilder:validation:Optional
	GeneratedRandomPasswordLength *float64 `json:"generatedRandomPasswordLength,omitempty" tf:"generated_random_password_length,omitempty"`

	// Set the total amount of memory that can be used by all user connections.
	// +kubebuilder:validation:Optional
	GlobalConnectionMemoryLimit *string `json:"globalConnectionMemoryLimit,omitempty" tf:"global_connection_memory_limit,omitempty"`

	// Determines whether the MySQL server calculates Global_connection_memory.
	// +kubebuilder:validation:Optional
	GlobalConnectionMemoryTracking *bool `json:"globalConnectionMemoryTracking,omitempty" tf:"global_connection_memory_tracking,omitempty"`

	// Specifies the maximum permitted result length in bytes for the GROUP_CONCAT() function.
	// +kubebuilder:validation:Optional
	GroupConcatMaxLen *string `json:"groupConcatMaxLen,omitempty" tf:"group_concat_max_len,omitempty"`

	// +kubebuilder:validation:Optional
	GroupReplicationConsistency *string `json:"groupReplicationConsistency,omitempty" tf:"group_replication_consistency,omitempty"`

	// ("information_schema_stats_expiry")
	// +kubebuilder:validation:Optional
	InformationSchemaStatsExpiry *float64 `json:"informationSchemaStatsExpiry,omitempty" tf:"information_schema_stats_expiry,omitempty"`

	// Whether the InnoDB adaptive hash index is enabled or disabled. It may be desirable, depending on your workload, to dynamically enable or disable adaptive hash indexing to improve query performance. Because the adaptive hash index may not be useful for all workloads, conduct benchmarks with it both enabled and disabled, using realistic workloads.
	// +kubebuilder:validation:Optional
	InnodbAdaptiveHashIndex *bool `json:"innodbAdaptiveHashIndex,omitempty" tf:"innodb_adaptive_hash_index,omitempty"`

	// The lock mode to use for generating auto-increment values. Permissible values are 0, 1, or 2, for traditional, consecutive, or interleaved, respectively.
	// +kubebuilder:validation:Optional
	InnodbAutoincLockMode *float64 `json:"innodbAutoincLockMode,omitempty" tf:"innodb_autoinc_lock_mode,omitempty"`

	// Specifies the percentage of the most recently used pages for each buffer pool to read out and dump.
	// +kubebuilder:validation:Optional
	InnodbBufferPoolDumpPct *float64 `json:"innodbBufferPoolDumpPct,omitempty" tf:"innodb_buffer_pool_dump_pct,omitempty"`

	// ("innodb_buffer_pool_instances")
	// +kubebuilder:validation:Optional
	InnodbBufferPoolInstances *float64 `json:"innodbBufferPoolInstances,omitempty" tf:"innodb_buffer_pool_instances,omitempty"`

	// The size (in bytes) of the buffer pool, that is, the memory area where InnoDB caches table and index data.
	// +kubebuilder:validation:Optional
	InnodbBufferPoolSize *string `json:"innodbBufferPoolSize,omitempty" tf:"innodb_buffer_pool_size,omitempty"`

	// Whether InnoDB performs change buffering, an optimization that delays write operations to secondary indexes so that the I/O operations can be performed sequentially. Permitted values are described in the following table. Values may also be specified numerically.
	// +kubebuilder:validation:Optional
	InnodbChangeBuffering *string `json:"innodbChangeBuffering,omitempty" tf:"innodb_change_buffering,omitempty"`

	// innodbDdlBufferSize corresponds to the MySQL system variable [innodb_ddl_buffer_size] (https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_ddl_buffer_size)
	// +kubebuilder:validation:Optional
	InnodbDdlBufferSize *string `json:"innodbDdlBufferSize,omitempty" tf:"innodb_ddl_buffer_size,omitempty"`

	// innodbDdlThreads corresponds to the MySQL system variable [innodb_ddl_threads] (https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_ddl_threads)
	// +kubebuilder:validation:Optional
	InnodbDdlThreads *float64 `json:"innodbDdlThreads,omitempty" tf:"innodb_ddl_threads,omitempty"`

	// ("innodb_ft_enable_stopword")
	// +kubebuilder:validation:Optional
	InnodbFtEnableStopword *bool `json:"innodbFtEnableStopword,omitempty" tf:"innodb_ft_enable_stopword,omitempty"`

	// ("innodb_ft_max_token_size")
	// +kubebuilder:validation:Optional
	InnodbFtMaxTokenSize *float64 `json:"innodbFtMaxTokenSize,omitempty" tf:"innodb_ft_max_token_size,omitempty"`

	// ("innodb_ft_min_token_size")
	// +kubebuilder:validation:Optional
	InnodbFtMinTokenSize *float64 `json:"innodbFtMinTokenSize,omitempty" tf:"innodb_ft_min_token_size,omitempty"`

	// ("innodb_ft_num_word_optimize")
	// +kubebuilder:validation:Optional
	InnodbFtNumWordOptimize *float64 `json:"innodbFtNumWordOptimize,omitempty" tf:"innodb_ft_num_word_optimize,omitempty"`

	// ("innodb_ft_result_cache_limit")
	// +kubebuilder:validation:Optional
	InnodbFtResultCacheLimit *string `json:"innodbFtResultCacheLimit,omitempty" tf:"innodb_ft_result_cache_limit,omitempty"`

	// ("innodb_ft_server_stopword_table")
	// +kubebuilder:validation:Optional
	InnodbFtServerStopwordTable *string `json:"innodbFtServerStopwordTable,omitempty" tf:"innodb_ft_server_stopword_table,omitempty"`

	// ("innodb_lock_wait_timeout")
	// +kubebuilder:validation:Optional
	InnodbLockWaitTimeout *float64 `json:"innodbLockWaitTimeout,omitempty" tf:"innodb_lock_wait_timeout,omitempty"`

	// Enables dedicated log writer threads for writing redo log records from the log buffer to the system buffers and flushing the system buffers to the redo log files.
	// +kubebuilder:validation:Optional
	InnodbLogWriterThreads *bool `json:"innodbLogWriterThreads,omitempty" tf:"innodb_log_writer_threads,omitempty"`

	// The desired maximum purge lag in terms of transactions.
	// +kubebuilder:validation:Optional
	InnodbMaxPurgeLag *string `json:"innodbMaxPurgeLag,omitempty" tf:"innodb_max_purge_lag,omitempty"`

	// The maximum delay in microseconds for the delay imposed when the innodb_max_purge_lag threshold is exceeded.
	// +kubebuilder:validation:Optional
	InnodbMaxPurgeLagDelay *float64 `json:"innodbMaxPurgeLagDelay,omitempty" tf:"innodb_max_purge_lag_delay,omitempty"`

	// Enables the NUMA interleave memory policy for allocation of the InnoDB buffer pool. When innodb_numa_interleave is enabled, the NUMA memory policy is set to MPOL_INTERLEAVE for the mysqld process. After the InnoDB buffer pool is allocated, the NUMA memory policy is set back to MPOL_DEFAULT. For the innodb_numa_interleave option to be available, MySQL must be compiled on a NUMA-enabled Linux system.
	// +kubebuilder:validation:Optional
	InnodbNumaInterleave *bool `json:"innodbNumaInterleave,omitempty" tf:"innodb_numa_interleave,omitempty"`

	// Specifies an upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables. There is one such log file for each index being created or table being altered. This log file stores data inserted, updated, or deleted in the table during the DDL operation.
	// +kubebuilder:validation:Optional
	InnodbOnlineAlterLogMaxSize *string `json:"innodbOnlineAlterLogMaxSize,omitempty" tf:"innodb_online_alter_log_max_size,omitempty"`

	// Defines the amount of disk space occupied by redo log files. innodb_redo_log_capacity supercedes the innodb_log_files_in_group and innodb_log_file_size variables, which are both ignored if innodb_redo_log_capacity is defined. If innodb_redo_log_capacity is not defined, and if neither innodb_log_file_size or innodb_log_files_in_group are defined, then the default innodb_redo_log_capacity value is used.
	// +kubebuilder:validation:Optional
	InnodbRedoLogCapacity *string `json:"innodbRedoLogCapacity,omitempty" tf:"innodb_redo_log_capacity,omitempty"`

	// InnoDB rolls back only the last statement on a transaction timeout by default. If --innodb-rollback-on-timeout is specified, a transaction timeout causes InnoDB to abort and roll back the entire transaction.
	// +kubebuilder:validation:Optional
	InnodbRollbackOnTimeout *bool `json:"innodbRollbackOnTimeout,omitempty" tf:"innodb_rollback_on_timeout,omitempty"`

	// This variable defines:
	// +kubebuilder:validation:Optional
	InnodbSortBufferSize *float64 `json:"innodbSortBufferSize,omitempty" tf:"innodb_sort_buffer_size,omitempty"`

	// The number of index pages to sample when estimating cardinality and other statistics for an indexed column, such as those calculated by ANALYZE TABLE.
	// +kubebuilder:validation:Optional
	InnodbStatsPersistentSamplePages *string `json:"innodbStatsPersistentSamplePages,omitempty" tf:"innodb_stats_persistent_sample_pages,omitempty"`

	// The number of index pages to sample when estimating cardinality and other statistics for an indexed column, such as those calculated by ANALYZE TABLE.
	// +kubebuilder:validation:Optional
	InnodbStatsTransientSamplePages *string `json:"innodbStatsTransientSamplePages,omitempty" tf:"innodb_stats_transient_sample_pages,omitempty"`

	// When you enable innodbStrictMode, the InnoDB storage engine returns errors instead of warnings for invalid or incompatible table options.
	// +kubebuilder:validation:Optional
	InnodbStrictMode *bool `json:"innodbStrictMode,omitempty" tf:"innodb_strict_mode,omitempty"`

	// When enabled, undo tablespaces that exceed the threshold value defined by innodb_max_undo_log_size are marked for truncation. Only undo tablespaces can be truncated. Truncating undo logs that reside in the system tablespace is not supported. For truncation to occur, there must be at least two undo tablespaces.
	// +kubebuilder:validation:Optional
	InnodbUndoLogTruncate *bool `json:"innodbUndoLogTruncate,omitempty" tf:"innodb_undo_log_truncate,omitempty"`

	// The number of seconds the server waits for activity on an interactive connection before closing it.
	// +kubebuilder:validation:Optional
	InteractiveTimeout *float64 `json:"interactiveTimeout,omitempty" tf:"interactive_timeout,omitempty"`

	// The minimum size of the buffer that is used for plain index scans, range index scans, and joins that do not use indexes and thus perform full table scans. In MySQL 8.0.18 and later, this variable also controls the amount of memory used for hash joins. Normally, the best way to get fast joins is to add indexes. Increase the value of join_buffer_size to get a faster full join when adding indexes is not possible. One join buffer is allocated for each full join between two tables. For a complex join between several tables for which indexes are not used, multiple join buffers might be necessary.
	// +kubebuilder:validation:Optional
	JoinBufferSize *string `json:"joinBufferSize,omitempty" tf:"join_buffer_size,omitempty"`

	// This variable controls server-side LOCAL capability for LOAD DATA statements. Depending on the local_infile setting, the server refuses or permits local data loading by clients that have LOCAL enabled on the client side.
	// +kubebuilder:validation:Optional
	LocalInfile *bool `json:"localInfile,omitempty" tf:"local_infile,omitempty"`

	// If a query takes longer than this many seconds, the server increments the Slow_queries status variable. If the slow query log is enabled, the query is logged to the slow query log file. This value is measured in real time, not CPU time, so a query that is under the threshold on a lightly loaded system might be above the threshold on a heavily loaded one.
	// +kubebuilder:validation:Optional
	LongQueryTime *float64 `json:"longQueryTime,omitempty" tf:"long_query_time,omitempty"`

	// ("mandatory_roles")
	// +kubebuilder:validation:Optional
	MandatoryRoles *string `json:"mandatoryRoles,omitempty" tf:"mandatory_roles,omitempty"`

	// The maximum size of one packet or any generated/intermediate string.
	// +kubebuilder:validation:Optional
	MaxAllowedPacket *float64 `json:"maxAllowedPacket,omitempty" tf:"max_allowed_packet,omitempty"`

	// Sets the size of the transaction cache.
	// +kubebuilder:validation:Optional
	MaxBinlogCacheSize *string `json:"maxBinlogCacheSize,omitempty" tf:"max_binlog_cache_size,omitempty"`

	// ("max_connect_errors")
	// +kubebuilder:validation:Optional
	MaxConnectErrors *string `json:"maxConnectErrors,omitempty" tf:"max_connect_errors,omitempty"`

	// ("max_connections")
	// +kubebuilder:validation:Optional
	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`

	// ("max_execution_time")
	// +kubebuilder:validation:Optional
	MaxExecutionTime *string `json:"maxExecutionTime,omitempty" tf:"max_execution_time,omitempty"`

	// This variable sets the maximum size to which user-created MEMORY tables are permitted to grow.
	// +kubebuilder:validation:Optional
	MaxHeapTableSize *string `json:"maxHeapTableSize,omitempty" tf:"max_heap_table_size,omitempty"`

	// ("max_prepared_stmt_count")
	// +kubebuilder:validation:Optional
	MaxPreparedStmtCount *float64 `json:"maxPreparedStmtCount,omitempty" tf:"max_prepared_stmt_count,omitempty"`

	// Limit the assumed maximum number of seeks when looking up rows based on a key. The MySQL optimizer assumes that no more than this number of key seeks are required when searching for matching rows in a table by scanning an index, regardless of the actual cardinality of the index (see Section 15.7.7.22, “SHOW INDEX Statement”). By setting this to a low value (say, 100), you can force MySQL to prefer indexes instead of table scans.
	// +kubebuilder:validation:Optional
	MaxSeeksForKey *string `json:"maxSeeksForKey,omitempty" tf:"max_seeks_for_key,omitempty"`

	// The maximum number of simultaneous connections permitted to any given MySQL user account. A value of 0 (the default) means “no limit.” This variable has a global value that can be set at server startup or runtime. It also has a read-only session value that indicates the effective simultaneous-connection limit that applies to the account associated with the current session.
	// +kubebuilder:validation:Optional
	MaxUserConnections *string `json:"maxUserConnections,omitempty" tf:"max_user_connections,omitempty"`

	// ("mysql_firewall_mode")
	// +kubebuilder:validation:Optional
	MySQLFirewallMode *bool `json:"mysqlFirewallMode,omitempty" tf:"mysql_firewall_mode,omitempty"`

	// DEPRECATED -- typo of mysqlx_zstd_default_compression_level. variable will be ignored.
	// +kubebuilder:validation:Optional
	MySQLZstdDefaultCompressionLevel *float64 `json:"mysqlZstdDefaultCompressionLevel,omitempty" tf:"mysql_zstd_default_compression_level,omitempty"`

	// The number of seconds X Plugin waits for the first packet to be received from newly connected clients.
	// +kubebuilder:validation:Optional
	MysqlxConnectTimeout *float64 `json:"mysqlxConnectTimeout,omitempty" tf:"mysqlx_connect_timeout,omitempty"`

	// Set the default compression level for the deflate algorithm. ("mysqlx_deflate_default_compression_level")
	// +kubebuilder:validation:Optional
	MysqlxDeflateDefaultCompressionLevel *float64 `json:"mysqlxDeflateDefaultCompressionLevel,omitempty" tf:"mysqlx_deflate_default_compression_level,omitempty"`

	// Limit the upper bound of accepted compression levels for the deflate algorithm. ("mysqlx_deflate_max_client_compression_level")
	// +kubebuilder:validation:Optional
	MysqlxDeflateMaxClientCompressionLevel *float64 `json:"mysqlxDeflateMaxClientCompressionLevel,omitempty" tf:"mysqlx_deflate_max_client_compression_level,omitempty"`

	// ("mysqlx_document_id_unique_prefix") DEPRECATED -- variable should not be settable and will be ignored
	// +kubebuilder:validation:Optional
	MysqlxDocumentIDUniquePrefix *float64 `json:"mysqlxDocumentIdUniquePrefix,omitempty" tf:"mysqlx_document_id_unique_prefix,omitempty"`

	// ("mysqlx_enable_hello_notice") DEPRECATED -- variable should not be settable and will be ignored
	// +kubebuilder:validation:Optional
	MysqlxEnableHelloNotice *bool `json:"mysqlxEnableHelloNotice,omitempty" tf:"mysqlx_enable_hello_notice,omitempty"`

	// ("mysqlx_idle_worker_thread_timeout") DEPRECATED -- variable should not be settable and will be ignored
	// +kubebuilder:validation:Optional
	MysqlxIdleWorkerThreadTimeout *float64 `json:"mysqlxIdleWorkerThreadTimeout,omitempty" tf:"mysqlx_idle_worker_thread_timeout,omitempty"`

	// The number of seconds to wait for interactive clients to timeout.
	// +kubebuilder:validation:Optional
	MysqlxInteractiveTimeout *float64 `json:"mysqlxInteractiveTimeout,omitempty" tf:"mysqlx_interactive_timeout,omitempty"`

	// Set the default compression level for the lz4 algorithm. ("mysqlx_lz4_default_compression_level")
	// +kubebuilder:validation:Optional
	MysqlxLz4DefaultCompressionLevel *float64 `json:"mysqlxLz4DefaultCompressionLevel,omitempty" tf:"mysqlx_lz4default_compression_level,omitempty"`

	// Limit the upper bound of accepted compression levels for the lz4 algorithm. ("mysqlx_lz4_max_client_compression_level")
	// +kubebuilder:validation:Optional
	MysqlxLz4MaxClientCompressionLevel *float64 `json:"mysqlxLz4MaxClientCompressionLevel,omitempty" tf:"mysqlx_lz4max_client_compression_level,omitempty"`

	// The maximum size of network packets that can be received by X Plugin.
	// +kubebuilder:validation:Optional
	MysqlxMaxAllowedPacket *float64 `json:"mysqlxMaxAllowedPacket,omitempty" tf:"mysqlx_max_allowed_packet,omitempty"`

	// ("mysqlx_min_worker_threads") DEPRECATED -- variable should not be settable and will be ignored
	// +kubebuilder:validation:Optional
	MysqlxMinWorkerThreads *float64 `json:"mysqlxMinWorkerThreads,omitempty" tf:"mysqlx_min_worker_threads,omitempty"`

	// The number of seconds that X Plugin waits for blocking read operations to complete. After this time, if the read operation is not successful, X Plugin closes the connection and returns a warning notice with the error code ER_IO_READ_ERROR to the client application.
	// +kubebuilder:validation:Optional
	MysqlxReadTimeout *float64 `json:"mysqlxReadTimeout,omitempty" tf:"mysqlx_read_timeout,omitempty"`

	// The number of seconds that X Plugin waits for activity on a connection.
	// +kubebuilder:validation:Optional
	MysqlxWaitTimeout *float64 `json:"mysqlxWaitTimeout,omitempty" tf:"mysqlx_wait_timeout,omitempty"`

	// The number of seconds that X Plugin waits for blocking write operations to complete. After this time, if the write operation is not successful, X Plugin closes the connection.
	// +kubebuilder:validation:Optional
	MysqlxWriteTimeout *float64 `json:"mysqlxWriteTimeout,omitempty" tf:"mysqlx_write_timeout,omitempty"`

	// Set the default compression level for the zstd algorithm. ("mysqlx_zstd_default_compression_level")
	// +kubebuilder:validation:Optional
	MysqlxZstdDefaultCompressionLevel *float64 `json:"mysqlxZstdDefaultCompressionLevel,omitempty" tf:"mysqlx_zstd_default_compression_level,omitempty"`

	// Limit the upper bound of accepted compression levels for the zstd algorithm. ("mysqlx_zstd_max_client_compression_level")
	// +kubebuilder:validation:Optional
	MysqlxZstdMaxClientCompressionLevel *float64 `json:"mysqlxZstdMaxClientCompressionLevel,omitempty" tf:"mysqlx_zstd_max_client_compression_level,omitempty"`

	// The number of seconds to wait for more data from a connection before aborting the read.
	// +kubebuilder:validation:Optional
	NetReadTimeout *float64 `json:"netReadTimeout,omitempty" tf:"net_read_timeout,omitempty"`

	// The number of seconds to wait for a block to be written to a connection before aborting the write.
	// +kubebuilder:validation:Optional
	NetWriteTimeout *float64 `json:"netWriteTimeout,omitempty" tf:"net_write_timeout,omitempty"`

	// The optimizer_switch system variable enables control over optimizer behavior. The value of this variable is a set of flags, each of which has a value of on or off to indicate whether the corresponding optimizer behavior is enabled or disabled. This variable has global and session values and can be changed at runtime. The global default can be set at server startup.
	// +kubebuilder:validation:Optional
	OptimizerSwitch *string `json:"optimizerSwitch,omitempty" tf:"optimizer_switch,omitempty"`

	// ("parser_max_mem_size")
	// +kubebuilder:validation:Optional
	ParserMaxMemSize *string `json:"parserMaxMemSize,omitempty" tf:"parser_max_mem_size,omitempty"`

	// ("query_alloc_block_size") DEPRECATED -- variable should not be settable and will be ignored
	// +kubebuilder:validation:Optional
	QueryAllocBlockSize *string `json:"queryAllocBlockSize,omitempty" tf:"query_alloc_block_size,omitempty"`

	// ("query_prealloc_size") DEPRECATED -- variable should not be settable and will be ignored
	// +kubebuilder:validation:Optional
	QueryPreallocSize *string `json:"queryPreallocSize,omitempty" tf:"query_prealloc_size,omitempty"`

	// The limit on memory consumption for the range optimizer. A value of 0 means “no limit.” If an execution plan considered by the optimizer uses the range access method but the optimizer estimates that the amount of memory needed for this method would exceed the limit, it abandons the plan and considers other plans.
	// +kubebuilder:validation:Optional
	RangeOptimizerMaxMemSize *string `json:"rangeOptimizerMaxMemSize,omitempty" tf:"range_optimizer_max_mem_size,omitempty"`

	// regexpTimeLimit corresponds to the MySQL system variable [regexp_time_limit] (https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_regexp_time_limit)
	// +kubebuilder:validation:Optional
	RegexpTimeLimit *float64 `json:"regexpTimeLimit,omitempty" tf:"regexp_time_limit,omitempty"`

	// The maximum amount of space to use for all relay logs.
	// +kubebuilder:validation:Optional
	RelayLogSpaceLimit *string `json:"relayLogSpaceLimit,omitempty" tf:"relay_log_space_limit,omitempty"`

	// Specifies the number of seconds to wait for more data or a heartbeat signal from the source before the replica considers the connection broken, aborts the read, and tries to reconnect. Setting this variable has no immediate effect. The state of the variable applies on all subsequent START REPLICA commands.
	// +kubebuilder:validation:Optional
	ReplicaNetTimeout *float64 `json:"replicaNetTimeout,omitempty" tf:"replica_net_timeout,omitempty"`

	// Beginning with MySQL 8.0.26, slave_parallel_workers is deprecated, and you should use replica_parallel_workers instead. (Prior to MySQL 8.0.26, you must use slave_parallel_workers to set the number of applier threads.)
	// +kubebuilder:validation:Optional
	ReplicaParallelWorkers *float64 `json:"replicaParallelWorkers,omitempty" tf:"replica_parallel_workers,omitempty"`

	// From MySQL 8.0.26, use replica_type_conversions in place of slave_type_conversions, which is deprecated from that release. In releases before MySQL 8.0.26, use slave_type_conversions.
	// +kubebuilder:validation:Optional
	ReplicaTypeConversions *string `json:"replicaTypeConversions,omitempty" tf:"replica_type_conversions,omitempty"`

	// Whether client connections to the server are required to use some form of secure transport. When this variable is enabled, the server permits only TCP/IP connections encrypted using TLS/SSL, or connections that use a socket file or shared memory. The server rejects nonsecure connection attempts, which fail with an ER_SECURE_TRANSPORT_REQUIRED error.
	// +kubebuilder:validation:Optional
	RequireSecureTransport *bool `json:"requireSecureTransport,omitempty" tf:"require_secure_transport,omitempty"`

	// Whether GIPK mode is in effect, in which case a MySQL replication source server adds a generated invisible primary key to any InnoDB table that is created without one.
	// +kubebuilder:validation:Optional
	SQLGenerateInvisiblePrimaryKey *bool `json:"sqlGenerateInvisiblePrimaryKey,omitempty" tf:"sql_generate_invisible_primary_key,omitempty"`

	// ("sql_mode")
	// +kubebuilder:validation:Optional
	SQLMode *string `json:"sqlMode,omitempty" tf:"sql_mode,omitempty"`

	// ("sql_require_primary_key")
	// +kubebuilder:validation:Optional
	SQLRequirePrimaryKey *bool `json:"sqlRequirePrimaryKey,omitempty" tf:"sql_require_primary_key,omitempty"`

	// ("sql_warnings")
	// +kubebuilder:validation:Optional
	SQLWarnings *bool `json:"sqlWarnings,omitempty" tf:"sql_warnings,omitempty"`

	// Whether to resolve host names when checking client connections. If this variable is OFF, mysqld resolves host names when checking client connections. If it is ON, mysqld uses only IP numbers; in this case, all Host column values in the grant tables must be IP addresses. See Section 7.1.12.3, “DNS Lookups and the Host Cache”.
	// +kubebuilder:validation:Optional
	SkipNameResolve *bool `json:"skipNameResolve,omitempty" tf:"skip_name_resolve,omitempty"`

	// Each session that must perform a sort allocates a buffer of this size.
	// +kubebuilder:validation:Optional
	SortBufferSize *string `json:"sortBufferSize,omitempty" tf:"sort_buffer_size,omitempty"`

	// The number of table definitions that can be stored in the table definition cache. If you use a large number of tables, you can create a large table definition cache to speed up opening of tables. The table definition cache takes less space and does not use file descriptors, unlike the normal table cache.
	// +kubebuilder:validation:Optional
	TableDefinitionCache *float64 `json:"tableDefinitionCache,omitempty" tf:"table_definition_cache,omitempty"`

	// The number of open tables for all threads. Increasing this value increases the number of file descriptors that mysqld requires.
	// +kubebuilder:validation:Optional
	TableOpenCache *float64 `json:"tableOpenCache,omitempty" tf:"table_open_cache,omitempty"`

	// Defines the maximum amount of memory that can be occupied by the TempTable storage engine before it starts storing data on disk. The default value is 1073741824 bytes (1GiB). For more information, see Section 10.4.4, “Internal Temporary Table Use in MySQL”.
	// +kubebuilder:validation:Optional
	TemptableMaxRAM *string `json:"temptableMaxRam,omitempty" tf:"temptable_max_ram,omitempty"`

	// Controls whether the thread pool uses dedicated listener threads. If enabled, a listener thread in each thread group is dedicated to the task of listening for network events from clients, ensuring that the maximum number of query worker threads is no more than the value specified by threadPoolMaxTransactionsLimit. threadPoolDedicatedListeners corresponds to the MySQL Database Service-specific system variable thread_pool_dedicated_listeners.
	// +kubebuilder:validation:Optional
	ThreadPoolDedicatedListeners *bool `json:"threadPoolDedicatedListeners,omitempty" tf:"thread_pool_dedicated_listeners,omitempty"`

	// Limits the maximum number of open transactions to the defined value. The default value is 0, which enforces no limit. threadPoolMaxTransactionsLimit corresponds to the MySQL Database Service-specific system variable thread_pool_max_transactions_limit.
	// +kubebuilder:validation:Optional
	ThreadPoolMaxTransactionsLimit *float64 `json:"threadPoolMaxTransactionsLimit,omitempty" tf:"thread_pool_max_transactions_limit,omitempty"`

	// The maximum number of query threads permitted in a thread group. The maximum value is 4096, but if thread_pool_max_transactions_limit is set, thread_pool_query_threads_per_group must not exceed that value. The default value of 1 means there is one active query thread in each thread group, which works well for many loads. When you are using the high concurrency thread pool algorithm (thread_pool_algorithm = 1), consider increasing the value if you experience slower response times due to long-running transactions.
	// +kubebuilder:validation:Optional
	ThreadPoolQueryThreadsPerGroup *float64 `json:"threadPoolQueryThreadsPerGroup,omitempty" tf:"thread_pool_query_threads_per_group,omitempty"`

	// The number of thread groups in the thread pool. This is the most important parameter controlling thread pool performance. It affects how many statements can execute simultaneously. If a value outside the range of permissible values is specified, the thread pool plugin does not load and the server writes a message to the error log.
	// +kubebuilder:validation:Optional
	ThreadPoolSize *float64 `json:"threadPoolSize,omitempty" tf:"thread_pool_size,omitempty"`

	// The delay period before executing a new transaction, in milliseconds. The maximum value is 300000 (5 minutes). A transaction delay can be used in cases where parallel transactions affect the performance of other operations due to resource contention. For example, if parallel transactions affect index creation or an online buffer pool resizing operation, you can configure a transaction delay to reduce resource contention while those operations are running.
	// +kubebuilder:validation:Optional
	ThreadPoolTransactionDelay *float64 `json:"threadPoolTransactionDelay,omitempty" tf:"thread_pool_transaction_delay,omitempty"`

	// Initializes the time zone for each client that connects.
	// +kubebuilder:validation:Optional
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`

	// The maximum size of internal in-memory temporary tables. This variable does not apply to user-created MEMORY tables.
	// +kubebuilder:validation:Optional
	TmpTableSize *string `json:"tmpTableSize,omitempty" tf:"tmp_table_size,omitempty"`

	// ("transaction_isolation")
	// +kubebuilder:validation:Optional
	TransactionIsolation *string `json:"transactionIsolation,omitempty" tf:"transaction_isolation,omitempty"`

	// The number of seconds the server waits for activity on a noninteractive connection before closing it.
	// +kubebuilder:validation:Optional
	WaitTimeout *float64 `json:"waitTimeout,omitempty" tf:"wait_timeout,omitempty"`
}

// MysqlConfigurationSpec defines the desired state of MysqlConfiguration
type MysqlConfigurationSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MysqlConfigurationParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider MysqlConfigurationInitParameters `json:"initProvider,omitempty"`
}

// MysqlConfigurationStatus defines the observed state of MysqlConfiguration.
type MysqlConfigurationStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MysqlConfigurationObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// MysqlConfiguration is the Schema for the MysqlConfigurations API. Provides the Mysql Configuration resource in Oracle Cloud Infrastructure MySQL Database service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type MysqlConfiguration struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.compartmentId) || (has(self.initProvider) && has(self.initProvider.compartmentId))",message="spec.forProvider.compartmentId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.shapeName) || (has(self.initProvider) && has(self.initProvider.shapeName))",message="spec.forProvider.shapeName is a required parameter"
	Spec   MysqlConfigurationSpec   `json:"spec"`
	Status MysqlConfigurationStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MysqlConfigurationList contains a list of MysqlConfigurations
type MysqlConfigurationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MysqlConfiguration `json:"items"`
}

// Repository type metadata.
var (
	MysqlConfiguration_Kind             = "MysqlConfiguration"
	MysqlConfiguration_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: MysqlConfiguration_Kind}.String()
	MysqlConfiguration_KindAPIVersion   = MysqlConfiguration_Kind + "." + CRDGroupVersion.String()
	MysqlConfiguration_GroupVersionKind = CRDGroupVersion.WithKind(MysqlConfiguration_Kind)
)

func init() {
	SchemeBuilder.Register(&MysqlConfiguration{}, &MysqlConfigurationList{})
}
