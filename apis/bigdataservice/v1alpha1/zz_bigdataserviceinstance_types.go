/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AttachedBlockVolumesInitParameters struct {
}

type AttachedBlockVolumesObservation struct {

	// The OCID of the volume attachment.
	VolumeAttachmentID *string `json:"volumeAttachmentId,omitempty" tf:"volume_attachment_id,omitempty"`

	// The size of the volume in GBs.
	VolumeSizeInGbs *string `json:"volumeSizeInGbs,omitempty" tf:"volume_size_in_gbs,omitempty"`
}

type AttachedBlockVolumesParameters struct {
}

type BdsClusterVersionSummaryInitParameters struct {

	// BDS version to be used for cluster creation
	BdsVersion *string `json:"bdsVersion,omitempty" tf:"bds_version,omitempty"`

	// ODH version to be used for cluster creation
	OdhVersion *string `json:"odhVersion,omitempty" tf:"odh_version,omitempty"`
}

type BdsClusterVersionSummaryObservation struct {

	// BDS version to be used for cluster creation
	BdsVersion *string `json:"bdsVersion,omitempty" tf:"bds_version,omitempty"`

	// ODH version to be used for cluster creation
	OdhVersion *string `json:"odhVersion,omitempty" tf:"odh_version,omitempty"`
}

type BdsClusterVersionSummaryParameters struct {

	// BDS version to be used for cluster creation
	// +kubebuilder:validation:Optional
	BdsVersion *string `json:"bdsVersion" tf:"bds_version,omitempty"`

	// ODH version to be used for cluster creation
	// +kubebuilder:validation:Optional
	OdhVersion *string `json:"odhVersion,omitempty" tf:"odh_version,omitempty"`
}

type BigdataserviceInstanceInitParameters struct {

	// Cluster version details including bds and odh version information.
	BdsClusterVersionSummary []BdsClusterVersionSummaryInitParameters `json:"bdsClusterVersionSummary,omitempty" tf:"bds_cluster_version_summary,omitempty"`

	// (Updatable) Pre-authenticated URL of the script in Object Store that is downloaded and executed.
	BootstrapScriptURL *string `json:"bootstrapScriptUrl,omitempty" tf:"bootstrap_script_url,omitempty"`

	// The information about added Cloud SQL capability
	CloudSQLDetails []CloudSQLDetailsInitParameters `json:"cloudSqlDetails,omitempty" tf:"cloud_sql_details,omitempty"`

	// Base-64 encoded password for the cluster (and Cloudera Manager) admin user.
	ClusterAdminPasswordSecretRef v1.SecretKeySelector `json:"clusterAdminPasswordSecretRef" tf:"-"`

	// Profile of the Big Data Service cluster.
	ClusterProfile *string `json:"clusterProfile,omitempty" tf:"cluster_profile,omitempty"`

	// The SSH public key used to authenticate the cluster connection.
	ClusterPublicKey *string `json:"clusterPublicKey,omitempty" tf:"cluster_public_key,omitempty"`

	// Version of the Hadoop distribution
	ClusterVersion *string `json:"clusterVersion,omitempty" tf:"cluster_version,omitempty"`

	// (Updatable) The OCID of the compartment
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	ComputeOnlyWorkerNode []ComputeOnlyWorkerNodeInitParameters `json:"computeOnlyWorkerNode,omitempty" tf:"compute_only_worker_node,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Name of the BDS instance
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	EdgeNode []EdgeNodeInitParameters `json:"edgeNode,omitempty" tf:"edge_node,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Tag to ignore changing the shape of existing worker, master, utility, compute_only_worker, edge, kafka_broker nodes, in a list format, when new nodes are added with a different shape.
	IgnoreExistingNodesShape []*string `json:"ignoreExistingNodesShape,omitempty" tf:"ignore_existing_nodes_shape,omitempty"`

	// (Updatable) Boolean flag specifying whether we configure Cloud SQL or not
	IsCloudSQLConfigured *bool `json:"isCloudSqlConfigured,omitempty" tf:"is_cloud_sql_configured,omitempty"`

	IsForceRemoveEnabled *bool `json:"isForceRemoveEnabled,omitempty" tf:"is_force_remove_enabled,omitempty"`

	// (Updatable) When setting state as INACTIVE for stopping a cluster, setting this flag to true forcefully stops the bds instance.
	IsForceStopJobs *bool `json:"isForceStopJobs,omitempty" tf:"is_force_stop_jobs,omitempty"`

	// Boolean flag specifying whether or not the cluster is HA
	IsHighAvailability *bool `json:"isHighAvailability,omitempty" tf:"is_high_availability,omitempty"`

	// Boolean flag specifying whether or not Kafka should be configured.
	IsKafkaConfigured *bool `json:"isKafkaConfigured,omitempty" tf:"is_kafka_configured,omitempty"`

	// Boolean flag specifying whether or not the cluster should be setup as secure.
	IsSecure *bool `json:"isSecure,omitempty" tf:"is_secure,omitempty"`

	// (Updatable) The OCID of the Key Management master encryption key.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The kafka broker node in the BDS instance
	KafkaBrokerNode []KafkaBrokerNodeInitParameters `json:"kafkaBrokerNode,omitempty" tf:"kafka_broker_node,omitempty"`

	// The user-defined kerberos realm name.
	KerberosRealmName *string `json:"kerberosRealmName,omitempty" tf:"kerberos_realm_name,omitempty"`

	// The master node in the BDS instance
	MasterNode []MasterNodeInitParameters `json:"masterNode,omitempty" tf:"master_node,omitempty"`

	// (Updatable) Additional configuration of the user's network.
	NetworkConfig []NetworkConfigInitParameters `json:"networkConfig,omitempty" tf:"network_config,omitempty"`

	// (Updatable) The version of the patch to be upated.
	OsPatchVersion *string `json:"osPatchVersion,omitempty" tf:"os_patch_version,omitempty"`

	// (Updatable) An optional property when used triggers Remove Node. Takes the node ocid as input.
	RemoveNode *string `json:"removeNode,omitempty" tf:"remove_node,omitempty"`

	StartClusterShapeConfigs []StartClusterShapeConfigsInitParameters `json:"startClusterShapeConfigs,omitempty" tf:"start_cluster_shape_configs,omitempty"`

	// (Updatable) The target state for the Bds Instance. Could be set to ACTIVE or INACTIVE.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The utility node in the BDS instance
	UtilNode []UtilNodeInitParameters `json:"utilNode,omitempty" tf:"util_node,omitempty"`

	WorkerNode []WorkerNodeInitParameters `json:"workerNode,omitempty" tf:"worker_node,omitempty"`
}

type BigdataserviceInstanceObservation struct {

	// Cluster version details including bds and odh version information.
	BdsClusterVersionSummary []BdsClusterVersionSummaryObservation `json:"bdsClusterVersionSummary,omitempty" tf:"bds_cluster_version_summary,omitempty"`

	// (Updatable) Pre-authenticated URL of the script in Object Store that is downloaded and executed.
	BootstrapScriptURL *string `json:"bootstrapScriptUrl,omitempty" tf:"bootstrap_script_url,omitempty"`

	// The information about added Cloud SQL capability
	CloudSQLDetails []CloudSQLDetailsObservation `json:"cloudSqlDetails,omitempty" tf:"cloud_sql_details,omitempty"`

	// Specific info about a Hadoop cluster
	ClusterDetails []ClusterDetailsObservation `json:"clusterDetails,omitempty" tf:"cluster_details,omitempty"`

	// Profile of the Big Data Service cluster.
	ClusterProfile *string `json:"clusterProfile,omitempty" tf:"cluster_profile,omitempty"`

	// The SSH public key used to authenticate the cluster connection.
	ClusterPublicKey *string `json:"clusterPublicKey,omitempty" tf:"cluster_public_key,omitempty"`

	// Version of the Hadoop distribution
	ClusterVersion *string `json:"clusterVersion,omitempty" tf:"cluster_version,omitempty"`

	// (Updatable) The OCID of the compartment
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	ComputeOnlyWorkerNode []ComputeOnlyWorkerNodeObservation `json:"computeOnlyWorkerNode,omitempty" tf:"compute_only_worker_node,omitempty"`

	// The user who created the cluster.
	CreatedBy *string `json:"createdBy,omitempty" tf:"created_by,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Name of the BDS instance
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	EdgeNode []EdgeNodeObservation `json:"edgeNode,omitempty" tf:"edge_node,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The OCID of the Big Data Service resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Tag to ignore changing the shape of existing worker, master, utility, compute_only_worker, edge, kafka_broker nodes, in a list format, when new nodes are added with a different shape.
	IgnoreExistingNodesShape []*string `json:"ignoreExistingNodesShape,omitempty" tf:"ignore_existing_nodes_shape,omitempty"`

	// (Updatable) Boolean flag specifying whether we configure Cloud SQL or not
	IsCloudSQLConfigured *bool `json:"isCloudSqlConfigured,omitempty" tf:"is_cloud_sql_configured,omitempty"`

	IsForceRemoveEnabled *bool `json:"isForceRemoveEnabled,omitempty" tf:"is_force_remove_enabled,omitempty"`

	// (Updatable) When setting state as INACTIVE for stopping a cluster, setting this flag to true forcefully stops the bds instance.
	IsForceStopJobs *bool `json:"isForceStopJobs,omitempty" tf:"is_force_stop_jobs,omitempty"`

	// Boolean flag specifying whether or not the cluster is HA
	IsHighAvailability *bool `json:"isHighAvailability,omitempty" tf:"is_high_availability,omitempty"`

	// Boolean flag specifying whether or not Kafka should be configured.
	IsKafkaConfigured *bool `json:"isKafkaConfigured,omitempty" tf:"is_kafka_configured,omitempty"`

	// Boolean flag specifying whether or not the cluster should be setup as secure.
	IsSecure *bool `json:"isSecure,omitempty" tf:"is_secure,omitempty"`

	// (Updatable) The OCID of the Key Management master encryption key.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The kafka broker node in the BDS instance
	KafkaBrokerNode []KafkaBrokerNodeObservation `json:"kafkaBrokerNode,omitempty" tf:"kafka_broker_node,omitempty"`

	// The user-defined kerberos realm name.
	KerberosRealmName *string `json:"kerberosRealmName,omitempty" tf:"kerberos_realm_name,omitempty"`

	// The master node in the BDS instance
	MasterNode []MasterNodeObservation `json:"masterNode,omitempty" tf:"master_node,omitempty"`

	// (Updatable) Additional configuration of the user's network.
	NetworkConfig []NetworkConfigObservation `json:"networkConfig,omitempty" tf:"network_config,omitempty"`

	// The list of nodes in the Big Data Service cluster.
	Nodes []NodesObservation `json:"nodes,omitempty" tf:"nodes,omitempty"`

	// The amount of master nodes should be created.
	NumberOfNodes *float64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes,omitempty"`

	// Number of nodes that require a maintenance reboot
	NumberOfNodesRequiringMaintenanceReboot *float64 `json:"numberOfNodesRequiringMaintenanceReboot,omitempty" tf:"number_of_nodes_requiring_maintenance_reboot,omitempty"`

	// (Updatable) The version of the patch to be upated.
	OsPatchVersion *string `json:"osPatchVersion,omitempty" tf:"os_patch_version,omitempty"`

	// (Updatable) An optional property when used triggers Remove Node. Takes the node ocid as input.
	RemoveNode *string `json:"removeNode,omitempty" tf:"remove_node,omitempty"`

	StartClusterShapeConfigs []StartClusterShapeConfigsObservation `json:"startClusterShapeConfigs,omitempty" tf:"start_cluster_shape_configs,omitempty"`

	// (Updatable) The target state for the Bds Instance. Could be set to ACTIVE or INACTIVE.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The time the cluster was created, shown as an RFC 3339 formatted datetime string.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The time the cluster was updated, shown as an RFC 3339 formatted datetime string.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`

	// The utility node in the BDS instance
	UtilNode []UtilNodeObservation `json:"utilNode,omitempty" tf:"util_node,omitempty"`

	WorkerNode []WorkerNodeObservation `json:"workerNode,omitempty" tf:"worker_node,omitempty"`
}

type BigdataserviceInstanceParameters struct {

	// Cluster version details including bds and odh version information.
	// +kubebuilder:validation:Optional
	BdsClusterVersionSummary []BdsClusterVersionSummaryParameters `json:"bdsClusterVersionSummary,omitempty" tf:"bds_cluster_version_summary,omitempty"`

	// (Updatable) Pre-authenticated URL of the script in Object Store that is downloaded and executed.
	// +kubebuilder:validation:Optional
	BootstrapScriptURL *string `json:"bootstrapScriptUrl,omitempty" tf:"bootstrap_script_url,omitempty"`

	// The information about added Cloud SQL capability
	// +kubebuilder:validation:Optional
	CloudSQLDetails []CloudSQLDetailsParameters `json:"cloudSqlDetails,omitempty" tf:"cloud_sql_details,omitempty"`

	// Base-64 encoded password for the cluster (and Cloudera Manager) admin user.
	// +kubebuilder:validation:Optional
	ClusterAdminPasswordSecretRef v1.SecretKeySelector `json:"clusterAdminPasswordSecretRef" tf:"-"`

	// Profile of the Big Data Service cluster.
	// +kubebuilder:validation:Optional
	ClusterProfile *string `json:"clusterProfile,omitempty" tf:"cluster_profile,omitempty"`

	// The SSH public key used to authenticate the cluster connection.
	// +kubebuilder:validation:Optional
	ClusterPublicKey *string `json:"clusterPublicKey,omitempty" tf:"cluster_public_key,omitempty"`

	// Version of the Hadoop distribution
	// +kubebuilder:validation:Optional
	ClusterVersion *string `json:"clusterVersion,omitempty" tf:"cluster_version,omitempty"`

	// (Updatable) The OCID of the compartment
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// +kubebuilder:validation:Optional
	ComputeOnlyWorkerNode []ComputeOnlyWorkerNodeParameters `json:"computeOnlyWorkerNode,omitempty" tf:"compute_only_worker_node,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Name of the BDS instance
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// +kubebuilder:validation:Optional
	EdgeNode []EdgeNodeParameters `json:"edgeNode,omitempty" tf:"edge_node,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Tag to ignore changing the shape of existing worker, master, utility, compute_only_worker, edge, kafka_broker nodes, in a list format, when new nodes are added with a different shape.
	// +kubebuilder:validation:Optional
	IgnoreExistingNodesShape []*string `json:"ignoreExistingNodesShape,omitempty" tf:"ignore_existing_nodes_shape,omitempty"`

	// (Updatable) Boolean flag specifying whether we configure Cloud SQL or not
	// +kubebuilder:validation:Optional
	IsCloudSQLConfigured *bool `json:"isCloudSqlConfigured,omitempty" tf:"is_cloud_sql_configured,omitempty"`

	// +kubebuilder:validation:Optional
	IsForceRemoveEnabled *bool `json:"isForceRemoveEnabled,omitempty" tf:"is_force_remove_enabled,omitempty"`

	// (Updatable) When setting state as INACTIVE for stopping a cluster, setting this flag to true forcefully stops the bds instance.
	// +kubebuilder:validation:Optional
	IsForceStopJobs *bool `json:"isForceStopJobs,omitempty" tf:"is_force_stop_jobs,omitempty"`

	// Boolean flag specifying whether or not the cluster is HA
	// +kubebuilder:validation:Optional
	IsHighAvailability *bool `json:"isHighAvailability,omitempty" tf:"is_high_availability,omitempty"`

	// Boolean flag specifying whether or not Kafka should be configured.
	// +kubebuilder:validation:Optional
	IsKafkaConfigured *bool `json:"isKafkaConfigured,omitempty" tf:"is_kafka_configured,omitempty"`

	// Boolean flag specifying whether or not the cluster should be setup as secure.
	// +kubebuilder:validation:Optional
	IsSecure *bool `json:"isSecure,omitempty" tf:"is_secure,omitempty"`

	// (Updatable) The OCID of the Key Management master encryption key.
	// +kubebuilder:validation:Optional
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The kafka broker node in the BDS instance
	// +kubebuilder:validation:Optional
	KafkaBrokerNode []KafkaBrokerNodeParameters `json:"kafkaBrokerNode,omitempty" tf:"kafka_broker_node,omitempty"`

	// The user-defined kerberos realm name.
	// +kubebuilder:validation:Optional
	KerberosRealmName *string `json:"kerberosRealmName,omitempty" tf:"kerberos_realm_name,omitempty"`

	// The master node in the BDS instance
	// +kubebuilder:validation:Optional
	MasterNode []MasterNodeParameters `json:"masterNode,omitempty" tf:"master_node,omitempty"`

	// (Updatable) Additional configuration of the user's network.
	// +kubebuilder:validation:Optional
	NetworkConfig []NetworkConfigParameters `json:"networkConfig,omitempty" tf:"network_config,omitempty"`

	// (Updatable) The version of the patch to be upated.
	// +kubebuilder:validation:Optional
	OsPatchVersion *string `json:"osPatchVersion,omitempty" tf:"os_patch_version,omitempty"`

	// (Updatable) An optional property when used triggers Remove Node. Takes the node ocid as input.
	// +kubebuilder:validation:Optional
	RemoveNode *string `json:"removeNode,omitempty" tf:"remove_node,omitempty"`

	// +kubebuilder:validation:Optional
	StartClusterShapeConfigs []StartClusterShapeConfigsParameters `json:"startClusterShapeConfigs,omitempty" tf:"start_cluster_shape_configs,omitempty"`

	// (Updatable) The target state for the Bds Instance. Could be set to ACTIVE or INACTIVE.
	// +kubebuilder:validation:Optional
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The utility node in the BDS instance
	// +kubebuilder:validation:Optional
	UtilNode []UtilNodeParameters `json:"utilNode,omitempty" tf:"util_node,omitempty"`

	// +kubebuilder:validation:Optional
	WorkerNode []WorkerNodeParameters `json:"workerNode,omitempty" tf:"worker_node,omitempty"`
}

type CloudSQLDetailsInitParameters struct {

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`
}

type CloudSQLDetailsObservation struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// IP address of the Cloud SQL node
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// Boolean flag specifying whether or not are Kerberos principals mapped to database users.
	IsKerberosMappedToDatabaseUsers *bool `json:"isKerberosMappedToDatabaseUsers,omitempty" tf:"is_kerberos_mapped_to_database_users,omitempty"`

	// Details about Kerberos principals
	KerberosDetails []KerberosDetailsObservation `json:"kerberosDetails,omitempty" tf:"kerberos_details,omitempty"`

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`
}

type CloudSQLDetailsParameters struct {

	// Shape of the node
	// +kubebuilder:validation:Optional
	Shape *string `json:"shape" tf:"shape,omitempty"`
}

type ClusterDetailsInitParameters struct {
}

type ClusterDetailsObservation struct {

	// The URL of Ambari
	AmbariURL *string `json:"ambariUrl,omitempty" tf:"ambari_url,omitempty"`

	// Cloud SQL cell version.
	BdCellVersion *string `json:"bdCellVersion,omitempty" tf:"bd_cell_version,omitempty"`

	// BDA version installed in the cluster
	BdaVersion *string `json:"bdaVersion,omitempty" tf:"bda_version,omitempty"`

	// Big Data Manager version installed in the cluster.
	BdmVersion *string `json:"bdmVersion,omitempty" tf:"bdm_version,omitempty"`

	// BDS version to be used for cluster creation
	BdsVersion *string `json:"bdsVersion,omitempty" tf:"bds_version,omitempty"`

	// The URL of Big Data Manager.
	BigDataManagerURL *string `json:"bigDataManagerUrl,omitempty" tf:"big_data_manager_url,omitempty"`

	// The URL of Cloudera Manager
	ClouderaManagerURL *string `json:"clouderaManagerUrl,omitempty" tf:"cloudera_manager_url,omitempty"`

	// Big Data SQL version.
	CsqlCellVersion *string `json:"csqlCellVersion,omitempty" tf:"csql_cell_version,omitempty"`

	// Cloud SQL query server database version.
	DBVersion *string `json:"dbVersion,omitempty" tf:"db_version,omitempty"`

	// The URL of the Hue server.
	HueServerURL *string `json:"hueServerUrl,omitempty" tf:"hue_server_url,omitempty"`

	// The URL of the Jupyterhub.
	JupyterHubURL *string `json:"jupyterHubUrl,omitempty" tf:"jupyter_hub_url,omitempty"`

	// ODH version to be used for cluster creation
	OdhVersion *string `json:"odhVersion,omitempty" tf:"odh_version,omitempty"`

	// Oracle Linux version installed in the cluster.
	OsVersion *string `json:"osVersion,omitempty" tf:"os_version,omitempty"`

	// The time the cluster was created, shown as an RFC 3339 formatted datetime string.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The time the cluster was automatically or manually refreshed, shown as an RFC 3339 formatted datetime string.
	TimeRefreshed *string `json:"timeRefreshed,omitempty" tf:"time_refreshed,omitempty"`
}

type ClusterDetailsParameters struct {
}

type ComputeOnlyWorkerNodeInitParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	NumberOfNodes *float64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []ComputeOnlyWorkerNodeShapeConfigInitParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type ComputeOnlyWorkerNodeObservation struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	NumberOfNodes *float64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []ComputeOnlyWorkerNodeShapeConfigObservation `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type ComputeOnlyWorkerNodeParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	// +kubebuilder:validation:Optional
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	// +kubebuilder:validation:Optional
	NumberOfNodes *float64 `json:"numberOfNodes" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	// +kubebuilder:validation:Optional
	Shape *string `json:"shape" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	// +kubebuilder:validation:Optional
	ShapeConfig []ComputeOnlyWorkerNodeShapeConfigParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`
}

type ComputeOnlyWorkerNodeShapeConfigInitParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type ComputeOnlyWorkerNodeShapeConfigObservation struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type ComputeOnlyWorkerNodeShapeConfigParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	// +kubebuilder:validation:Optional
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	// +kubebuilder:validation:Optional
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	// +kubebuilder:validation:Optional
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type EdgeNodeInitParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	NumberOfNodes *float64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []EdgeNodeShapeConfigInitParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type EdgeNodeObservation struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	NumberOfNodes *float64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []EdgeNodeShapeConfigObservation `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type EdgeNodeParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	// +kubebuilder:validation:Optional
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	// +kubebuilder:validation:Optional
	NumberOfNodes *float64 `json:"numberOfNodes" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	// +kubebuilder:validation:Optional
	Shape *string `json:"shape" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	// +kubebuilder:validation:Optional
	ShapeConfig []EdgeNodeShapeConfigParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`
}

type EdgeNodeShapeConfigInitParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type EdgeNodeShapeConfigObservation struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type EdgeNodeShapeConfigParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	// +kubebuilder:validation:Optional
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	// +kubebuilder:validation:Optional
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	// +kubebuilder:validation:Optional
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type KafkaBrokerNodeInitParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The list of nodes in the Big Data Service cluster.
	NumberOfKafkaNodes *float64 `json:"numberOfKafkaNodes,omitempty" tf:"number_of_kafka_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []KafkaBrokerNodeShapeConfigInitParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type KafkaBrokerNodeObservation struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The list of nodes in the Big Data Service cluster.
	NumberOfKafkaNodes *float64 `json:"numberOfKafkaNodes,omitempty" tf:"number_of_kafka_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []KafkaBrokerNodeShapeConfigObservation `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type KafkaBrokerNodeParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	// +kubebuilder:validation:Optional
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The list of nodes in the Big Data Service cluster.
	// +kubebuilder:validation:Optional
	NumberOfKafkaNodes *float64 `json:"numberOfKafkaNodes" tf:"number_of_kafka_nodes,omitempty"`

	// Shape of the node
	// +kubebuilder:validation:Optional
	Shape *string `json:"shape" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	// +kubebuilder:validation:Optional
	ShapeConfig []KafkaBrokerNodeShapeConfigParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`
}

type KafkaBrokerNodeShapeConfigInitParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type KafkaBrokerNodeShapeConfigObservation struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type KafkaBrokerNodeShapeConfigParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	// +kubebuilder:validation:Optional
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	// +kubebuilder:validation:Optional
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	// +kubebuilder:validation:Optional
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type KerberosDetailsInitParameters struct {
}

type KerberosDetailsObservation struct {

	// Location of the keytab file
	KeytabFile *string `json:"keytabFile,omitempty" tf:"keytab_file,omitempty"`

	// Name of the Kerberos principal
	PrincipalName *string `json:"principalName,omitempty" tf:"principal_name,omitempty"`
}

type KerberosDetailsParameters struct {
}

type MasterNodeInitParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	NumberOfNodes *float64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []MasterNodeShapeConfigInitParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type MasterNodeObservation struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	NumberOfNodes *float64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []MasterNodeShapeConfigObservation `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type MasterNodeParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	// +kubebuilder:validation:Optional
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	// +kubebuilder:validation:Optional
	NumberOfNodes *float64 `json:"numberOfNodes" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	// +kubebuilder:validation:Optional
	Shape *string `json:"shape" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	// +kubebuilder:validation:Optional
	ShapeConfig []MasterNodeShapeConfigParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`
}

type MasterNodeShapeConfigInitParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type MasterNodeShapeConfigObservation struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type MasterNodeShapeConfigParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	// +kubebuilder:validation:Optional
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	// +kubebuilder:validation:Optional
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	// +kubebuilder:validation:Optional
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type NetworkConfigInitParameters struct {

	// (Updatable) The CIDR IP address block of the VCN.
	CidrBlock *string `json:"cidrBlock,omitempty" tf:"cidr_block,omitempty"`

	// (Updatable) A boolean flag whether to configure a NAT gateway.
	IsNATGatewayRequired *bool `json:"isNatGatewayRequired,omitempty" tf:"is_nat_gateway_required,omitempty"`
}

type NetworkConfigObservation struct {

	// (Updatable) The CIDR IP address block of the VCN.
	CidrBlock *string `json:"cidrBlock,omitempty" tf:"cidr_block,omitempty"`

	// (Updatable) A boolean flag whether to configure a NAT gateway.
	IsNATGatewayRequired *bool `json:"isNatGatewayRequired,omitempty" tf:"is_nat_gateway_required,omitempty"`
}

type NetworkConfigParameters struct {

	// (Updatable) The CIDR IP address block of the VCN.
	// +kubebuilder:validation:Optional
	CidrBlock *string `json:"cidrBlock,omitempty" tf:"cidr_block,omitempty"`

	// (Updatable) A boolean flag whether to configure a NAT gateway.
	// +kubebuilder:validation:Optional
	IsNATGatewayRequired *bool `json:"isNatGatewayRequired,omitempty" tf:"is_nat_gateway_required,omitempty"`
}

type NodeTypeShapeConfigsInitParameters struct {

	// The Big Data Service cluster node type.
	NodeType *string `json:"nodeType,omitempty" tf:"node_type,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`
}

type NodeTypeShapeConfigsObservation struct {

	// The Big Data Service cluster node type.
	NodeType *string `json:"nodeType,omitempty" tf:"node_type,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`
}

type NodeTypeShapeConfigsParameters struct {

	// The Big Data Service cluster node type.
	// +kubebuilder:validation:Optional
	NodeType *string `json:"nodeType,omitempty" tf:"node_type,omitempty"`

	// Shape of the node
	// +kubebuilder:validation:Optional
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`
}

type NodesInitParameters struct {
}

type NodesObservation struct {

	// The list of block volumes attached to a given node.
	AttachedBlockVolumes []AttachedBlockVolumesObservation `json:"attachedBlockVolumes,omitempty" tf:"attached_block_volumes,omitempty"`

	// The name of the availability domain in which the node is running.
	AvailabilityDomain *string `json:"availabilityDomain,omitempty" tf:"availability_domain,omitempty"`

	// (Updatable) Name of the BDS instance
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The name of the fault domain in which the node is running.
	FaultDomain *string `json:"faultDomain,omitempty" tf:"fault_domain,omitempty"`

	// The fully-qualified hostname (FQDN) of the node.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// IP address of the Cloud SQL node
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// The OCID of the image from which the node was created.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The OCID of the underlying Oracle Cloud Infrastructure Compute instance.
	InstanceID *string `json:"instanceId,omitempty" tf:"instance_id,omitempty"`

	// Indicates if the node requires a reboot to either reflect the latest os kernel or take actions for maintenance reboot.
	IsRebootRequired *bool `json:"isRebootRequired,omitempty" tf:"is_reboot_required,omitempty"`

	// The aggregate size of all local disks, in gigabytes. If the instance does not have any local disks, this field is null.
	LocalDisksTotalSizeInGbs *float64 `json:"localDisksTotalSizeInGbs,omitempty" tf:"local_disks_total_size_in_gbs,omitempty"`

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The Big Data Service cluster node type.
	NodeType *string `json:"nodeType,omitempty" tf:"node_type,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`

	// ODH version to be used for cluster creation
	OdhVersion *string `json:"odhVersion,omitempty" tf:"odh_version,omitempty"`

	// Oracle Linux version installed in the cluster.
	OsVersion *string `json:"osVersion,omitempty" tf:"os_version,omitempty"`

	// The fingerprint of the SSH key used for node access.
	SSHFingerprint *string `json:"sshFingerprint,omitempty" tf:"ssh_fingerprint,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// (Updatable) The target state for the Bds Instance. Could be set to ACTIVE or INACTIVE.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// The time the cluster was created, shown as an RFC 3339 formatted datetime string.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The date and time the instance is expected to be stopped / started, in the format defined by RFC3339.
	TimeMaintenanceRebootDue *string `json:"timeMaintenanceRebootDue,omitempty" tf:"time_maintenance_reboot_due,omitempty"`
}

type NodesParameters struct {
}

type StartClusterShapeConfigsInitParameters struct {
	NodeTypeShapeConfigs []NodeTypeShapeConfigsInitParameters `json:"nodeTypeShapeConfigs,omitempty" tf:"node_type_shape_configs,omitempty"`
}

type StartClusterShapeConfigsObservation struct {
	NodeTypeShapeConfigs []NodeTypeShapeConfigsObservation `json:"nodeTypeShapeConfigs,omitempty" tf:"node_type_shape_configs,omitempty"`
}

type StartClusterShapeConfigsParameters struct {

	// +kubebuilder:validation:Optional
	NodeTypeShapeConfigs []NodeTypeShapeConfigsParameters `json:"nodeTypeShapeConfigs,omitempty" tf:"node_type_shape_configs,omitempty"`
}

type UtilNodeInitParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	NumberOfNodes *float64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []UtilNodeShapeConfigInitParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type UtilNodeObservation struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	NumberOfNodes *float64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []UtilNodeShapeConfigObservation `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type UtilNodeParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	// +kubebuilder:validation:Optional
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	// +kubebuilder:validation:Optional
	NumberOfNodes *float64 `json:"numberOfNodes" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	// +kubebuilder:validation:Optional
	Shape *string `json:"shape" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	// +kubebuilder:validation:Optional
	ShapeConfig []UtilNodeShapeConfigParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`
}

type UtilNodeShapeConfigInitParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type UtilNodeShapeConfigObservation struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type UtilNodeShapeConfigParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	// +kubebuilder:validation:Optional
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	// +kubebuilder:validation:Optional
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	// +kubebuilder:validation:Optional
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type WorkerNodeInitParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	NumberOfNodes *float64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []WorkerNodeShapeConfigInitParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type WorkerNodeObservation struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	NumberOfNodes *float64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	ShapeConfig []WorkerNodeShapeConfigObservation `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type WorkerNodeParameters struct {

	// The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
	// +kubebuilder:validation:Optional
	BlockVolumeSizeInGbs *string `json:"blockVolumeSizeInGbs,omitempty" tf:"block_volume_size_in_gbs,omitempty"`

	// The amount of master nodes should be created.
	// +kubebuilder:validation:Optional
	NumberOfNodes *float64 `json:"numberOfNodes" tf:"number_of_nodes,omitempty"`

	// Shape of the node
	// +kubebuilder:validation:Optional
	Shape *string `json:"shape" tf:"shape,omitempty"`

	// The shape configuration requested for the node.
	// +kubebuilder:validation:Optional
	ShapeConfig []WorkerNodeShapeConfigParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// The OCID of the subnet in which the node will be created.
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`
}

type WorkerNodeShapeConfigInitParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type WorkerNodeShapeConfigObservation struct {

	// The total amount of memory available to the node, in gigabytes.
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type WorkerNodeShapeConfigParameters struct {

	// The total amount of memory available to the node, in gigabytes.
	// +kubebuilder:validation:Optional
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
	// +kubebuilder:validation:Optional
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// The total number of OCPUs available to the node.
	// +kubebuilder:validation:Optional
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

// BigdataserviceInstanceSpec defines the desired state of BigdataserviceInstance
type BigdataserviceInstanceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     BigdataserviceInstanceParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider BigdataserviceInstanceInitParameters `json:"initProvider,omitempty"`
}

// BigdataserviceInstanceStatus defines the observed state of BigdataserviceInstance.
type BigdataserviceInstanceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        BigdataserviceInstanceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// BigdataserviceInstance is the Schema for the BigdataserviceInstances API. Provides the Bds Instance resource in Oracle Cloud Infrastructure Big Data Service service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type BigdataserviceInstance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.clusterAdminPasswordSecretRef)",message="spec.forProvider.clusterAdminPasswordSecretRef is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.clusterPublicKey) || (has(self.initProvider) && has(self.initProvider.clusterPublicKey))",message="spec.forProvider.clusterPublicKey is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.clusterVersion) || (has(self.initProvider) && has(self.initProvider.clusterVersion))",message="spec.forProvider.clusterVersion is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.compartmentId) || (has(self.initProvider) && has(self.initProvider.compartmentId))",message="spec.forProvider.compartmentId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.displayName) || (has(self.initProvider) && has(self.initProvider.displayName))",message="spec.forProvider.displayName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.isHighAvailability) || (has(self.initProvider) && has(self.initProvider.isHighAvailability))",message="spec.forProvider.isHighAvailability is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.isSecure) || (has(self.initProvider) && has(self.initProvider.isSecure))",message="spec.forProvider.isSecure is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.masterNode) || (has(self.initProvider) && has(self.initProvider.masterNode))",message="spec.forProvider.masterNode is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.utilNode) || (has(self.initProvider) && has(self.initProvider.utilNode))",message="spec.forProvider.utilNode is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.workerNode) || (has(self.initProvider) && has(self.initProvider.workerNode))",message="spec.forProvider.workerNode is a required parameter"
	Spec   BigdataserviceInstanceSpec   `json:"spec"`
	Status BigdataserviceInstanceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BigdataserviceInstanceList contains a list of BigdataserviceInstances
type BigdataserviceInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BigdataserviceInstance `json:"items"`
}

// Repository type metadata.
var (
	BigdataserviceInstance_Kind             = "BigdataserviceInstance"
	BigdataserviceInstance_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: BigdataserviceInstance_Kind}.String()
	BigdataserviceInstance_KindAPIVersion   = BigdataserviceInstance_Kind + "." + CRDGroupVersion.String()
	BigdataserviceInstance_GroupVersionKind = CRDGroupVersion.WithKind(BigdataserviceInstance_Kind)
)

func init() {
	SchemeBuilder.Register(&BigdataserviceInstance{}, &BigdataserviceInstanceList{})
}
