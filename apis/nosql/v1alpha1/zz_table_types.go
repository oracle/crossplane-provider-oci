/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ColumnsInitParameters struct {
}

type ColumnsObservation struct {

	// The column default value.
	DefaultValue *string `json:"defaultValue,omitempty" tf:"default_value,omitempty"`

	// True if the STRING column was declared AS UUID.
	IsAsUUID *bool `json:"isAsUuid,omitempty" tf:"is_as_uuid,omitempty"`

	// True if the STRING AS UUID column is also GENERATED BY DEFAULT.
	IsGenerated *bool `json:"isGenerated,omitempty" tf:"is_generated,omitempty"`

	// The column nullable flag.
	IsNullable *bool `json:"isNullable,omitempty" tf:"is_nullable,omitempty"`

	// Table name.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The column type.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ColumnsParameters struct {
}

type IdentityInitParameters struct {
}

type IdentityObservation struct {

	// The name of the identity column.
	ColumnName *string `json:"columnName,omitempty" tf:"column_name,omitempty"`

	// True if the identity value is GENERATED ALWAYS.
	IsAlways *bool `json:"isAlways,omitempty" tf:"is_always,omitempty"`

	// True if the identity value is GENERATED BY DEFAULT ON NULL.
	IsNull *bool `json:"isNull,omitempty" tf:"is_null,omitempty"`
}

type IdentityParameters struct {
}

type ReplicasInitParameters struct {
}

type ReplicasObservation struct {

	// (Updatable) The capacity mode of the table.  If capacityMode = ON_DEMAND, maxReadUnits and maxWriteUnits are not used, and both will have the value of zero.
	CapacityMode *string `json:"capacityMode,omitempty" tf:"capacity_mode,omitempty"`

	// A message describing the current state in more detail.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// (Updatable) Maximum sustained write throughput limit for the table.
	MaxWriteUnits *float64 `json:"maxWriteUnits,omitempty" tf:"max_write_units,omitempty"`

	// A customer-facing region identifier
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The state of the replica.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The OCID of the replica table
	TableID *string `json:"tableId,omitempty" tf:"table_id,omitempty"`
}

type ReplicasParameters struct {
}

type SchemaInitParameters struct {
}

type SchemaObservation struct {

	// The columns of a table.
	Columns []ColumnsObservation `json:"columns,omitempty" tf:"columns,omitempty"`

	// The identity properties of a table, if any.
	Identity []IdentityObservation `json:"identity,omitempty" tf:"identity,omitempty"`

	// A list of column names that make up a key.
	PrimaryKey []*string `json:"primaryKey,omitempty" tf:"primary_key,omitempty"`

	// A list of column names that make up a key.
	ShardKey []*string `json:"shardKey,omitempty" tf:"shard_key,omitempty"`

	// The default Time-to-Live for the table, in days.
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type SchemaParameters struct {
}

type TableInitParameters struct {

	// (Updatable) Compartment Identifier.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
	DdlStatement *string `json:"ddlStatement,omitempty" tf:"ddl_statement,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: {"foo-namespace": {"bar-key": "value"}}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// True if table can be reclaimed after an idle period.
	IsAutoReclaimable *bool `json:"isAutoReclaimable,omitempty" tf:"is_auto_reclaimable,omitempty"`

	// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
	TableLimits []TableLimitsInitParameters `json:"tableLimits,omitempty" tf:"table_limits,omitempty"`
}

type TableLimitsInitParameters struct {

	// (Updatable) The capacity mode of the table.  If capacityMode = ON_DEMAND, maxReadUnits and maxWriteUnits are not used, and both will have the value of zero.
	CapacityMode *string `json:"capacityMode,omitempty" tf:"capacity_mode,omitempty"`

	// (Updatable) Maximum sustained read throughput limit for the table.
	MaxReadUnits *float64 `json:"maxReadUnits,omitempty" tf:"max_read_units,omitempty"`

	// (Updatable) Maximum size of storage used by the table.
	MaxStorageInGbs *float64 `json:"maxStorageInGbs,omitempty" tf:"max_storage_in_gbs,omitempty"`

	// (Updatable) Maximum sustained write throughput limit for the table.
	MaxWriteUnits *float64 `json:"maxWriteUnits,omitempty" tf:"max_write_units,omitempty"`
}

type TableLimitsObservation struct {

	// (Updatable) The capacity mode of the table.  If capacityMode = ON_DEMAND, maxReadUnits and maxWriteUnits are not used, and both will have the value of zero.
	CapacityMode *string `json:"capacityMode,omitempty" tf:"capacity_mode,omitempty"`

	// (Updatable) Maximum sustained read throughput limit for the table.
	MaxReadUnits *float64 `json:"maxReadUnits,omitempty" tf:"max_read_units,omitempty"`

	// (Updatable) Maximum size of storage used by the table.
	MaxStorageInGbs *float64 `json:"maxStorageInGbs,omitempty" tf:"max_storage_in_gbs,omitempty"`

	// (Updatable) Maximum sustained write throughput limit for the table.
	MaxWriteUnits *float64 `json:"maxWriteUnits,omitempty" tf:"max_write_units,omitempty"`
}

type TableLimitsParameters struct {

	// (Updatable) The capacity mode of the table.  If capacityMode = ON_DEMAND, maxReadUnits and maxWriteUnits are not used, and both will have the value of zero.
	// +kubebuilder:validation:Optional
	CapacityMode *string `json:"capacityMode,omitempty" tf:"capacity_mode,omitempty"`

	// (Updatable) Maximum sustained read throughput limit for the table.
	// +kubebuilder:validation:Optional
	MaxReadUnits *float64 `json:"maxReadUnits" tf:"max_read_units,omitempty"`

	// (Updatable) Maximum size of storage used by the table.
	// +kubebuilder:validation:Optional
	MaxStorageInGbs *float64 `json:"maxStorageInGbs" tf:"max_storage_in_gbs,omitempty"`

	// (Updatable) Maximum sustained write throughput limit for the table.
	// +kubebuilder:validation:Optional
	MaxWriteUnits *float64 `json:"maxWriteUnits" tf:"max_write_units,omitempty"`
}

type TableObservation struct {

	// (Updatable) Compartment Identifier.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
	DdlStatement *string `json:"ddlStatement,omitempty" tf:"ddl_statement,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: {"foo-namespace": {"bar-key": "value"}}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Unique identifier that is immutable.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// True if table can be reclaimed after an idle period.
	IsAutoReclaimable *bool `json:"isAutoReclaimable,omitempty" tf:"is_auto_reclaimable,omitempty"`

	// True if this table is currently a member of a replication set.
	IsMultiRegion *bool `json:"isMultiRegion,omitempty" tf:"is_multi_region,omitempty"`

	// A message describing the current state in more detail.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// If this table is in a replication set, this value represents the progress of the initialization of the replica's data.  A value of 100 indicates that initialization has completed.
	LocalReplicaInitializationInPercent *float64 `json:"localReplicaInitializationInPercent,omitempty" tf:"local_replica_initialization_in_percent,omitempty"`

	// An array of Replica listing this table's replicas, if any
	Replicas []ReplicasObservation `json:"replicas,omitempty" tf:"replicas,omitempty"`

	// The table schema information as a JSON object.
	Schema []SchemaObservation `json:"schema,omitempty" tf:"schema,omitempty"`

	// The current state of this table's schema. Available states are MUTABLE - The schema can be changed. The table is not eligible for replication. FROZEN - The schema is immutable. The table is eligible for replication.
	SchemaState *string `json:"schemaState,omitempty" tf:"schema_state,omitempty"`

	// The state of the replica.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Read-only system tag. These predefined keys are scoped to namespaces.  At present the only supported namespace is "orcl-cloud"; and the only key in that namespace is "free-tier-retained". Example: {"orcl-cloud"": {"free-tier-retained": "true"}}
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
	TableLimits []TableLimitsObservation `json:"tableLimits,omitempty" tf:"table_limits,omitempty"`

	// The time the the table was created. An RFC3339 formatted datetime string.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// If lifecycleState is INACTIVE, indicates when this table will be automatically removed. An RFC3339 formatted datetime string.
	TimeOfExpiration *string `json:"timeOfExpiration,omitempty" tf:"time_of_expiration,omitempty"`

	// The time the the table's metadata was last updated. An RFC3339 formatted datetime string.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`
}

type TableParameters struct {

	// (Updatable) Compartment Identifier.
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
	// +kubebuilder:validation:Optional
	DdlStatement *string `json:"ddlStatement,omitempty" tf:"ddl_statement,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: {"foo-namespace": {"bar-key": "value"}}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// True if table can be reclaimed after an idle period.
	// +kubebuilder:validation:Optional
	IsAutoReclaimable *bool `json:"isAutoReclaimable,omitempty" tf:"is_auto_reclaimable,omitempty"`

	// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
	// +kubebuilder:validation:Optional
	TableLimits []TableLimitsParameters `json:"tableLimits,omitempty" tf:"table_limits,omitempty"`
}

// TableSpec defines the desired state of Table
type TableSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TableParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider TableInitParameters `json:"initProvider,omitempty"`
}

// TableStatus defines the observed state of Table.
type TableStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TableObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Table is the Schema for the Tables API. Provides the Table resource in Oracle Cloud Infrastructure NoSQL Database service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type Table struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.compartmentId) || (has(self.initProvider) && has(self.initProvider.compartmentId))",message="spec.forProvider.compartmentId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.ddlStatement) || (has(self.initProvider) && has(self.initProvider.ddlStatement))",message="spec.forProvider.ddlStatement is a required parameter"
	Spec   TableSpec   `json:"spec"`
	Status TableStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TableList contains a list of Tables
type TableList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Table `json:"items"`
}

// Repository type metadata.
var (
	Table_Kind             = "Table"
	Table_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Table_Kind}.String()
	Table_KindAPIVersion   = Table_Kind + "." + CRDGroupVersion.String()
	Table_GroupVersionKind = CRDGroupVersion.WithKind(Table_Kind)
)

func init() {
	SchemeBuilder.Register(&Table{}, &TableList{})
}
