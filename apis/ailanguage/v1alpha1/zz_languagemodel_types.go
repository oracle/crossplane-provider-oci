/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ClassMetricsInitParameters struct {
}

type ClassMetricsObservation struct {

	// F1-score, is a measure of a model’s accuracy on a dataset
	F1 *float64 `json:"f1,omitempty" tf:"f1,omitempty"`

	// Text classification label
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
	Precision *float64 `json:"precision,omitempty" tf:"precision,omitempty"`

	// Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
	Recall *float64 `json:"recall,omitempty" tf:"recall,omitempty"`

	// number of samples in the test set
	Support *float64 `json:"support,omitempty" tf:"support,omitempty"`
}

type ClassMetricsParameters struct {
}

type ClassificationModeInitParameters struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	ClassificationMode *string `json:"classificationMode,omitempty" tf:"classification_mode,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ClassificationModeObservation struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	ClassificationMode *string `json:"classificationMode,omitempty" tf:"classification_mode,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ClassificationModeParameters struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	// +kubebuilder:validation:Optional
	ClassificationMode *string `json:"classificationMode" tf:"classification_mode,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type EntityMetricsInitParameters struct {
}

type EntityMetricsObservation struct {

	// F1-score, is a measure of a model’s accuracy on a dataset
	F1 *float64 `json:"f1,omitempty" tf:"f1,omitempty"`

	// Text classification label
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
	Precision *float64 `json:"precision,omitempty" tf:"precision,omitempty"`

	// Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
	Recall *float64 `json:"recall,omitempty" tf:"recall,omitempty"`
}

type EntityMetricsParameters struct {
}

type EvaluationResultsInitParameters struct {
}

type EvaluationResultsMetricsInitParameters struct {
}

type EvaluationResultsMetricsObservation struct {

	// The fraction of the labels that were correctly recognised .
	Accuracy *float64 `json:"accuracy,omitempty" tf:"accuracy,omitempty"`

	// F1-score, is a measure of a model’s accuracy on a dataset
	MacroF1 *float64 `json:"macroF1,omitempty" tf:"macro_f1,omitempty"`

	// Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
	MacroPrecision *float64 `json:"macroPrecision,omitempty" tf:"macro_precision,omitempty"`

	// Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
	MacroRecall *float64 `json:"macroRecall,omitempty" tf:"macro_recall,omitempty"`

	// F1-score, is a measure of a model’s accuracy on a dataset
	MicroF1 *float64 `json:"microF1,omitempty" tf:"micro_f1,omitempty"`

	// Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
	MicroPrecision *float64 `json:"microPrecision,omitempty" tf:"micro_precision,omitempty"`

	// Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
	MicroRecall *float64 `json:"microRecall,omitempty" tf:"micro_recall,omitempty"`

	// F1-score, is a measure of a model’s accuracy on a dataset
	WeightedF1 *float64 `json:"weightedF1,omitempty" tf:"weighted_f1,omitempty"`

	// Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
	WeightedPrecision *float64 `json:"weightedPrecision,omitempty" tf:"weighted_precision,omitempty"`

	// Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
	WeightedRecall *float64 `json:"weightedRecall,omitempty" tf:"weighted_recall,omitempty"`
}

type EvaluationResultsMetricsParameters struct {
}

type EvaluationResultsObservation struct {

	// List of text classification metrics
	ClassMetrics []ClassMetricsObservation `json:"classMetrics,omitempty" tf:"class_metrics,omitempty"`

	// class level confusion matrix
	ConfusionMatrix *string `json:"confusionMatrix,omitempty" tf:"confusion_matrix,omitempty"`

	// List of entity metrics
	EntityMetrics []EntityMetricsObservation `json:"entityMetrics,omitempty" tf:"entity_metrics,omitempty"`

	// labels
	Labels []*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Model level named entity recognition metrics
	Metrics []EvaluationResultsMetricsObservation `json:"metrics,omitempty" tf:"metrics,omitempty"`

	// Model type
	ModelType *string `json:"modelType,omitempty" tf:"model_type,omitempty"`
}

type EvaluationResultsParameters struct {
}

type LanguageModelInitParameters struct {

	// (Updatable) The OCID  for the models compartment.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A short description of the a model.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name for the resource. It does not have to be unique and can be modified. Avoid entering confidential information.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Possible model types
	ModelDetails []ModelDetailsInitParameters `json:"modelDetails,omitempty" tf:"model_details,omitempty"`

	// The OCID of the project to associate with the model.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Possible strategy as testing and validation dataset.
	TestStrategy []TestStrategyInitParameters `json:"testStrategy,omitempty" tf:"test_strategy,omitempty"`

	// Possible data set type
	TrainingDataset []LanguageModelTrainingDatasetInitParameters `json:"trainingDataset,omitempty" tf:"training_dataset,omitempty"`
}

type LanguageModelObservation struct {

	// (Updatable) The OCID  for the models compartment.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A short description of the a model.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name for the resource. It does not have to be unique and can be modified. Avoid entering confidential information.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// model training results of different models
	EvaluationResults []EvaluationResultsObservation `json:"evaluationResults,omitempty" tf:"evaluation_results,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Unique identifier model OCID of a model that is immutable on creation
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in failed state.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// Possible model types
	ModelDetails []ModelDetailsObservation `json:"modelDetails,omitempty" tf:"model_details,omitempty"`

	// The OCID of the project to associate with the model.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// The state of the model.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Usage of system tag keys. These predefined keys are scoped to namespaces. Example: {"orcl-cloud.free-tier-retained": "true"}
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// Possible strategy as testing and validation dataset.
	TestStrategy []TestStrategyObservation `json:"testStrategy,omitempty" tf:"test_strategy,omitempty"`

	// The time the the model was created. An RFC3339 formatted datetime string.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The time the model was updated. An RFC3339 formatted datetime string.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`

	// Possible data set type
	TrainingDataset []LanguageModelTrainingDatasetObservation `json:"trainingDataset,omitempty" tf:"training_dataset,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type LanguageModelParameters struct {

	// (Updatable) The OCID  for the models compartment.
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A short description of the a model.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) A user-friendly display name for the resource. It does not have to be unique and can be modified. Avoid entering confidential information.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Possible model types
	// +kubebuilder:validation:Optional
	ModelDetails []ModelDetailsParameters `json:"modelDetails,omitempty" tf:"model_details,omitempty"`

	// The OCID of the project to associate with the model.
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Possible strategy as testing and validation dataset.
	// +kubebuilder:validation:Optional
	TestStrategy []TestStrategyParameters `json:"testStrategy,omitempty" tf:"test_strategy,omitempty"`

	// Possible data set type
	// +kubebuilder:validation:Optional
	TrainingDataset []LanguageModelTrainingDatasetParameters `json:"trainingDataset,omitempty" tf:"training_dataset,omitempty"`
}

type LanguageModelTrainingDatasetInitParameters struct {

	// Data Science Labelling Service OCID
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []TrainingDatasetLocationDetailsInitParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type LanguageModelTrainingDatasetObservation struct {

	// Data Science Labelling Service OCID
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []TrainingDatasetLocationDetailsObservation `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type LanguageModelTrainingDatasetParameters struct {

	// Data Science Labelling Service OCID
	// +kubebuilder:validation:Optional
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	// +kubebuilder:validation:Optional
	DatasetType *string `json:"datasetType" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationDetails []TrainingDatasetLocationDetailsParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type LocationDetailsInitParameters struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type LocationDetailsObservation struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type LocationDetailsParameters struct {

	// Object storage bucket name
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationType *string `json:"locationType" tf:"location_type,omitempty"`

	// Object storage namespace
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	// +kubebuilder:validation:Optional
	ObjectNames []*string `json:"objectNames" tf:"object_names,omitempty"`
}

type ModelDetailsInitParameters struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	ClassificationMode []ClassificationModeInitParameters `json:"classificationMode,omitempty" tf:"classification_mode,omitempty"`

	// supported language default value is en
	LanguageCode *string `json:"languageCode,omitempty" tf:"language_code,omitempty"`

	// Model type
	ModelType *string `json:"modelType,omitempty" tf:"model_type,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ModelDetailsObservation struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	ClassificationMode []ClassificationModeObservation `json:"classificationMode,omitempty" tf:"classification_mode,omitempty"`

	// supported language default value is en
	LanguageCode *string `json:"languageCode,omitempty" tf:"language_code,omitempty"`

	// Model type
	ModelType *string `json:"modelType,omitempty" tf:"model_type,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ModelDetailsParameters struct {

	// (Applicable when model_type=TEXT_CLASSIFICATION) possible text classification modes
	// +kubebuilder:validation:Optional
	ClassificationMode []ClassificationModeParameters `json:"classificationMode,omitempty" tf:"classification_mode,omitempty"`

	// supported language default value is en
	// +kubebuilder:validation:Optional
	LanguageCode *string `json:"languageCode,omitempty" tf:"language_code,omitempty"`

	// Model type
	// +kubebuilder:validation:Optional
	ModelType *string `json:"modelType" tf:"model_type,omitempty"`

	// Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type TestStrategyInitParameters struct {

	// This information will define the test strategy different datasets for test and validation dataset.
	StrategyType *string `json:"strategyType,omitempty" tf:"strategy_type,omitempty"`

	// Possible data set type
	TestingDataset []TestStrategyTestingDatasetInitParameters `json:"testingDataset,omitempty" tf:"testing_dataset,omitempty"`

	// Possible data set type
	ValidationDataset []TestStrategyValidationDatasetInitParameters `json:"validationDataset,omitempty" tf:"validation_dataset,omitempty"`
}

type TestStrategyObservation struct {

	// This information will define the test strategy different datasets for test and validation dataset.
	StrategyType *string `json:"strategyType,omitempty" tf:"strategy_type,omitempty"`

	// Possible data set type
	TestingDataset []TestStrategyTestingDatasetObservation `json:"testingDataset,omitempty" tf:"testing_dataset,omitempty"`

	// Possible data set type
	ValidationDataset []TestStrategyValidationDatasetObservation `json:"validationDataset,omitempty" tf:"validation_dataset,omitempty"`
}

type TestStrategyParameters struct {

	// This information will define the test strategy different datasets for test and validation dataset.
	// +kubebuilder:validation:Optional
	StrategyType *string `json:"strategyType" tf:"strategy_type,omitempty"`

	// Possible data set type
	// +kubebuilder:validation:Optional
	TestingDataset []TestStrategyTestingDatasetParameters `json:"testingDataset" tf:"testing_dataset,omitempty"`

	// Possible data set type
	// +kubebuilder:validation:Optional
	ValidationDataset []TestStrategyValidationDatasetParameters `json:"validationDataset,omitempty" tf:"validation_dataset,omitempty"`
}

type TestStrategyTestingDatasetInitParameters struct {

	// Data Science Labelling Service OCID
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []LocationDetailsInitParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type TestStrategyTestingDatasetObservation struct {

	// Data Science Labelling Service OCID
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []LocationDetailsObservation `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type TestStrategyTestingDatasetParameters struct {

	// Data Science Labelling Service OCID
	// +kubebuilder:validation:Optional
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	// +kubebuilder:validation:Optional
	DatasetType *string `json:"datasetType" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationDetails []LocationDetailsParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type TestStrategyValidationDatasetInitParameters struct {

	// Data Science Labelling Service OCID
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []ValidationDatasetLocationDetailsInitParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type TestStrategyValidationDatasetObservation struct {

	// Data Science Labelling Service OCID
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	DatasetType *string `json:"datasetType,omitempty" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	LocationDetails []ValidationDatasetLocationDetailsObservation `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type TestStrategyValidationDatasetParameters struct {

	// Data Science Labelling Service OCID
	// +kubebuilder:validation:Optional
	DatasetID *string `json:"datasetId,omitempty" tf:"dataset_id,omitempty"`

	// Possible data sets
	// +kubebuilder:validation:Optional
	DatasetType *string `json:"datasetType" tf:"dataset_type,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationDetails []ValidationDatasetLocationDetailsParameters `json:"locationDetails,omitempty" tf:"location_details,omitempty"`
}

type TrainingDatasetLocationDetailsInitParameters struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type TrainingDatasetLocationDetailsObservation struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type TrainingDatasetLocationDetailsParameters struct {

	// Object storage bucket name
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationType *string `json:"locationType" tf:"location_type,omitempty"`

	// Object storage namespace
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	// +kubebuilder:validation:Optional
	ObjectNames []*string `json:"objectNames" tf:"object_names,omitempty"`
}

type ValidationDatasetLocationDetailsInitParameters struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type ValidationDatasetLocationDetailsObservation struct {

	// Object storage bucket name
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// Possible object storage location types
	LocationType *string `json:"locationType,omitempty" tf:"location_type,omitempty"`

	// Object storage namespace
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	ObjectNames []*string `json:"objectNames,omitempty" tf:"object_names,omitempty"`
}

type ValidationDatasetLocationDetailsParameters struct {

	// Object storage bucket name
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// Possible object storage location types
	// +kubebuilder:validation:Optional
	LocationType *string `json:"locationType" tf:"location_type,omitempty"`

	// Object storage namespace
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// Array of files which need to be processed in the bucket
	// +kubebuilder:validation:Optional
	ObjectNames []*string `json:"objectNames" tf:"object_names,omitempty"`
}

// LanguageModelSpec defines the desired state of LanguageModel
type LanguageModelSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LanguageModelParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider LanguageModelInitParameters `json:"initProvider,omitempty"`
}

// LanguageModelStatus defines the observed state of LanguageModel.
type LanguageModelStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LanguageModelObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// LanguageModel is the Schema for the LanguageModels API. Provides the Model resource in Oracle Cloud Infrastructure Ai Language service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type LanguageModel struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.compartmentId) || (has(self.initProvider) && has(self.initProvider.compartmentId))",message="spec.forProvider.compartmentId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.modelDetails) || (has(self.initProvider) && has(self.initProvider.modelDetails))",message="spec.forProvider.modelDetails is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.projectId) || (has(self.initProvider) && has(self.initProvider.projectId))",message="spec.forProvider.projectId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.trainingDataset) || (has(self.initProvider) && has(self.initProvider.trainingDataset))",message="spec.forProvider.trainingDataset is a required parameter"
	Spec   LanguageModelSpec   `json:"spec"`
	Status LanguageModelStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LanguageModelList contains a list of LanguageModels
type LanguageModelList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LanguageModel `json:"items"`
}

// Repository type metadata.
var (
	LanguageModel_Kind             = "LanguageModel"
	LanguageModel_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LanguageModel_Kind}.String()
	LanguageModel_KindAPIVersion   = LanguageModel_Kind + "." + CRDGroupVersion.String()
	LanguageModel_GroupVersionKind = CRDGroupVersion.WithKind(LanguageModel_Kind)
)

func init() {
	SchemeBuilder.Register(&LanguageModel{}, &LanguageModelList{})
}
