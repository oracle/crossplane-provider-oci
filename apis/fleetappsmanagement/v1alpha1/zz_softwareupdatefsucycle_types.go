/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApplyActionScheduleInitParameters struct {

	// The date and time the Exadata Fleet Update Action is expected to start. RFC 3339, section 14.29.
	TimeToStart *string `json:"timeToStart,omitempty" tf:"time_to_start,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ApplyActionScheduleObservation struct {

	// The date and time the Exadata Fleet Update Action is expected to start. RFC 3339, section 14.29.
	TimeToStart *string `json:"timeToStart,omitempty" tf:"time_to_start,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ApplyActionScheduleParameters struct {

	// The date and time the Exadata Fleet Update Action is expected to start. RFC 3339, section 14.29.
	// +kubebuilder:validation:Optional
	TimeToStart *string `json:"timeToStart" tf:"time_to_start,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type BatchingStrategyInitParameters struct {

	// (Applicable when type=FIFTY_FIFTY | SEQUENTIAL | SERVICE_AVAILABILITY_FACTOR) (Updatable) True to force rolling patching.
	IsForceRolling *bool `json:"isForceRolling,omitempty" tf:"is_force_rolling,omitempty"`

	// (Applicable when type=FIFTY_FIFTY) (Updatable) True to wait for customer to resume the Apply Action once the first half is done. False to automatically patch the second half.
	IsWaitForBatchResume *bool `json:"isWaitForBatchResume,omitempty" tf:"is_wait_for_batch_resume,omitempty"`

	// (Applicable when type=SERVICE_AVAILABILITY_FACTOR) (Updatable) Percentage of availability in the service during the Patch operation.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type BatchingStrategyObservation struct {

	// (Applicable when type=FIFTY_FIFTY | SEQUENTIAL | SERVICE_AVAILABILITY_FACTOR) (Updatable) True to force rolling patching.
	IsForceRolling *bool `json:"isForceRolling,omitempty" tf:"is_force_rolling,omitempty"`

	// (Applicable when type=FIFTY_FIFTY) (Updatable) True to wait for customer to resume the Apply Action once the first half is done. False to automatically patch the second half.
	IsWaitForBatchResume *bool `json:"isWaitForBatchResume,omitempty" tf:"is_wait_for_batch_resume,omitempty"`

	// (Applicable when type=SERVICE_AVAILABILITY_FACTOR) (Updatable) Percentage of availability in the service during the Patch operation.
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type BatchingStrategyParameters struct {

	// (Applicable when type=FIFTY_FIFTY | SEQUENTIAL | SERVICE_AVAILABILITY_FACTOR) (Updatable) True to force rolling patching.
	// +kubebuilder:validation:Optional
	IsForceRolling *bool `json:"isForceRolling,omitempty" tf:"is_force_rolling,omitempty"`

	// (Applicable when type=FIFTY_FIFTY) (Updatable) True to wait for customer to resume the Apply Action once the first half is done. False to automatically patch the second half.
	// +kubebuilder:validation:Optional
	IsWaitForBatchResume *bool `json:"isWaitForBatchResume,omitempty" tf:"is_wait_for_batch_resume,omitempty"`

	// (Applicable when type=SERVICE_AVAILABILITY_FACTOR) (Updatable) Percentage of availability in the service during the Patch operation.
	// +kubebuilder:validation:Optional
	Percentage *float64 `json:"percentage,omitempty" tf:"percentage,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type DiagnosticsCollectionInitParameters struct {

	// (Updatable) Enable incident logs and trace collection.  Allow Oracle to collect incident logs and traces to enable fault diagnosis and issue resolution according to the selected mode.
	LogCollectionMode *string `json:"logCollectionMode,omitempty" tf:"log_collection_mode,omitempty"`
}

type DiagnosticsCollectionObservation struct {

	// (Updatable) Enable incident logs and trace collection.  Allow Oracle to collect incident logs and traces to enable fault diagnosis and issue resolution according to the selected mode.
	LogCollectionMode *string `json:"logCollectionMode,omitempty" tf:"log_collection_mode,omitempty"`
}

type DiagnosticsCollectionParameters struct {

	// (Updatable) Enable incident logs and trace collection.  Allow Oracle to collect incident logs and traces to enable fault diagnosis and issue resolution according to the selected mode.
	// +kubebuilder:validation:Optional
	LogCollectionMode *string `json:"logCollectionMode,omitempty" tf:"log_collection_mode,omitempty"`
}

type GoalVersionDetailsInitParameters struct {

	// (Updatable) Goal home policy to use when Staging the Goal Version during patching. CREATE_NEW: Create a new DBHome (for Database Collections) for the specified image or version. USE_EXISTING: All database targets in the same VMCluster or CloudVmCluster will be moved to a shared database home.  If an existing home for the selected image or version is not found in the VM Cluster for a target database, then a new home will be created.  If more than one existing home for the selected image is found, then the home with the least number of databases will be used.  If multiple homes have the least number of databases, then a home will be selected at random.
	HomePolicy *string `json:"homePolicy,omitempty" tf:"home_policy,omitempty"`

	// (Updatable) Prefix name used for new DB home resources created as part of the Stage Action. Format: <specified_prefix>_ If not specified, a default Oracle Cloud Infrastructure DB home resource will be generated for the new DB home resources created.
	NewHomePrefix *string `json:"newHomePrefix,omitempty" tf:"new_home_prefix,omitempty"`

	// (Updatable) Target database software image OCID.
	SoftwareImageID *string `json:"softwareImageId,omitempty" tf:"software_image_id,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Updatable) Target DB or GI version string for the Exadata Fleet Update Cycle.
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type GoalVersionDetailsObservation struct {

	// (Updatable) Goal home policy to use when Staging the Goal Version during patching. CREATE_NEW: Create a new DBHome (for Database Collections) for the specified image or version. USE_EXISTING: All database targets in the same VMCluster or CloudVmCluster will be moved to a shared database home.  If an existing home for the selected image or version is not found in the VM Cluster for a target database, then a new home will be created.  If more than one existing home for the selected image is found, then the home with the least number of databases will be used.  If multiple homes have the least number of databases, then a home will be selected at random.
	HomePolicy *string `json:"homePolicy,omitempty" tf:"home_policy,omitempty"`

	// (Updatable) Prefix name used for new DB home resources created as part of the Stage Action. Format: <specified_prefix>_ If not specified, a default Oracle Cloud Infrastructure DB home resource will be generated for the new DB home resources created.
	NewHomePrefix *string `json:"newHomePrefix,omitempty" tf:"new_home_prefix,omitempty"`

	// (Updatable) Target database software image OCID.
	SoftwareImageID *string `json:"softwareImageId,omitempty" tf:"software_image_id,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Updatable) Target DB or GI version string for the Exadata Fleet Update Cycle.
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type GoalVersionDetailsParameters struct {

	// (Updatable) Goal home policy to use when Staging the Goal Version during patching. CREATE_NEW: Create a new DBHome (for Database Collections) for the specified image or version. USE_EXISTING: All database targets in the same VMCluster or CloudVmCluster will be moved to a shared database home.  If an existing home for the selected image or version is not found in the VM Cluster for a target database, then a new home will be created.  If more than one existing home for the selected image is found, then the home with the least number of databases will be used.  If multiple homes have the least number of databases, then a home will be selected at random.
	// +kubebuilder:validation:Optional
	HomePolicy *string `json:"homePolicy,omitempty" tf:"home_policy,omitempty"`

	// (Updatable) Prefix name used for new DB home resources created as part of the Stage Action. Format: <specified_prefix>_ If not specified, a default Oracle Cloud Infrastructure DB home resource will be generated for the new DB home resources created.
	// +kubebuilder:validation:Optional
	NewHomePrefix *string `json:"newHomePrefix,omitempty" tf:"new_home_prefix,omitempty"`

	// (Updatable) Target database software image OCID.
	// +kubebuilder:validation:Optional
	SoftwareImageID *string `json:"softwareImageId,omitempty" tf:"software_image_id,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`

	// (Updatable) Target DB or GI version string for the Exadata Fleet Update Cycle.
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type NextActionToExecuteInitParameters struct {
}

type NextActionToExecuteObservation struct {

	// The date and time the Exadata Fleet Update Action is expected to start. RFC 3339, section 14.29.
	TimeToStart *string `json:"timeToStart,omitempty" tf:"time_to_start,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type NextActionToExecuteParameters struct {
}

type SoftwareUpdateFsuCycleInitParameters struct {

	// Scheduling related details for the Exadata Fleet Update Action during create operations. The specified time should not conflict with existing Exadata Infrastructure maintenance windows. Null scheduleDetails for Stage and Apply Actions in Exadata Fleet Update Cycle creation would not create Actions. Null scheduleDetails for CreateAction would execute the Exadata Fleet Update Action as soon as possible.
	ApplyActionSchedule []ApplyActionScheduleInitParameters `json:"applyActionSchedule,omitempty" tf:"apply_action_schedule,omitempty"`

	// (Updatable) Batching strategy details to use during PRECHECK and APPLY Cycle Actions.
	BatchingStrategy []BatchingStrategyInitParameters `json:"batchingStrategy,omitempty" tf:"batching_strategy,omitempty"`

	// (Updatable) Compartment Identifier.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Details to configure diagnostics collection for targets affected by this Exadata Fleet Update Maintenance Cycle.
	DiagnosticsCollection []DiagnosticsCollectionInitParameters `json:"diagnosticsCollection,omitempty" tf:"diagnostics_collection,omitempty"`

	// (Updatable) Exadata Fleet Update Cycle display name.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// OCID identifier for the Collection ID the Exadata Fleet Update Cycle will be assigned to.
	FsuCollectionID *string `json:"fsuCollectionId,omitempty" tf:"fsu_collection_id,omitempty"`

	// (Updatable) Goal version or image details for the Exadata Fleet Update Cycle.
	GoalVersionDetails []GoalVersionDetailsInitParameters `json:"goalVersionDetails,omitempty" tf:"goal_version_details,omitempty"`

	// (Applicable when type=PATCH) (Updatable) List of patch IDs to ignore.
	IsIgnoreMissingPatches []*string `json:"isIgnoreMissingPatches,omitempty" tf:"is_ignore_missing_patches,omitempty"`

	// (Applicable when type=PATCH) (Updatable) Ignore all patches between the source and target homes during patching.
	IsIgnorePatches *bool `json:"isIgnorePatches,omitempty" tf:"is_ignore_patches,omitempty"`

	// (Applicable when type=PATCH) (Updatable) Ensure that services of administrator-managed Oracle RAC or Oracle RAC One databases are running on the same instances before and after the move operation.
	IsKeepPlacement *bool `json:"isKeepPlacement,omitempty" tf:"is_keep_placement,omitempty"`

	// (Applicable when type=PATCH) (Updatable) Service drain timeout specified in seconds.
	MaxDrainTimeoutInSeconds *float64 `json:"maxDrainTimeoutInSeconds,omitempty" tf:"max_drain_timeout_in_seconds,omitempty"`

	// Scheduling related details for the Exadata Fleet Update Action during create operations. The specified time should not conflict with existing Exadata Infrastructure maintenance windows. Null scheduleDetails for Stage and Apply Actions in Exadata Fleet Update Cycle creation would not create Actions. Null scheduleDetails for CreateAction would execute the Exadata Fleet Update Action as soon as possible.
	StageActionSchedule []StageActionScheduleInitParameters `json:"stageActionSchedule,omitempty" tf:"stage_action_schedule,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Applicable when type=UPGRADE) (Updatable) Details of supported upgrade options for DB or GI collection.
	UpgradeDetails []UpgradeDetailsInitParameters `json:"upgradeDetails,omitempty" tf:"upgrade_details,omitempty"`
}

type SoftwareUpdateFsuCycleObservation struct {

	// Scheduling related details for the Exadata Fleet Update Action during create operations. The specified time should not conflict with existing Exadata Infrastructure maintenance windows. Null scheduleDetails for Stage and Apply Actions in Exadata Fleet Update Cycle creation would not create Actions. Null scheduleDetails for CreateAction would execute the Exadata Fleet Update Action as soon as possible.
	ApplyActionSchedule []ApplyActionScheduleObservation `json:"applyActionSchedule,omitempty" tf:"apply_action_schedule,omitempty"`

	// (Updatable) Batching strategy details to use during PRECHECK and APPLY Cycle Actions.
	BatchingStrategy []BatchingStrategyObservation `json:"batchingStrategy,omitempty" tf:"batching_strategy,omitempty"`

	// (Updatable) Type of Exadata Fleet Update collection being upgraded.
	CollectionType *string `json:"collectionType,omitempty" tf:"collection_type,omitempty"`

	// (Updatable) Compartment Identifier.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Details to configure diagnostics collection for targets affected by this Exadata Fleet Update Maintenance Cycle.
	DiagnosticsCollection []DiagnosticsCollectionObservation `json:"diagnosticsCollection,omitempty" tf:"diagnostics_collection,omitempty"`

	// (Updatable) Exadata Fleet Update Cycle display name.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// OCID identifier for the Action that is currently in execution, if applicable.
	ExecutingFsuActionID *string `json:"executingFsuActionId,omitempty" tf:"executing_fsu_action_id,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// OCID identifier for the Collection ID the Exadata Fleet Update Cycle will be assigned to.
	FsuCollectionID *string `json:"fsuCollectionId,omitempty" tf:"fsu_collection_id,omitempty"`

	// (Updatable) Goal version or image details for the Exadata Fleet Update Cycle.
	GoalVersionDetails []GoalVersionDetailsObservation `json:"goalVersionDetails,omitempty" tf:"goal_version_details,omitempty"`

	// OCID identifier for the Exadata Fleet Update Cycle.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Applicable when type=PATCH) (Updatable) List of patch IDs to ignore.
	IsIgnoreMissingPatches []*string `json:"isIgnoreMissingPatches,omitempty" tf:"is_ignore_missing_patches,omitempty"`

	// (Applicable when type=PATCH) (Updatable) Ignore all patches between the source and target homes during patching.
	IsIgnorePatches *bool `json:"isIgnorePatches,omitempty" tf:"is_ignore_patches,omitempty"`

	// (Applicable when type=PATCH) (Updatable) Ensure that services of administrator-managed Oracle RAC or Oracle RAC One databases are running on the same instances before and after the move operation.
	IsKeepPlacement *bool `json:"isKeepPlacement,omitempty" tf:"is_keep_placement,omitempty"`

	// The latest Action type that was completed in the Exadata Fleet Update Cycle. No value would indicate that the Cycle has not completed any Action yet.
	LastCompletedAction *string `json:"lastCompletedAction,omitempty" tf:"last_completed_action,omitempty"`

	// The OCID of the latest Action  in the Exadata Fleet Update Cycle.
	LastCompletedActionID *string `json:"lastCompletedActionId,omitempty" tf:"last_completed_action_id,omitempty"`

	// A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// (Applicable when type=PATCH) (Updatable) Service drain timeout specified in seconds.
	MaxDrainTimeoutInSeconds *float64 `json:"maxDrainTimeoutInSeconds,omitempty" tf:"max_drain_timeout_in_seconds,omitempty"`

	// In this array all the possible actions will be listed. The first element is the suggested Action.
	NextActionToExecute []NextActionToExecuteObservation `json:"nextActionToExecute,omitempty" tf:"next_action_to_execute,omitempty"`

	// Current rollback cycle state if rollback maintenance cycle action has been attempted. No value would indicate that the Cycle has not run a rollback maintenance cycle action before.
	RollbackCycleState *string `json:"rollbackCycleState,omitempty" tf:"rollback_cycle_state,omitempty"`

	// Scheduling related details for the Exadata Fleet Update Action during create operations. The specified time should not conflict with existing Exadata Infrastructure maintenance windows. Null scheduleDetails for Stage and Apply Actions in Exadata Fleet Update Cycle creation would not create Actions. Null scheduleDetails for CreateAction would execute the Exadata Fleet Update Action as soon as possible.
	StageActionSchedule []StageActionScheduleObservation `json:"stageActionSchedule,omitempty" tf:"stage_action_schedule,omitempty"`

	// The current state of the Exadata Fleet Update Cycle.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Usage of system tag keys. These predefined keys are scoped to namespaces. Example: {"orcl-cloud.free-tier-retained": "true"}
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// The date and time the Exadata Fleet Update Cycle was created, as described in RFC 3339, section 14.29.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The date and time the Exadata Fleet Update Cycle was finished, as described in RFC 3339.
	TimeFinished *string `json:"timeFinished,omitempty" tf:"time_finished,omitempty"`

	// The date and time the Exadata Fleet Update Cycle was updated, as described in RFC 3339, section 14.29.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Applicable when type=UPGRADE) (Updatable) Details of supported upgrade options for DB or GI collection.
	UpgradeDetails []UpgradeDetailsObservation `json:"upgradeDetails,omitempty" tf:"upgrade_details,omitempty"`
}

type SoftwareUpdateFsuCycleParameters struct {

	// Scheduling related details for the Exadata Fleet Update Action during create operations. The specified time should not conflict with existing Exadata Infrastructure maintenance windows. Null scheduleDetails for Stage and Apply Actions in Exadata Fleet Update Cycle creation would not create Actions. Null scheduleDetails for CreateAction would execute the Exadata Fleet Update Action as soon as possible.
	// +kubebuilder:validation:Optional
	ApplyActionSchedule []ApplyActionScheduleParameters `json:"applyActionSchedule,omitempty" tf:"apply_action_schedule,omitempty"`

	// (Updatable) Batching strategy details to use during PRECHECK and APPLY Cycle Actions.
	// +kubebuilder:validation:Optional
	BatchingStrategy []BatchingStrategyParameters `json:"batchingStrategy,omitempty" tf:"batching_strategy,omitempty"`

	// (Updatable) Compartment Identifier.
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Details to configure diagnostics collection for targets affected by this Exadata Fleet Update Maintenance Cycle.
	// +kubebuilder:validation:Optional
	DiagnosticsCollection []DiagnosticsCollectionParameters `json:"diagnosticsCollection,omitempty" tf:"diagnostics_collection,omitempty"`

	// (Updatable) Exadata Fleet Update Cycle display name.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// OCID identifier for the Collection ID the Exadata Fleet Update Cycle will be assigned to.
	// +kubebuilder:validation:Optional
	FsuCollectionID *string `json:"fsuCollectionId,omitempty" tf:"fsu_collection_id,omitempty"`

	// (Updatable) Goal version or image details for the Exadata Fleet Update Cycle.
	// +kubebuilder:validation:Optional
	GoalVersionDetails []GoalVersionDetailsParameters `json:"goalVersionDetails,omitempty" tf:"goal_version_details,omitempty"`

	// (Applicable when type=PATCH) (Updatable) List of patch IDs to ignore.
	// +kubebuilder:validation:Optional
	IsIgnoreMissingPatches []*string `json:"isIgnoreMissingPatches,omitempty" tf:"is_ignore_missing_patches,omitempty"`

	// (Applicable when type=PATCH) (Updatable) Ignore all patches between the source and target homes during patching.
	// +kubebuilder:validation:Optional
	IsIgnorePatches *bool `json:"isIgnorePatches,omitempty" tf:"is_ignore_patches,omitempty"`

	// (Applicable when type=PATCH) (Updatable) Ensure that services of administrator-managed Oracle RAC or Oracle RAC One databases are running on the same instances before and after the move operation.
	// +kubebuilder:validation:Optional
	IsKeepPlacement *bool `json:"isKeepPlacement,omitempty" tf:"is_keep_placement,omitempty"`

	// (Applicable when type=PATCH) (Updatable) Service drain timeout specified in seconds.
	// +kubebuilder:validation:Optional
	MaxDrainTimeoutInSeconds *float64 `json:"maxDrainTimeoutInSeconds,omitempty" tf:"max_drain_timeout_in_seconds,omitempty"`

	// Scheduling related details for the Exadata Fleet Update Action during create operations. The specified time should not conflict with existing Exadata Infrastructure maintenance windows. Null scheduleDetails for Stage and Apply Actions in Exadata Fleet Update Cycle creation would not create Actions. Null scheduleDetails for CreateAction would execute the Exadata Fleet Update Action as soon as possible.
	// +kubebuilder:validation:Optional
	StageActionSchedule []StageActionScheduleParameters `json:"stageActionSchedule,omitempty" tf:"stage_action_schedule,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Applicable when type=UPGRADE) (Updatable) Details of supported upgrade options for DB or GI collection.
	// +kubebuilder:validation:Optional
	UpgradeDetails []UpgradeDetailsParameters `json:"upgradeDetails,omitempty" tf:"upgrade_details,omitempty"`
}

type StageActionScheduleInitParameters struct {

	// The date and time the Exadata Fleet Update Action is expected to start. RFC 3339, section 14.29.
	TimeToStart *string `json:"timeToStart,omitempty" tf:"time_to_start,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type StageActionScheduleObservation struct {

	// The date and time the Exadata Fleet Update Action is expected to start. RFC 3339, section 14.29.
	TimeToStart *string `json:"timeToStart,omitempty" tf:"time_to_start,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type StageActionScheduleParameters struct {

	// The date and time the Exadata Fleet Update Action is expected to start. RFC 3339, section 14.29.
	// +kubebuilder:validation:Optional
	TimeToStart *string `json:"timeToStart" tf:"time_to_start,omitempty"`

	// Type of scheduling strategy to use for Fleet Patching Update Action execution.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type UpgradeDetailsInitParameters struct {

	// (Updatable) Type of Exadata Fleet Update collection being upgraded.
	CollectionType *string `json:"collectionType,omitempty" tf:"collection_type,omitempty"`

	// (Applicable when collection_type=DB) (Updatable) Enables or disables the recompilation of invalid objects.
	IsRecompileInvalidObjects *bool `json:"isRecompileInvalidObjects,omitempty" tf:"is_recompile_invalid_objects,omitempty"`

	// (Applicable when collection_type=DB) (Updatable) Enables or disables time zone upgrade.
	IsTimeZoneUpgrade *bool `json:"isTimeZoneUpgrade,omitempty" tf:"is_time_zone_upgrade,omitempty"`
}

type UpgradeDetailsObservation struct {

	// (Updatable) Type of Exadata Fleet Update collection being upgraded.
	CollectionType *string `json:"collectionType,omitempty" tf:"collection_type,omitempty"`

	// (Applicable when collection_type=DB) (Updatable) Enables or disables the recompilation of invalid objects.
	IsRecompileInvalidObjects *bool `json:"isRecompileInvalidObjects,omitempty" tf:"is_recompile_invalid_objects,omitempty"`

	// (Applicable when collection_type=DB) (Updatable) Enables or disables time zone upgrade.
	IsTimeZoneUpgrade *bool `json:"isTimeZoneUpgrade,omitempty" tf:"is_time_zone_upgrade,omitempty"`
}

type UpgradeDetailsParameters struct {

	// (Updatable) Type of Exadata Fleet Update collection being upgraded.
	// +kubebuilder:validation:Optional
	CollectionType *string `json:"collectionType" tf:"collection_type,omitempty"`

	// (Applicable when collection_type=DB) (Updatable) Enables or disables the recompilation of invalid objects.
	// +kubebuilder:validation:Optional
	IsRecompileInvalidObjects *bool `json:"isRecompileInvalidObjects,omitempty" tf:"is_recompile_invalid_objects,omitempty"`

	// (Applicable when collection_type=DB) (Updatable) Enables or disables time zone upgrade.
	// +kubebuilder:validation:Optional
	IsTimeZoneUpgrade *bool `json:"isTimeZoneUpgrade,omitempty" tf:"is_time_zone_upgrade,omitempty"`
}

// SoftwareUpdateFsuCycleSpec defines the desired state of SoftwareUpdateFsuCycle
type SoftwareUpdateFsuCycleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SoftwareUpdateFsuCycleParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SoftwareUpdateFsuCycleInitParameters `json:"initProvider,omitempty"`
}

// SoftwareUpdateFsuCycleStatus defines the observed state of SoftwareUpdateFsuCycle.
type SoftwareUpdateFsuCycleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SoftwareUpdateFsuCycleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// SoftwareUpdateFsuCycle is the Schema for the SoftwareUpdateFsuCycles API. Provides the Fsu Cycle resource in Oracle Cloud Infrastructure Fleet Software Update service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type SoftwareUpdateFsuCycle struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.compartmentId) || (has(self.initProvider) && has(self.initProvider.compartmentId))",message="spec.forProvider.compartmentId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.fsuCollectionId) || (has(self.initProvider) && has(self.initProvider.fsuCollectionId))",message="spec.forProvider.fsuCollectionId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.goalVersionDetails) || (has(self.initProvider) && has(self.initProvider.goalVersionDetails))",message="spec.forProvider.goalVersionDetails is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.type) || (has(self.initProvider) && has(self.initProvider.type))",message="spec.forProvider.type is a required parameter"
	Spec   SoftwareUpdateFsuCycleSpec   `json:"spec"`
	Status SoftwareUpdateFsuCycleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SoftwareUpdateFsuCycleList contains a list of SoftwareUpdateFsuCycles
type SoftwareUpdateFsuCycleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SoftwareUpdateFsuCycle `json:"items"`
}

// Repository type metadata.
var (
	SoftwareUpdateFsuCycle_Kind             = "SoftwareUpdateFsuCycle"
	SoftwareUpdateFsuCycle_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SoftwareUpdateFsuCycle_Kind}.String()
	SoftwareUpdateFsuCycle_KindAPIVersion   = SoftwareUpdateFsuCycle_Kind + "." + CRDGroupVersion.String()
	SoftwareUpdateFsuCycle_GroupVersionKind = CRDGroupVersion.WithKind(SoftwareUpdateFsuCycle_Kind)
)

func init() {
	SchemeBuilder.Register(&SoftwareUpdateFsuCycle{}, &SoftwareUpdateFsuCycleList{})
}
