/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CapabilitiesInitParameters struct {

	// A list of additional configurable container capabilities.
	AddCapabilities []*string `json:"addCapabilities,omitempty" tf:"add_capabilities,omitempty"`

	// A list of container capabilities that can be dropped.
	DropCapabilities []*string `json:"dropCapabilities,omitempty" tf:"drop_capabilities,omitempty"`
}

type CapabilitiesObservation struct {

	// A list of additional configurable container capabilities.
	AddCapabilities []*string `json:"addCapabilities,omitempty" tf:"add_capabilities,omitempty"`

	// A list of container capabilities that can be dropped.
	DropCapabilities []*string `json:"dropCapabilities,omitempty" tf:"drop_capabilities,omitempty"`
}

type CapabilitiesParameters struct {

	// A list of additional configurable container capabilities.
	// +kubebuilder:validation:Optional
	AddCapabilities []*string `json:"addCapabilities,omitempty" tf:"add_capabilities,omitempty"`

	// A list of container capabilities that can be dropped.
	// +kubebuilder:validation:Optional
	DropCapabilities []*string `json:"dropCapabilities,omitempty" tf:"drop_capabilities,omitempty"`
}

type ConfigsInitParameters struct {

	// The base64 encoded contents of the file. The contents are decoded to plain text before mounted as a file to a container inside container instance.
	Data *string `json:"data,omitempty" tf:"data,omitempty"`

	// The name of the file. The fileName should be unique across the volume.
	FileName *string `json:"fileName,omitempty" tf:"file_name,omitempty"`

	// Container health check HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type ConfigsObservation struct {

	// The base64 encoded contents of the file. The contents are decoded to plain text before mounted as a file to a container inside container instance.
	Data *string `json:"data,omitempty" tf:"data,omitempty"`

	// The name of the file. The fileName should be unique across the volume.
	FileName *string `json:"fileName,omitempty" tf:"file_name,omitempty"`

	// Container health check HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type ConfigsParameters struct {

	// The base64 encoded contents of the file. The contents are decoded to plain text before mounted as a file to a container inside container instance.
	// +kubebuilder:validation:Optional
	Data *string `json:"data,omitempty" tf:"data,omitempty"`

	// The name of the file. The fileName should be unique across the volume.
	// +kubebuilder:validation:Optional
	FileName *string `json:"fileName,omitempty" tf:"file_name,omitempty"`

	// Container health check HTTP path.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type ContainersInitParameters struct {

	// A list of string arguments for a container's ENTRYPOINT process.
	Arguments []*string `json:"arguments,omitempty" tf:"arguments,omitempty"`

	// An optional command that overrides the ENTRYPOINT process. If you do not provide a value, the existing ENTRYPOINT process defined in the image is used.
	Command []*string `json:"command,omitempty" tf:"command,omitempty"`

	// Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}.
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information. If you don't provide a name, a name is generated automatically.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// A map of additional environment variables to set in the environment of the container's ENTRYPOINT process. These variables are in addition to any variables already defined in the container's image.
	// +mapType=granular
	EnvironmentVariables map[string]*string `json:"environmentVariables,omitempty" tf:"environment_variables,omitempty"`

	// Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// list of container health checks to check container status and take appropriate action if container status is failed. There are two types of health checks that we currently support HTTP and TCP.
	HealthChecks []HealthChecksInitParameters `json:"healthChecks,omitempty" tf:"health_checks,omitempty"`

	// A URL identifying the image that the container runs in, such as docker.io/library/busybox:latest. If you do not provide a tag, the tag will default to latest.
	ImageURL *string `json:"imageUrl,omitempty" tf:"image_url,omitempty"`

	// Determines if the container will have access to the container instance resource principal.
	IsResourcePrincipalDisabled *bool `json:"isResourcePrincipalDisabled,omitempty" tf:"is_resource_principal_disabled,omitempty"`

	// The size and amount of resources available to the container.
	ResourceConfig []ResourceConfigInitParameters `json:"resourceConfig,omitempty" tf:"resource_config,omitempty"`

	// Security context for container.
	SecurityContext []SecurityContextInitParameters `json:"securityContext,omitempty" tf:"security_context,omitempty"`

	// List of the volume mounts.
	VolumeMounts []VolumeMountsInitParameters `json:"volumeMounts,omitempty" tf:"volume_mounts,omitempty"`

	// The working directory within the container's filesystem for the container process. If not specified, the default working directory from the image is used.
	WorkingDirectory *string `json:"workingDirectory,omitempty" tf:"working_directory,omitempty"`
}

type ContainersObservation struct {

	// A list of string arguments for a container's ENTRYPOINT process.
	Arguments []*string `json:"arguments,omitempty" tf:"arguments,omitempty"`

	// The availability domain where the container instance runs.
	AvailabilityDomain *string `json:"availabilityDomain,omitempty" tf:"availability_domain,omitempty"`

	// An optional command that overrides the ENTRYPOINT process. If you do not provide a value, the existing ENTRYPOINT process defined in the image is used.
	Command []*string `json:"command,omitempty" tf:"command,omitempty"`

	// (Updatable) The compartment OCID.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// The OCID of the container.
	ContainerID *string `json:"containerId,omitempty" tf:"container_id,omitempty"`

	// An OCID that cannot be changed.
	ContainerInstanceID *string `json:"containerInstanceId,omitempty" tf:"container_instance_id,omitempty"`

	// Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}.
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information. If you don't provide a name, a name is generated automatically.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// A map of additional environment variables to set in the environment of the container's ENTRYPOINT process. These variables are in addition to any variables already defined in the container's image.
	// +mapType=granular
	EnvironmentVariables map[string]*string `json:"environmentVariables,omitempty" tf:"environment_variables,omitempty"`

	ExitCode *float64 `json:"exitCode,omitempty" tf:"exit_code,omitempty"`

	// The fault domain where the container instance runs.
	FaultDomain *string `json:"faultDomain,omitempty" tf:"fault_domain,omitempty"`

	// Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// list of container health checks to check container status and take appropriate action if container status is failed. There are two types of health checks that we currently support HTTP and TCP.
	HealthChecks []HealthChecksObservation `json:"healthChecks,omitempty" tf:"health_checks,omitempty"`

	// A URL identifying the image that the container runs in, such as docker.io/library/busybox:latest. If you do not provide a tag, the tag will default to latest.
	ImageURL *string `json:"imageUrl,omitempty" tf:"image_url,omitempty"`

	// Determines if the container will have access to the container instance resource principal.
	IsResourcePrincipalDisabled *bool `json:"isResourcePrincipalDisabled,omitempty" tf:"is_resource_principal_disabled,omitempty"`

	// A message that describes the current state of the container in more detail. Can be used to provide actionable information.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// The size and amount of resources available to the container.
	ResourceConfig []ResourceConfigObservation `json:"resourceConfig,omitempty" tf:"resource_config,omitempty"`

	// Security context for container.
	SecurityContext []SecurityContextObservation `json:"securityContext,omitempty" tf:"security_context,omitempty"`

	// (Updatable) The target state for the Container Instance. Could be set to ACTIVE or INACTIVE.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Usage of system tag keys. These predefined keys are scoped to namespaces. Example: {"orcl-cloud.free-tier-retained": "true"}.
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// The time the container instance was created, in the format defined by RFC 3339.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	TimeTerminated *string `json:"timeTerminated,omitempty" tf:"time_terminated,omitempty"`

	// The time the container instance was updated, in the format defined by RFC 3339.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`

	// List of the volume mounts.
	VolumeMounts []VolumeMountsObservation `json:"volumeMounts,omitempty" tf:"volume_mounts,omitempty"`

	// The working directory within the container's filesystem for the container process. If not specified, the default working directory from the image is used.
	WorkingDirectory *string `json:"workingDirectory,omitempty" tf:"working_directory,omitempty"`
}

type ContainersParameters struct {

	// A list of string arguments for a container's ENTRYPOINT process.
	// +kubebuilder:validation:Optional
	Arguments []*string `json:"arguments,omitempty" tf:"arguments,omitempty"`

	// An optional command that overrides the ENTRYPOINT process. If you do not provide a value, the existing ENTRYPOINT process defined in the image is used.
	// +kubebuilder:validation:Optional
	Command []*string `json:"command,omitempty" tf:"command,omitempty"`

	// Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information. If you don't provide a name, a name is generated automatically.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// A map of additional environment variables to set in the environment of the container's ENTRYPOINT process. These variables are in addition to any variables already defined in the container's image.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	EnvironmentVariables map[string]*string `json:"environmentVariables,omitempty" tf:"environment_variables,omitempty"`

	// Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// list of container health checks to check container status and take appropriate action if container status is failed. There are two types of health checks that we currently support HTTP and TCP.
	// +kubebuilder:validation:Optional
	HealthChecks []HealthChecksParameters `json:"healthChecks,omitempty" tf:"health_checks,omitempty"`

	// A URL identifying the image that the container runs in, such as docker.io/library/busybox:latest. If you do not provide a tag, the tag will default to latest.
	// +kubebuilder:validation:Optional
	ImageURL *string `json:"imageUrl" tf:"image_url,omitempty"`

	// Determines if the container will have access to the container instance resource principal.
	// +kubebuilder:validation:Optional
	IsResourcePrincipalDisabled *bool `json:"isResourcePrincipalDisabled,omitempty" tf:"is_resource_principal_disabled,omitempty"`

	// The size and amount of resources available to the container.
	// +kubebuilder:validation:Optional
	ResourceConfig []ResourceConfigParameters `json:"resourceConfig,omitempty" tf:"resource_config,omitempty"`

	// Security context for container.
	// +kubebuilder:validation:Optional
	SecurityContext []SecurityContextParameters `json:"securityContext,omitempty" tf:"security_context,omitempty"`

	// List of the volume mounts.
	// +kubebuilder:validation:Optional
	VolumeMounts []VolumeMountsParameters `json:"volumeMounts,omitempty" tf:"volume_mounts,omitempty"`

	// The working directory within the container's filesystem for the container process. If not specified, the default working directory from the image is used.
	// +kubebuilder:validation:Optional
	WorkingDirectory *string `json:"workingDirectory,omitempty" tf:"working_directory,omitempty"`
}

type DNSConfigInitParameters struct {

	// IP address of a name server that the resolver should query, either an IPv4 address (in dot notation), or an IPv6 address in colon (and possibly dot) notation. If null, uses nameservers from subnet dhcpDnsOptions.
	Nameservers []*string `json:"nameservers,omitempty" tf:"nameservers,omitempty"`

	// Options allows certain internal resolver variables to be modified. Options are a list of objects in https://man7.org/linux/man-pages/man5/resolv.conf.5.html. Examples: ["ndots:n", "edns0"].
	Options []*string `json:"options,omitempty" tf:"options,omitempty"`

	// Search list for host-name lookup. If null, we will use searches from subnet dhcpDnsOptios.
	Searches []*string `json:"searches,omitempty" tf:"searches,omitempty"`
}

type DNSConfigObservation struct {

	// IP address of a name server that the resolver should query, either an IPv4 address (in dot notation), or an IPv6 address in colon (and possibly dot) notation. If null, uses nameservers from subnet dhcpDnsOptions.
	Nameservers []*string `json:"nameservers,omitempty" tf:"nameservers,omitempty"`

	// Options allows certain internal resolver variables to be modified. Options are a list of objects in https://man7.org/linux/man-pages/man5/resolv.conf.5.html. Examples: ["ndots:n", "edns0"].
	Options []*string `json:"options,omitempty" tf:"options,omitempty"`

	// Search list for host-name lookup. If null, we will use searches from subnet dhcpDnsOptios.
	Searches []*string `json:"searches,omitempty" tf:"searches,omitempty"`
}

type DNSConfigParameters struct {

	// IP address of a name server that the resolver should query, either an IPv4 address (in dot notation), or an IPv6 address in colon (and possibly dot) notation. If null, uses nameservers from subnet dhcpDnsOptions.
	// +kubebuilder:validation:Optional
	Nameservers []*string `json:"nameservers,omitempty" tf:"nameservers,omitempty"`

	// Options allows certain internal resolver variables to be modified. Options are a list of objects in https://man7.org/linux/man-pages/man5/resolv.conf.5.html. Examples: ["ndots:n", "edns0"].
	// +kubebuilder:validation:Optional
	Options []*string `json:"options,omitempty" tf:"options,omitempty"`

	// Search list for host-name lookup. If null, we will use searches from subnet dhcpDnsOptios.
	// +kubebuilder:validation:Optional
	Searches []*string `json:"searches,omitempty" tf:"searches,omitempty"`
}

type HeadersInitParameters struct {

	// Container HTTP header Key.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Container HTTP header value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type HeadersObservation struct {

	// Container HTTP header Key.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Container HTTP header value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type HeadersParameters struct {

	// Container HTTP header Key.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Container HTTP header value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type HealthChecksInitParameters struct {

	// The action will be triggered when the container health check fails. There are two types of action: KILL or NONE. The default action is KILL. If failure action is KILL, the container will be subject to the container restart policy.
	FailureAction *string `json:"failureAction,omitempty" tf:"failure_action,omitempty"`

	// Number of consecutive failures at which we consider the check failed.
	FailureThreshold *float64 `json:"failureThreshold,omitempty" tf:"failure_threshold,omitempty"`

	// (Applicable when health_check_type=HTTP) Container health check HTTP headers.
	Headers []HeadersInitParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// Container health check type.
	HealthCheckType *string `json:"healthCheckType,omitempty" tf:"health_check_type,omitempty"`

	// The initial delay in seconds before start checking container health status.
	InitialDelayInSeconds *float64 `json:"initialDelayInSeconds,omitempty" tf:"initial_delay_in_seconds,omitempty"`

	// Number of seconds between two consecutive runs for checking container health.
	IntervalInSeconds *float64 `json:"intervalInSeconds,omitempty" tf:"interval_in_seconds,omitempty"`

	// Container HTTP header Key.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Container health check HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Container health check HTTP port.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	StatusDetails *string `json:"statusDetails,omitempty" tf:"status_details,omitempty"`

	// Number of consecutive successes at which we consider the check succeeded again after it was in failure state.
	SuccessThreshold *float64 `json:"successThreshold,omitempty" tf:"success_threshold,omitempty"`

	// Length of waiting time in seconds before marking health check failed.
	TimeoutInSeconds *float64 `json:"timeoutInSeconds,omitempty" tf:"timeout_in_seconds,omitempty"`
}

type HealthChecksObservation struct {

	// The action will be triggered when the container health check fails. There are two types of action: KILL or NONE. The default action is KILL. If failure action is KILL, the container will be subject to the container restart policy.
	FailureAction *string `json:"failureAction,omitempty" tf:"failure_action,omitempty"`

	// Number of consecutive failures at which we consider the check failed.
	FailureThreshold *float64 `json:"failureThreshold,omitempty" tf:"failure_threshold,omitempty"`

	// (Applicable when health_check_type=HTTP) Container health check HTTP headers.
	Headers []HeadersObservation `json:"headers,omitempty" tf:"headers,omitempty"`

	// Container health check type.
	HealthCheckType *string `json:"healthCheckType,omitempty" tf:"health_check_type,omitempty"`

	// The initial delay in seconds before start checking container health status.
	InitialDelayInSeconds *float64 `json:"initialDelayInSeconds,omitempty" tf:"initial_delay_in_seconds,omitempty"`

	// Number of seconds between two consecutive runs for checking container health.
	IntervalInSeconds *float64 `json:"intervalInSeconds,omitempty" tf:"interval_in_seconds,omitempty"`

	// Container HTTP header Key.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Container health check HTTP path.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Container health check HTTP port.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	StatusDetails *string `json:"statusDetails,omitempty" tf:"status_details,omitempty"`

	// Number of consecutive successes at which we consider the check succeeded again after it was in failure state.
	SuccessThreshold *float64 `json:"successThreshold,omitempty" tf:"success_threshold,omitempty"`

	// Length of waiting time in seconds before marking health check failed.
	TimeoutInSeconds *float64 `json:"timeoutInSeconds,omitempty" tf:"timeout_in_seconds,omitempty"`
}

type HealthChecksParameters struct {

	// The action will be triggered when the container health check fails. There are two types of action: KILL or NONE. The default action is KILL. If failure action is KILL, the container will be subject to the container restart policy.
	// +kubebuilder:validation:Optional
	FailureAction *string `json:"failureAction,omitempty" tf:"failure_action,omitempty"`

	// Number of consecutive failures at which we consider the check failed.
	// +kubebuilder:validation:Optional
	FailureThreshold *float64 `json:"failureThreshold,omitempty" tf:"failure_threshold,omitempty"`

	// (Applicable when health_check_type=HTTP) Container health check HTTP headers.
	// +kubebuilder:validation:Optional
	Headers []HeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// Container health check type.
	// +kubebuilder:validation:Optional
	HealthCheckType *string `json:"healthCheckType" tf:"health_check_type,omitempty"`

	// The initial delay in seconds before start checking container health status.
	// +kubebuilder:validation:Optional
	InitialDelayInSeconds *float64 `json:"initialDelayInSeconds,omitempty" tf:"initial_delay_in_seconds,omitempty"`

	// Number of seconds between two consecutive runs for checking container health.
	// +kubebuilder:validation:Optional
	IntervalInSeconds *float64 `json:"intervalInSeconds,omitempty" tf:"interval_in_seconds,omitempty"`

	// Container HTTP header Key.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Container health check HTTP path.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Container health check HTTP port.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// +kubebuilder:validation:Optional
	StatusDetails *string `json:"statusDetails,omitempty" tf:"status_details,omitempty"`

	// Number of consecutive successes at which we consider the check succeeded again after it was in failure state.
	// +kubebuilder:validation:Optional
	SuccessThreshold *float64 `json:"successThreshold,omitempty" tf:"success_threshold,omitempty"`

	// Length of waiting time in seconds before marking health check failed.
	// +kubebuilder:validation:Optional
	TimeoutInSeconds *float64 `json:"timeoutInSeconds,omitempty" tf:"timeout_in_seconds,omitempty"`
}

type ImagePullSecretsInitParameters struct {

	// The password which should be used with the registry for authentication. The value is expected in base64 format.
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// The registry endpoint of the container image.
	RegistryEndpoint *string `json:"registryEndpoint,omitempty" tf:"registry_endpoint,omitempty"`

	// The OCID of the secret for registry credentials.
	SecretID *string `json:"secretId,omitempty" tf:"secret_id,omitempty"`

	// The type of ImagePullSecret.
	SecretType *string `json:"secretType,omitempty" tf:"secret_type,omitempty"`

	// The username which should be used with the registry for authentication. The value is expected in base64 format.
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type ImagePullSecretsObservation struct {

	// The registry endpoint of the container image.
	RegistryEndpoint *string `json:"registryEndpoint,omitempty" tf:"registry_endpoint,omitempty"`

	// The OCID of the secret for registry credentials.
	SecretID *string `json:"secretId,omitempty" tf:"secret_id,omitempty"`

	// The type of ImagePullSecret.
	SecretType *string `json:"secretType,omitempty" tf:"secret_type,omitempty"`

	// The username which should be used with the registry for authentication. The value is expected in base64 format.
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type ImagePullSecretsParameters struct {

	// The password which should be used with the registry for authentication. The value is expected in base64 format.
	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// The registry endpoint of the container image.
	// +kubebuilder:validation:Optional
	RegistryEndpoint *string `json:"registryEndpoint" tf:"registry_endpoint,omitempty"`

	// The OCID of the secret for registry credentials.
	// +kubebuilder:validation:Optional
	SecretID *string `json:"secretId,omitempty" tf:"secret_id,omitempty"`

	// The type of ImagePullSecret.
	// +kubebuilder:validation:Optional
	SecretType *string `json:"secretType" tf:"secret_type,omitempty"`

	// The username which should be used with the registry for authentication. The value is expected in base64 format.
	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type InstancesContainerInstanceInitParameters struct {

	// The availability domain where the container instance runs.
	AvailabilityDomain *string `json:"availabilityDomain,omitempty" tf:"availability_domain,omitempty"`

	// (Updatable) The compartment OCID.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Container restart policy
	ContainerRestartPolicy *string `json:"containerRestartPolicy,omitempty" tf:"container_restart_policy,omitempty"`

	// The containers to create on this container instance.
	Containers []ContainersInitParameters `json:"containers,omitempty" tf:"containers,omitempty"`

	// Allow customers to define DNS settings for containers. If this is not provided, the containers use the default DNS settings of the subnet.
	DNSConfig []DNSConfigInitParameters `json:"dnsConfig,omitempty" tf:"dns_config,omitempty"`

	// Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}.
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information. If you don't provide a name, a name is generated automatically.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The fault domain where the container instance runs.
	FaultDomain *string `json:"faultDomain,omitempty" tf:"fault_domain,omitempty"`

	// Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The amount of time that processes in a container have to gracefully end when the container must be stopped. For example, when you delete a container instance. After the timeout is reached, the processes are sent a signal to be deleted.
	GracefulShutdownTimeoutInSeconds *string `json:"gracefulShutdownTimeoutInSeconds,omitempty" tf:"graceful_shutdown_timeout_in_seconds,omitempty"`

	// The image pulls secrets so you can access private registry to pull container images.
	ImagePullSecrets []ImagePullSecretsInitParameters `json:"imagePullSecrets,omitempty" tf:"image_pull_secrets,omitempty"`

	// The shape of the container instance. The shape determines the resources available to the container instance.
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The size and amount of resources available to the container instance.
	ShapeConfig []ShapeConfigInitParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// (Updatable) The target state for the Container Instance. Could be set to ACTIVE or INACTIVE.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The networks available to containers on this container instance.
	Vnics []VnicsInitParameters `json:"vnics,omitempty" tf:"vnics,omitempty"`

	// A volume is a directory with data that is accessible across multiple containers in a container instance.
	Volumes []VolumesInitParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`
}

type InstancesContainerInstanceObservation struct {

	// The availability domain where the container instance runs.
	AvailabilityDomain *string `json:"availabilityDomain,omitempty" tf:"availability_domain,omitempty"`

	// (Updatable) The compartment OCID.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// The number of containers on the container instance.
	ContainerCount *float64 `json:"containerCount,omitempty" tf:"container_count,omitempty"`

	// Container restart policy
	ContainerRestartPolicy *string `json:"containerRestartPolicy,omitempty" tf:"container_restart_policy,omitempty"`

	// The containers to create on this container instance.
	Containers []ContainersObservation `json:"containers,omitempty" tf:"containers,omitempty"`

	// Allow customers to define DNS settings for containers. If this is not provided, the containers use the default DNS settings of the subnet.
	DNSConfig []DNSConfigObservation `json:"dnsConfig,omitempty" tf:"dns_config,omitempty"`

	// Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}.
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information. If you don't provide a name, a name is generated automatically.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The fault domain where the container instance runs.
	FaultDomain *string `json:"faultDomain,omitempty" tf:"fault_domain,omitempty"`

	// Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The amount of time that processes in a container have to gracefully end when the container must be stopped. For example, when you delete a container instance. After the timeout is reached, the processes are sent a signal to be deleted.
	GracefulShutdownTimeoutInSeconds *string `json:"gracefulShutdownTimeoutInSeconds,omitempty" tf:"graceful_shutdown_timeout_in_seconds,omitempty"`

	// An OCID that cannot be changed.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The image pulls secrets so you can access private registry to pull container images.
	ImagePullSecrets []ImagePullSecretsObservation `json:"imagePullSecrets,omitempty" tf:"image_pull_secrets,omitempty"`

	// A message that describes the current state of the container in more detail. Can be used to provide actionable information.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// The shape of the container instance. The shape determines the resources available to the container instance.
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The size and amount of resources available to the container instance.
	ShapeConfig []ShapeConfigObservation `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// (Updatable) The target state for the Container Instance. Could be set to ACTIVE or INACTIVE.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Usage of system tag keys. These predefined keys are scoped to namespaces. Example: {"orcl-cloud.free-tier-retained": "true"}.
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// The time the container instance was created, in the format defined by RFC 3339.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The time the container instance was updated, in the format defined by RFC 3339.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`

	// The networks available to containers on this container instance.
	Vnics []VnicsObservation `json:"vnics,omitempty" tf:"vnics,omitempty"`

	// The number of volumes that are attached to the container instance.
	VolumeCount *float64 `json:"volumeCount,omitempty" tf:"volume_count,omitempty"`

	// A volume is a directory with data that is accessible across multiple containers in a container instance.
	Volumes []VolumesObservation `json:"volumes,omitempty" tf:"volumes,omitempty"`
}

type InstancesContainerInstanceParameters struct {

	// The availability domain where the container instance runs.
	// +kubebuilder:validation:Optional
	AvailabilityDomain *string `json:"availabilityDomain,omitempty" tf:"availability_domain,omitempty"`

	// (Updatable) The compartment OCID.
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Container restart policy
	// +kubebuilder:validation:Optional
	ContainerRestartPolicy *string `json:"containerRestartPolicy,omitempty" tf:"container_restart_policy,omitempty"`

	// The containers to create on this container instance.
	// +kubebuilder:validation:Optional
	Containers []ContainersParameters `json:"containers,omitempty" tf:"containers,omitempty"`

	// Allow customers to define DNS settings for containers. If this is not provided, the containers use the default DNS settings of the subnet.
	// +kubebuilder:validation:Optional
	DNSConfig []DNSConfigParameters `json:"dnsConfig,omitempty" tf:"dns_config,omitempty"`

	// Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information. If you don't provide a name, a name is generated automatically.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The fault domain where the container instance runs.
	// +kubebuilder:validation:Optional
	FaultDomain *string `json:"faultDomain,omitempty" tf:"fault_domain,omitempty"`

	// Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The amount of time that processes in a container have to gracefully end when the container must be stopped. For example, when you delete a container instance. After the timeout is reached, the processes are sent a signal to be deleted.
	// +kubebuilder:validation:Optional
	GracefulShutdownTimeoutInSeconds *string `json:"gracefulShutdownTimeoutInSeconds,omitempty" tf:"graceful_shutdown_timeout_in_seconds,omitempty"`

	// The image pulls secrets so you can access private registry to pull container images.
	// +kubebuilder:validation:Optional
	ImagePullSecrets []ImagePullSecretsParameters `json:"imagePullSecrets,omitempty" tf:"image_pull_secrets,omitempty"`

	// The shape of the container instance. The shape determines the resources available to the container instance.
	// +kubebuilder:validation:Optional
	Shape *string `json:"shape,omitempty" tf:"shape,omitempty"`

	// The size and amount of resources available to the container instance.
	// +kubebuilder:validation:Optional
	ShapeConfig []ShapeConfigParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// (Updatable) The target state for the Container Instance. Could be set to ACTIVE or INACTIVE.
	// +kubebuilder:validation:Optional
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The networks available to containers on this container instance.
	// +kubebuilder:validation:Optional
	Vnics []VnicsParameters `json:"vnics,omitempty" tf:"vnics,omitempty"`

	// A volume is a directory with data that is accessible across multiple containers in a container instance.
	// +kubebuilder:validation:Optional
	Volumes []VolumesParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`
}

type ResourceConfigInitParameters struct {

	// The maximum amount of memory that can be consumed by the container's process.
	MemoryLimitInGbs *float64 `json:"memoryLimitInGbs,omitempty" tf:"memory_limit_in_gbs,omitempty"`

	// The maximum amount of CPUs that can be consumed by the container's process.
	VcpusLimit *float64 `json:"vcpusLimit,omitempty" tf:"vcpus_limit,omitempty"`
}

type ResourceConfigObservation struct {

	// The maximum amount of memory that can be consumed by the container's process.
	MemoryLimitInGbs *float64 `json:"memoryLimitInGbs,omitempty" tf:"memory_limit_in_gbs,omitempty"`

	// The maximum amount of CPUs that can be consumed by the container's process.
	VcpusLimit *float64 `json:"vcpusLimit,omitempty" tf:"vcpus_limit,omitempty"`
}

type ResourceConfigParameters struct {

	// The maximum amount of memory that can be consumed by the container's process.
	// +kubebuilder:validation:Optional
	MemoryLimitInGbs *float64 `json:"memoryLimitInGbs,omitempty" tf:"memory_limit_in_gbs,omitempty"`

	// The maximum amount of CPUs that can be consumed by the container's process.
	// +kubebuilder:validation:Optional
	VcpusLimit *float64 `json:"vcpusLimit,omitempty" tf:"vcpus_limit,omitempty"`
}

type SecurityContextInitParameters struct {

	// Linux Container capabilities to configure capabilities of container.
	Capabilities []CapabilitiesInitParameters `json:"capabilities,omitempty" tf:"capabilities,omitempty"`

	// Indicates if the container must run as a non-root user. If true, the service validates the container image at runtime to ensure that it is not going to run with UID 0 (root) and fails the container instance creation if the validation fails.
	IsNonRootUserCheckEnabled *bool `json:"isNonRootUserCheckEnabled,omitempty" tf:"is_non_root_user_check_enabled,omitempty"`

	// Determines if the container will have a read-only root file system. Default value is false.
	IsRootFileSystemReadonly *bool `json:"isRootFileSystemReadonly,omitempty" tf:"is_root_file_system_readonly,omitempty"`

	// The group ID (GID) to run the entrypoint process of the container. Uses runtime default if not provided.
	RunAsGroup *float64 `json:"runAsGroup,omitempty" tf:"run_as_group,omitempty"`

	// The user ID (UID) to run the entrypoint process of the container. Defaults to user specified UID in container image metadata if not provided. This must be provided if runAsGroup is provided.
	RunAsUser *float64 `json:"runAsUser,omitempty" tf:"run_as_user,omitempty"`

	// The type of security context
	SecurityContextType *string `json:"securityContextType,omitempty" tf:"security_context_type,omitempty"`
}

type SecurityContextObservation struct {

	// Linux Container capabilities to configure capabilities of container.
	Capabilities []CapabilitiesObservation `json:"capabilities,omitempty" tf:"capabilities,omitempty"`

	// Indicates if the container must run as a non-root user. If true, the service validates the container image at runtime to ensure that it is not going to run with UID 0 (root) and fails the container instance creation if the validation fails.
	IsNonRootUserCheckEnabled *bool `json:"isNonRootUserCheckEnabled,omitempty" tf:"is_non_root_user_check_enabled,omitempty"`

	// Determines if the container will have a read-only root file system. Default value is false.
	IsRootFileSystemReadonly *bool `json:"isRootFileSystemReadonly,omitempty" tf:"is_root_file_system_readonly,omitempty"`

	// The group ID (GID) to run the entrypoint process of the container. Uses runtime default if not provided.
	RunAsGroup *float64 `json:"runAsGroup,omitempty" tf:"run_as_group,omitempty"`

	// The user ID (UID) to run the entrypoint process of the container. Defaults to user specified UID in container image metadata if not provided. This must be provided if runAsGroup is provided.
	RunAsUser *float64 `json:"runAsUser,omitempty" tf:"run_as_user,omitempty"`

	// The type of security context
	SecurityContextType *string `json:"securityContextType,omitempty" tf:"security_context_type,omitempty"`
}

type SecurityContextParameters struct {

	// Linux Container capabilities to configure capabilities of container.
	// +kubebuilder:validation:Optional
	Capabilities []CapabilitiesParameters `json:"capabilities,omitempty" tf:"capabilities,omitempty"`

	// Indicates if the container must run as a non-root user. If true, the service validates the container image at runtime to ensure that it is not going to run with UID 0 (root) and fails the container instance creation if the validation fails.
	// +kubebuilder:validation:Optional
	IsNonRootUserCheckEnabled *bool `json:"isNonRootUserCheckEnabled,omitempty" tf:"is_non_root_user_check_enabled,omitempty"`

	// Determines if the container will have a read-only root file system. Default value is false.
	// +kubebuilder:validation:Optional
	IsRootFileSystemReadonly *bool `json:"isRootFileSystemReadonly,omitempty" tf:"is_root_file_system_readonly,omitempty"`

	// The group ID (GID) to run the entrypoint process of the container. Uses runtime default if not provided.
	// +kubebuilder:validation:Optional
	RunAsGroup *float64 `json:"runAsGroup,omitempty" tf:"run_as_group,omitempty"`

	// The user ID (UID) to run the entrypoint process of the container. Defaults to user specified UID in container image metadata if not provided. This must be provided if runAsGroup is provided.
	// +kubebuilder:validation:Optional
	RunAsUser *float64 `json:"runAsUser,omitempty" tf:"run_as_user,omitempty"`

	// The type of security context
	// +kubebuilder:validation:Optional
	SecurityContextType *string `json:"securityContextType,omitempty" tf:"security_context_type,omitempty"`
}

type ShapeConfigInitParameters struct {

	// The total amount of memory available to the container instance (GB).
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The total number of OCPUs available to the container instance.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type ShapeConfigObservation struct {

	// The total amount of memory available to the container instance (GB).
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The networking bandwidth available to the container instance, in gigabits per second.
	NetworkingBandwidthInGbps *float64 `json:"networkingBandwidthInGbps,omitempty" tf:"networking_bandwidth_in_gbps,omitempty"`

	// The total number of OCPUs available to the container instance.
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`

	// A short description of the container instance's processor (CPU).
	ProcessorDescription *string `json:"processorDescription,omitempty" tf:"processor_description,omitempty"`
}

type ShapeConfigParameters struct {

	// The total amount of memory available to the container instance (GB).
	// +kubebuilder:validation:Optional
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// The total number of OCPUs available to the container instance.
	// +kubebuilder:validation:Optional
	Ocpus *float64 `json:"ocpus" tf:"ocpus,omitempty"`
}

type VnicsInitParameters struct {

	// Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}.
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information. If you don't provide a name, a name is generated automatically.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The hostname for the VNIC's primary private IP. Used for DNS.
	HostnameLabel *string `json:"hostnameLabel,omitempty" tf:"hostname_label,omitempty"`

	// Whether the VNIC should be assigned a public IP address.
	IsPublicIPAssigned *bool `json:"isPublicIpAssigned,omitempty" tf:"is_public_ip_assigned,omitempty"`

	// A list of the OCIDs of the network security groups (NSGs) to add the VNIC to.
	// +listType=set
	NsgIds []*string `json:"nsgIds,omitempty" tf:"nsg_ids,omitempty"`

	// A private IP address of your choice to assign to the VNIC. Must be an available IP address within the subnet's CIDR.
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// Whether the source/destination check is disabled on the VNIC.
	SkipSourceDestCheck *bool `json:"skipSourceDestCheck,omitempty" tf:"skip_source_dest_check,omitempty"`

	// The OCID of the subnet to create the VNIC in.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type VnicsObservation struct {

	// Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}.
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information. If you don't provide a name, a name is generated automatically.
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The hostname for the VNIC's primary private IP. Used for DNS.
	HostnameLabel *string `json:"hostnameLabel,omitempty" tf:"hostname_label,omitempty"`

	// Whether the VNIC should be assigned a public IP address.
	IsPublicIPAssigned *bool `json:"isPublicIpAssigned,omitempty" tf:"is_public_ip_assigned,omitempty"`

	// A list of the OCIDs of the network security groups (NSGs) to add the VNIC to.
	// +listType=set
	NsgIds []*string `json:"nsgIds,omitempty" tf:"nsg_ids,omitempty"`

	// A private IP address of your choice to assign to the VNIC. Must be an available IP address within the subnet's CIDR.
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// Whether the source/destination check is disabled on the VNIC.
	SkipSourceDestCheck *bool `json:"skipSourceDestCheck,omitempty" tf:"skip_source_dest_check,omitempty"`

	// The OCID of the subnet to create the VNIC in.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// The identifier of the virtual network interface card (VNIC) over which the containers accessing this network can communicate with the larger virtual cloud network.
	VnicID *string `json:"vnicId,omitempty" tf:"vnic_id,omitempty"`
}

type VnicsParameters struct {

	// Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information. If you don't provide a name, a name is generated automatically.
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The hostname for the VNIC's primary private IP. Used for DNS.
	// +kubebuilder:validation:Optional
	HostnameLabel *string `json:"hostnameLabel,omitempty" tf:"hostname_label,omitempty"`

	// Whether the VNIC should be assigned a public IP address.
	// +kubebuilder:validation:Optional
	IsPublicIPAssigned *bool `json:"isPublicIpAssigned,omitempty" tf:"is_public_ip_assigned,omitempty"`

	// A list of the OCIDs of the network security groups (NSGs) to add the VNIC to.
	// +kubebuilder:validation:Optional
	// +listType=set
	NsgIds []*string `json:"nsgIds,omitempty" tf:"nsg_ids,omitempty"`

	// A private IP address of your choice to assign to the VNIC. Must be an available IP address within the subnet's CIDR.
	// +kubebuilder:validation:Optional
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// Whether the source/destination check is disabled on the VNIC.
	// +kubebuilder:validation:Optional
	SkipSourceDestCheck *bool `json:"skipSourceDestCheck,omitempty" tf:"skip_source_dest_check,omitempty"`

	// The OCID of the subnet to create the VNIC in.
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`
}

type VolumeMountsInitParameters struct {

	// Whether the volume was mounted in read-only mode. By default, the volume is not read-only.
	IsReadOnly *bool `json:"isReadOnly,omitempty" tf:"is_read_only,omitempty"`

	// The volume access path.
	MountPath *string `json:"mountPath,omitempty" tf:"mount_path,omitempty"`

	// If there is more than one partition in the volume, reference this number of partitions. Here is an example: Number  Start   End     Size    File system  Name                  Flags 1      1049kB  106MB   105MB   fat16        EFI System Partition  boot, esp 2      106MB   1180MB  1074MB  xfs 3      1180MB  50.0GB  48.8GB                                     lvm
	Partition *float64 `json:"partition,omitempty" tf:"partition,omitempty"`

	// A subpath inside the referenced volume.
	SubPath *string `json:"subPath,omitempty" tf:"sub_path,omitempty"`

	// The name of the volume. Avoid entering confidential information.
	VolumeName *string `json:"volumeName,omitempty" tf:"volume_name,omitempty"`
}

type VolumeMountsObservation struct {

	// Whether the volume was mounted in read-only mode. By default, the volume is not read-only.
	IsReadOnly *bool `json:"isReadOnly,omitempty" tf:"is_read_only,omitempty"`

	// The volume access path.
	MountPath *string `json:"mountPath,omitempty" tf:"mount_path,omitempty"`

	// If there is more than one partition in the volume, reference this number of partitions. Here is an example: Number  Start   End     Size    File system  Name                  Flags 1      1049kB  106MB   105MB   fat16        EFI System Partition  boot, esp 2      106MB   1180MB  1074MB  xfs 3      1180MB  50.0GB  48.8GB                                     lvm
	Partition *float64 `json:"partition,omitempty" tf:"partition,omitempty"`

	// A subpath inside the referenced volume.
	SubPath *string `json:"subPath,omitempty" tf:"sub_path,omitempty"`

	// The name of the volume. Avoid entering confidential information.
	VolumeName *string `json:"volumeName,omitempty" tf:"volume_name,omitempty"`
}

type VolumeMountsParameters struct {

	// Whether the volume was mounted in read-only mode. By default, the volume is not read-only.
	// +kubebuilder:validation:Optional
	IsReadOnly *bool `json:"isReadOnly,omitempty" tf:"is_read_only,omitempty"`

	// The volume access path.
	// +kubebuilder:validation:Optional
	MountPath *string `json:"mountPath" tf:"mount_path,omitempty"`

	// If there is more than one partition in the volume, reference this number of partitions. Here is an example: Number  Start   End     Size    File system  Name                  Flags 1      1049kB  106MB   105MB   fat16        EFI System Partition  boot, esp 2      106MB   1180MB  1074MB  xfs 3      1180MB  50.0GB  48.8GB                                     lvm
	// +kubebuilder:validation:Optional
	Partition *float64 `json:"partition,omitempty" tf:"partition,omitempty"`

	// A subpath inside the referenced volume.
	// +kubebuilder:validation:Optional
	SubPath *string `json:"subPath,omitempty" tf:"sub_path,omitempty"`

	// The name of the volume. Avoid entering confidential information.
	// +kubebuilder:validation:Optional
	VolumeName *string `json:"volumeName" tf:"volume_name,omitempty"`
}

type VolumesInitParameters struct {

	// (Applicable when volume_type=EMPTYDIR) The volume type of the empty directory, can be either File Storage or Memory.
	BackingStore *string `json:"backingStore,omitempty" tf:"backing_store,omitempty"`

	// (Applicable when volume_type=CONFIGFILE) Contains key value pairs which can be mounted as individual files inside the container. The value needs to be base64 encoded. It is decoded to plain text before the mount.
	Configs []ConfigsInitParameters `json:"configs,omitempty" tf:"configs,omitempty"`

	// Container HTTP header Key.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The type of volume.
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type VolumesObservation struct {

	// (Applicable when volume_type=EMPTYDIR) The volume type of the empty directory, can be either File Storage or Memory.
	BackingStore *string `json:"backingStore,omitempty" tf:"backing_store,omitempty"`

	// (Applicable when volume_type=CONFIGFILE) Contains key value pairs which can be mounted as individual files inside the container. The value needs to be base64 encoded. It is decoded to plain text before the mount.
	Configs []ConfigsObservation `json:"configs,omitempty" tf:"configs,omitempty"`

	// Container HTTP header Key.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The type of volume.
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type VolumesParameters struct {

	// (Applicable when volume_type=EMPTYDIR) The volume type of the empty directory, can be either File Storage or Memory.
	// +kubebuilder:validation:Optional
	BackingStore *string `json:"backingStore,omitempty" tf:"backing_store,omitempty"`

	// (Applicable when volume_type=CONFIGFILE) Contains key value pairs which can be mounted as individual files inside the container. The value needs to be base64 encoded. It is decoded to plain text before the mount.
	// +kubebuilder:validation:Optional
	Configs []ConfigsParameters `json:"configs,omitempty" tf:"configs,omitempty"`

	// Container HTTP header Key.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// The type of volume.
	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType" tf:"volume_type,omitempty"`
}

// InstancesContainerInstanceSpec defines the desired state of InstancesContainerInstance
type InstancesContainerInstanceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     InstancesContainerInstanceParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider InstancesContainerInstanceInitParameters `json:"initProvider,omitempty"`
}

// InstancesContainerInstanceStatus defines the observed state of InstancesContainerInstance.
type InstancesContainerInstanceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        InstancesContainerInstanceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// InstancesContainerInstance is the Schema for the InstancesContainerInstances API. Provides the Container Instance resource in Oracle Cloud Infrastructure Container Instances service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type InstancesContainerInstance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.availabilityDomain) || (has(self.initProvider) && has(self.initProvider.availabilityDomain))",message="spec.forProvider.availabilityDomain is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.compartmentId) || (has(self.initProvider) && has(self.initProvider.compartmentId))",message="spec.forProvider.compartmentId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.containers) || (has(self.initProvider) && has(self.initProvider.containers))",message="spec.forProvider.containers is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.shape) || (has(self.initProvider) && has(self.initProvider.shape))",message="spec.forProvider.shape is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.shapeConfig) || (has(self.initProvider) && has(self.initProvider.shapeConfig))",message="spec.forProvider.shapeConfig is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.vnics) || (has(self.initProvider) && has(self.initProvider.vnics))",message="spec.forProvider.vnics is a required parameter"
	Spec   InstancesContainerInstanceSpec   `json:"spec"`
	Status InstancesContainerInstanceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// InstancesContainerInstanceList contains a list of InstancesContainerInstances
type InstancesContainerInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []InstancesContainerInstance `json:"items"`
}

// Repository type metadata.
var (
	InstancesContainerInstance_Kind             = "InstancesContainerInstance"
	InstancesContainerInstance_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: InstancesContainerInstance_Kind}.String()
	InstancesContainerInstance_KindAPIVersion   = InstancesContainerInstance_Kind + "." + CRDGroupVersion.String()
	InstancesContainerInstance_GroupVersionKind = CRDGroupVersion.WithKind(InstancesContainerInstance_Kind)
)

func init() {
	SchemeBuilder.Register(&InstancesContainerInstance{}, &InstancesContainerInstanceList{})
}
