/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type StorageFileSystemQuotaRuleInitParameters struct {
	AreViolatorsOnly *bool `json:"areViolatorsOnly,omitempty" tf:"are_violators_only,omitempty"`

	// (Updatable) A user-friendly name. It does not have to be unique, and it is changeable. Avoid entering confidential information. Example: UserXYZ's quota
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The OCID of the file system.
	FileSystemID *string `json:"fileSystemId,omitempty" tf:"file_system_id,omitempty"`

	// The flag is an identifier to tell whether the quota rule will be enforced. If isHardQuota is true, the quota rule will be enforced so the write will be blocked if usage exceeds the hard quota limit. If isHardQuota is false, usage can exceed the soft quota limit. An alarm or notification will be sent to the customer, if the specific usage exceeds.
	IsHardQuota *bool `json:"isHardQuota,omitempty" tf:"is_hard_quota,omitempty"`

	// An identifier for the owner of this usage and quota rule. Unix-like operating systems use this integer value to identify a user or group to manage access control.
	PrincipalID *float64 `json:"principalId,omitempty" tf:"principal_id,omitempty"`

	// The type of the owner of this quota rule and usage.
	PrincipalType *string `json:"principalType,omitempty" tf:"principal_type,omitempty"`

	// (Updatable) The value of the quota rule. The unit is Gigabyte.
	QuotaLimitInGigabytes *float64 `json:"quotaLimitInGigabytes,omitempty" tf:"quota_limit_in_gigabytes,omitempty"`

	// The identifier of the quota rule. It is the base64 encoded string of the tuple <principalId, principalType, isHardQuota>.
	QuotaRuleID *string `json:"quotaRuleId,omitempty" tf:"quota_rule_id,omitempty"`
}

type StorageFileSystemQuotaRuleObservation struct {
	AreViolatorsOnly *bool `json:"areViolatorsOnly,omitempty" tf:"are_violators_only,omitempty"`

	// (Updatable) A user-friendly name. It does not have to be unique, and it is changeable. Avoid entering confidential information. Example: UserXYZ's quota
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The OCID of the file system.
	FileSystemID *string `json:"fileSystemId,omitempty" tf:"file_system_id,omitempty"`

	// The identifier of the quota rule. It is the base64 encoded string of the tuple <principalId, principalType, isHardQuota>.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The flag is an identifier to tell whether the quota rule will be enforced. If isHardQuota is true, the quota rule will be enforced so the write will be blocked if usage exceeds the hard quota limit. If isHardQuota is false, usage can exceed the soft quota limit. An alarm or notification will be sent to the customer, if the specific usage exceeds.
	IsHardQuota *bool `json:"isHardQuota,omitempty" tf:"is_hard_quota,omitempty"`

	// An identifier for the owner of this usage and quota rule. Unix-like operating systems use this integer value to identify a user or group to manage access control.
	PrincipalID *float64 `json:"principalId,omitempty" tf:"principal_id,omitempty"`

	// The type of the owner of this quota rule and usage.
	PrincipalType *string `json:"principalType,omitempty" tf:"principal_type,omitempty"`

	// (Updatable) The value of the quota rule. The unit is Gigabyte.
	QuotaLimitInGigabytes *float64 `json:"quotaLimitInGigabytes,omitempty" tf:"quota_limit_in_gigabytes,omitempty"`

	// The identifier of the quota rule. It is the base64 encoded string of the tuple <principalId, principalType, isHardQuota>.
	QuotaRuleID *string `json:"quotaRuleId,omitempty" tf:"quota_rule_id,omitempty"`

	// The date and time the quota rule was started, expressed in RFC 3339 timestamp format.  Example: 2016-08-25T21:10:29.600Z
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The date and time the quota rule was last updated, expressed in RFC 3339 timestamp format.  Example: 2016-08-25T21:10:29.600Z
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`
}

type StorageFileSystemQuotaRuleParameters struct {

	// +kubebuilder:validation:Optional
	AreViolatorsOnly *bool `json:"areViolatorsOnly,omitempty" tf:"are_violators_only,omitempty"`

	// (Updatable) A user-friendly name. It does not have to be unique, and it is changeable. Avoid entering confidential information. Example: UserXYZ's quota
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The OCID of the file system.
	// +kubebuilder:validation:Optional
	FileSystemID *string `json:"fileSystemId,omitempty" tf:"file_system_id,omitempty"`

	// The flag is an identifier to tell whether the quota rule will be enforced. If isHardQuota is true, the quota rule will be enforced so the write will be blocked if usage exceeds the hard quota limit. If isHardQuota is false, usage can exceed the soft quota limit. An alarm or notification will be sent to the customer, if the specific usage exceeds.
	// +kubebuilder:validation:Optional
	IsHardQuota *bool `json:"isHardQuota,omitempty" tf:"is_hard_quota,omitempty"`

	// An identifier for the owner of this usage and quota rule. Unix-like operating systems use this integer value to identify a user or group to manage access control.
	// +kubebuilder:validation:Optional
	PrincipalID *float64 `json:"principalId,omitempty" tf:"principal_id,omitempty"`

	// The type of the owner of this quota rule and usage.
	// +kubebuilder:validation:Optional
	PrincipalType *string `json:"principalType,omitempty" tf:"principal_type,omitempty"`

	// (Updatable) The value of the quota rule. The unit is Gigabyte.
	// +kubebuilder:validation:Optional
	QuotaLimitInGigabytes *float64 `json:"quotaLimitInGigabytes,omitempty" tf:"quota_limit_in_gigabytes,omitempty"`

	// The identifier of the quota rule. It is the base64 encoded string of the tuple <principalId, principalType, isHardQuota>.
	// +kubebuilder:validation:Optional
	QuotaRuleID *string `json:"quotaRuleId,omitempty" tf:"quota_rule_id,omitempty"`
}

// StorageFileSystemQuotaRuleSpec defines the desired state of StorageFileSystemQuotaRule
type StorageFileSystemQuotaRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     StorageFileSystemQuotaRuleParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider StorageFileSystemQuotaRuleInitParameters `json:"initProvider,omitempty"`
}

// StorageFileSystemQuotaRuleStatus defines the observed state of StorageFileSystemQuotaRule.
type StorageFileSystemQuotaRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        StorageFileSystemQuotaRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// StorageFileSystemQuotaRule is the Schema for the StorageFileSystemQuotaRules API. Provides the File System Quota Rule resource in Oracle Cloud Infrastructure File Storage service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type StorageFileSystemQuotaRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.fileSystemId) || (has(self.initProvider) && has(self.initProvider.fileSystemId))",message="spec.forProvider.fileSystemId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.isHardQuota) || (has(self.initProvider) && has(self.initProvider.isHardQuota))",message="spec.forProvider.isHardQuota is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.principalType) || (has(self.initProvider) && has(self.initProvider.principalType))",message="spec.forProvider.principalType is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.quotaLimitInGigabytes) || (has(self.initProvider) && has(self.initProvider.quotaLimitInGigabytes))",message="spec.forProvider.quotaLimitInGigabytes is a required parameter"
	Spec   StorageFileSystemQuotaRuleSpec   `json:"spec"`
	Status StorageFileSystemQuotaRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// StorageFileSystemQuotaRuleList contains a list of StorageFileSystemQuotaRules
type StorageFileSystemQuotaRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []StorageFileSystemQuotaRule `json:"items"`
}

// Repository type metadata.
var (
	StorageFileSystemQuotaRule_Kind             = "StorageFileSystemQuotaRule"
	StorageFileSystemQuotaRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: StorageFileSystemQuotaRule_Kind}.String()
	StorageFileSystemQuotaRule_KindAPIVersion   = StorageFileSystemQuotaRule_Kind + "." + CRDGroupVersion.String()
	StorageFileSystemQuotaRule_GroupVersionKind = CRDGroupVersion.WithKind(StorageFileSystemQuotaRule_Kind)
)

func init() {
	SchemeBuilder.Register(&StorageFileSystemQuotaRule{}, &StorageFileSystemQuotaRuleList{})
}
